<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaSE-流程控制语句</title>
    <url>/2020/03/14/JavaSE-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>1.程序流程控制-语句if<br>程序流程控制有四种结构：顺序结构、判断结构、选择结构、循环结构。<br>判断结构-if语句<br>三种格式<br>第一种<br>if(条件表达式)<br>{<br>    执行语句;<br>    }</p>
<a id="more"></a>
<p>注意：if语句要明确控制范围，用大括号来控制，但当if语句中控制语句是单条语句时大括号可以省略。如果if语句没写大括号，就只能控制离它最近的单条语句。</p>
<p>这里单条语句不是指单行语句。如下图中，红色方框可以看成一个单条语句，所以外面的两个红圈圈起来的大括号可以省略。</p>
<p>第二种<br>if(条件表达式)<br>{<br>    执行语句;<br>}else{<br>    执行语句;<br>}</p>
<p>注意：三运运算符就是if else 语句简写格式。简写格式是运算符，必须要有运算结果，否则不能运行。简写格式当ifesle运算后有一个具体的结果时，可以简化成三元运算符。<br>第三种<br>if(条件表达式)<br>{<br>    执行语句;<br>}else if(条件表达式){<br>    执行语句;<br>}<br>…<br>else{<br>    执行语句;<br>}<br>这里再来一个括号省略的例子</p>
<p>2.局部代码块<br>任何在大括号之间的叫做代码块，加了if，就是if代码块，还有主函数代码块，类代码块如：</p>
<p>如果前面什么也没有，就叫局部代码块。</p>
<p>局部代码块可以定义局部变量的生命周期，可以有效腾出内存空间。</p>
<p>3.语句-switch<br>选择结构-switch<br>switch(表达式)<br>{<br>    case 取值1:<br>    break;<br>    case 取值2:<br>    执行语句;<br>    break;<br>    …<br>    default:默认<br>    执行语句;<br>    break;<br>}<br>Switch语句只支持byte、short、int、char四种类型值。<br>备选答案是无序的，不是某个选择一定要放在第几个，但是执行是有顺序的。必须先执行case再执行default。<br>Switch结束方式有两种，一种是break结束，一种是执行到大括号结束，所以在最后的选择中，break是可以省略的。</p>
<p>若是这种情况，default和case4没有break，运行过程是先case4、case1、case3判断，然后不属于就来到default，判断对了之后，由于没有break，就继续执行可执行的语句。因为case是执行过，不会再执行，所以就直接执行System.out.printIn，直到遇到break，所以最后结果是：</p>
<p>3.switch与if的区别<br>If：<br>1.对具体的值进行判断<br>2.对区间进行判断<br>3.对运算结果是boolean类型的表达式进行判断</p>
<p>Switch:<br>1.对具体的值进行判断<br>2.值的个数通常的是固定的<br>对于几个固定的值判断建议使用switch语句，因为switch语句会将具体的答案都加载进内存，效率相对高一些。</p>
<p>4.while、do while语句<br>循环结构-while、do while、for<br>While语句<br>while(条件表达式)<br>{<br>    执行语句;<br>}</p>
<p>Do while<br>do<br>{<br>    执行语句;<br>}<br>while(条件表达式);</p>
<p>do while语句特点：无论条件是否满足，循环体至少执行一次。</p>
<p>5.while练习-计数器思想<br>需求：求1~100中6的倍数有几个</p>
<p>6.for语句<br>for(初始化表达式;循环条件表达式;循环后的操作表达式)<br>{<br>    执行语句;(循环体)<br>}</p>
<p>其中需要明白for循环基本运行过程。</p>
<p>有时候也会有上述形式，需要注意不要固化思维。</p>
<p>7.for和while的区别<br>1.for和while可以互换。<br>2.格式上的不同，在使用上有点小区别。<br>如果需要通过变量来对循环进行控制，该变量只作为循环增量的存在，区别就体现出来。<br>即在for括号里面进行的初始化表达式只在for循环中使用，一旦for循环结束，这个量就从内存中移除。</p>
<p>有时候会用到无限循环，所以给出两者无限循环的最简单的表达式</p>
<p>for的三个表达式都可以不写。头尾两个不写就是没有，中间的不写就是默认为true。<br>使用循环结构的场景：<br>当对某些代码执行很多次时，使用循环结构完成。<br>当对一个条件进行一次判断时，可以使用if语句。<br>当对一个条件进行多次判断时，可以使用while语句。<br>注意：1.在使用循环时，一定要明确哪些语句要参与循环，哪些不需要。<br>    2.循环通常情况下需要定义条件和控制次数。</p>
<p>8.for循环嵌套练习</p>
<p>9.语句-break&amp;continue<br>break:跳出<br>break作用范围：要么是switch语句，要么是循环语句。<br>注意：当break语句单独存在时，下面不要定义其他语句，因为执行不到。<br>如：</p>
<p>这种情况并不是break控制if语句，因为break只能控制switch和循环。这里它只是作为if的一个执行，当循环到x=1时，就执行break。</p>
<p>break跳出所在的当前循环<br>如果出现了循环嵌套，break想要跳出指定的循环，可以通过标号来完成。</p>
<p>Continue:<br>continue:结束本次循环，继续下次循环<br>作用范围：循环结构。<br>如果continue单独存在时，下面不要有任何语句，因为执行不到。</p>
<p>这种情况与break类似，同样执行不到下面语句。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-运算</title>
    <url>/2020/03/14/JavaSE-%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>基本的运算，运算两端必须是同一类型数值。<br>1.类型提升和强制转换<br>如果两端是数值型，不是同一类型也可以计算。因为计算时会把不同类型转换成相同类型进行计算，以占用内存比较大的为主。占用内存较小的会进行自动类型提升，如从一个字节提升为四个字节，这个过程是自动进行，最后得结果类型与内存占用较大的一致。如上述情况。</p>
<p>这种情况进行编译时会报错，说是缺少精度。因为4是默认为Int型，在计算完b=b+4时，b的类型变为int型，而不是byte，所以会报错。如果非要是byte型，则进行强制转换</p>
<p>它会将高位的字节略去不要，留下低位字节。如何计算完的数在高位字节中有占用，则计算出来的结果不会有高位字节，结果会出现错误。所以强制类型转换会有风险。</p>
<a id="more"></a>
<p>2.字符类型运算过程<br>(‘a’ + 1)<br>对于括号里面的运算，是可以进行编译的，且得出来的结果是98。这里要首先知道存在一个二进制的生活中文字的对应关系表，也就是编码表，简称ASCII。这个表里面只有英文字母，数字和一些符号与二进制的对应关系。其中对应的二进制就是01100001，十进制中也就是97。在上述的计算中，其过程是首先将a转化为编码表里对应的二进制数（占两个字节）然后1是默认为int类型，占4个字节，将a进行类型升级，二者再相加，得到结果98。若想得到字符，则在前面加char，进行强制转换。<br>(char)(‘a’ + 1)<br>A对应65，a对应97,0对应48。<br>中文和二进制也有一一对应的关系，其形成的表叫做GB2312。后期扩展成GBK，之后又扩展成GB18030。<br>存在一个Unicode码表，含有国际上各个文字的码表。基本上都是有国际标准码表来完成。</p>
<p>3.类型运算细节</p>
<p>这种情况下，编译器会报错，说是缺少精度，应该转成int类型，请问原因（面试题）<br>在一开始中，byte b=4，系统检测4，发现int型的4是可以用byte表示，于是默认将int型的4强制转换成byte型。但是在上述图片中b=b1+b2，b1和b2都是变量，就算前面赋值，系统也是检测是变量，变量的话就不知道值是什么，如何还是强行转换成byte类型的话，是有可能装不下的，所以要转换成int类型。<br>如果int运算中也超了，编译是可以的，但是结果是，本来int最多是32位，超出的话会到33位及以上，这是系统就会把33位及以上的位数舍弃，只剩下32位，所以只显示32位的结果。</p>
<p>4.算术运算符和赋值运算符<br>算术运算符有<br> ‘+’- * /    java是强位型语言，其中两个整数除法运算会自动转换，舍弃小数点后的数字。<br>%（取余，模运算）  模运算，5%2是1,-5%2是-1,5%-2是1，所以模运算有符号看被模数，被模数是负，结果就是负。<br>+（连接） 任何数据用+与字符串相加，都是相连接。</p>
<p>++（自增，在原有数据基础上+1，再赋值给原有数据）<br>a=3；b=a++；这时的运算过程是a要自增，在自增之前，若参与了其他运算，先进行了a自己值的保留值的动作，再自增，再将保留值进行运算。<br>int i=3;i=i++;这时i的值是3。<br>–同上<br>赋值运算符 =、+=、-=、/=、*=、%=<br>int a=4;a+=2;该意思为左边等于左右两边的和即a=4+2=6<br>+=也是赋值运算符，也有做转换动作，底层会自动做强转。如下图：</p>
<p>5.比较运算符&amp;逻辑运算符<br>比较运算符<br>比较运算符运算完必定有结果，它的运算结果要么是true，要么是false。</p>
<p>例：</p>
<p>逻辑运算符<br>逻辑运算符用于连接两个boolean类型的表达式<br>例：<br>&amp;与</p>
<p>|或</p>
<p>^异或<br>和或有些不同，两边都是true或false结果的话，结果是false，即两边比较结果都是一样的话是false，不同则是true。</p>
<p>！非<br>判断事物的另一面<br>!true=false; !false=true; !!true=true<br>&amp;&amp;双与<br>运算结果和单与相同，过程不同，双与只要符号左边一旦为假，则不再执行右边的运算，运算为假。单与则是无论左边的运算结果是什么，右边都参与运算。（面试会涉及）<br>||双或<br>运算结果和单或相同，过程不同，双或只要符号左边一旦为真，则不再执行右边的运算，运算为真。单或则是无论左边的运算结果是什么，右边都参与运算。</p>
<p>6.位运算符<br>这里注意<br>与运算符可以保留想要的后几位数</p>
<p>或运算符可以保留有效位即1</p>
<p>异或运算符中，一个数异或同一个数两次，结果还是这个数，可以用来加密。</p>
<p>7.移位运算符<br>左移&lt;&lt;：<br>如3&lt;&lt;2，将3左移两位，先把3表示成二进制形式，然后左移两位，结果是12。同理3&lt;&lt;3，3左移三位，结果是24，可以发现左移几位就是该数据乘以2的几次方。左移可以完成2的次幂运算。<br>右移&gt;&gt;：<br>注意：右移后高位出现的空位，原来高位是什么就用什么补这个空位。如负数前面是1则就用1来补充。然后右移几位，其实就是该数据除以2的几次幂。<br>无符号右移&gt;&gt;&gt;：<br>数据进行右移时，高位出现的空位，无论原高位是什么，空位都用0补。</p>
<p>8.位运算符练习<br>1.最有效的方式算出2乘以8等于几？<br>想要运算高效，一般选用位运算。直接对二进制位上的数据进行操作。<br>所以这道题我们观察到8是2的三次方，可以直接使用左移位运算，即2&lt;&lt;3，这样运算的效率更高。</p>
<p>2.对两个整数变量进行互换（不需要第三方变量）</p>
<p>这种用了第三方变量，一般在开发时都是使用这种方法，因为能够提高阅读性。</p>
<p>但开发时不用，因为阅读性低</p>
<p>9.三元运算符<br>三个元素参与运算的符号。无论表达形式什么样，都是运算符。只要是运算符，肯定就有结果<br>格式<br>(条件表达式) ? 表达式1 : 表达式2；<br>条件为true 结果是表达式1；条件为false结果是表达式2；<br>例：获取两个整数中较大的整数</p>
<p>获取三个整数中较大的整数</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-函数</title>
    <url>/2020/03/13/JavaSE-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>1 函数-定义<br>定义：定义在类中的具有特定功能的一段独立小程序。函数也称方法。</p>
<p>2 函数-格式<br>定义函数的格式：<br>    修饰符 返回值类型 函数名（参数类型 形式参数1，参数类型 形式参数2，…）<br>    {<br>        执行语句；<br>        return 返回值；<br>    }</p>
<a id="more"></a>
<p>函数名若是用到多个单词，则第一个单词首字母小写，后面的单词首字母大写。<br>形式参数也可以没有。<br>Return除了返回值的作用还有结束函数的作用。</p>
<p>3 函数-细节-void<br>特殊情况：<br>    功能没有具体的返回值。<br>    这时return的后面直接用分号结束。<br>    返回值类型怎么体现？因为没有具体值，所以不可以写具体的数据类型。<br>    在JAVA中，只能用一个关键字来表示这种情况。关键字是：void<br>    总结：没有具体返回值时，返回值类型用void来表示<br>注意：如果返回值类型是void，那么函数中的return语句可以省略不写。</p>
<p>4、5 函数-细节-错误格式、定义思想错误<br>函数的特点：<br>定义函数可以将功能代码进行封装<br>便于对该功能进行复用<br>函数只有被调用才会被执行<br>函数的出现提高了代码的复用性<br>注意：<br>(1)函数中只能调用函数，不可以在函数内部定义函数。<br>(2)定义函数时，函数的结果应该返回给调用者，交由调用者处理。<br>如果想要在System.out.println(函数)中有结果，则函数不能是void类型，因为void类型没有返回值，没有输出结果。</p>
<p>6、7 、8函数-两个明确、练习<br>通过两个明确来完成<br>    明确1：这个功能的结果是什么？<br>    是和。是功能的结果，所以该功能的返回值类型是int。<br>    其实就是在明确函数的返回类型。<br>    明确2：这个功能实现过程中是否需要未知内容参与运算？<br>    有，加数和被加数。这就是函数的参数列表（参数的个数、参数类型）<br>    其实就是在明确参数列表<br>注意：返回值类型和参数类型没有直接关系。</p>
<p>9 函数-内存加载过程<br>Java虚拟机先运行main函数，当遇到新函数或方法时，调用其，开始占用内存空间。等函数或方法调用结束，就不再占用内存，继续main函数，知道main函数执行完毕，也移出内存。<br>在这里提到栈的概念<br>特点：先进后出，先进来的放在栈底。</p>
<p>10 函数-重载<br>概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。<br>特点：与返回值类型无关，只看参数列表。<br>Java是严谨性语言，如果出现的调用的不确定性，会编译失败。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-语言基础</title>
    <url>/2020/03/13/JavaSE-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>任何高级语言的基础组成<br>关键字、运算符、标识符、语句、注释、函数、常量与变量、数组</p>
<p>01 关键字<br>被赋予特殊java含义的单词<br>一般情况下，关键字全部是小写</p>
<a id="more"></a>
<p>02 标识符<br>在程序中自定义的一些名称。<br>由26个英文字母大小写，数字：0-9，符号：_$组成<br>定义符合标识符规则：<br>1.数字不可以开头<br>2.不可以使用关键字<br>Java中严格区分大小写。凡是名称都可以算是标识符，比如main函数中的main。</p>
<p>03 注释<br>用于注解说明程序中的文字。<br>单行注释：//说明文字。<br>多行注释：/*<br>          说明<br>          文字。<br>          <em>/<br>文档注释：java特有注释<br>/**<br>文档注释。<br><em>/<br>文档注释可以被javadoc提取，将文字和代码生成一个网页，形成程序说明书。<br>单行注释里面可以嵌套单行注释，即//asd//asd<br>单行注释里面可以嵌套多行注释，即//asd/</em>asd</em>/asd<br>多行注释里面可以嵌套单行注释，即/<em>asd//asd <em>/<br>多行注释里面可以嵌套多行注释，即/</em>asd/*asd</em>/，这里注意后面只有一个*/。<br>注释文字在编译时不编译进去。</p>
<p>04 注释的应用<br>工作或者面试时写代码，一定要添加注释。<br>以后一开始写程序时先写多行注释。</p>
<p>05 常量<br>表示不能改变的数值<br>分类：</p>
<ol>
<li>整数常量。所有整数 如2</li>
<li>小数常量。所有小数 如1.2</li>
<li>布尔（boolean）型常量。较为特殊，只有两个数值：true false</li>
<li>字符常量。将一个数字字母或者符号用单引号(‘’)标识 如‘2’‘a’</li>
<li>字符串常量。将一个或者过个字符用双引号(“”)标识 如“212”“asd”</li>
<li>null常量（空常量）。只有一种数值就是null。</li>
</ol>
<p>06 进制的由来<br>对于整数有四种表现形式<br>二进制：0.1，满2进1<br>八进制：0-7，满8进1，用0开头表示<br>十进制：0-9，满10进1<br>十六进制：0-9，A-F，满16进1.用0x开头表示</p>
<p>将八个二进制位成一个数据存储最小单元，称之为byte字节<br>每一个二进制位叫做bit位<br>1k=1024字节；<br>由于这样8个表示太麻烦，于是让三个bit位为一组，为八进制，四个为一组为16进制</p>
<p>07 进制转换<br>由于这样8个表示太麻烦，于是让三个bit位为一组，为八进制，四个为一组为16进制<br>这也是二进制转换成八进制和十六进制的比较快速的转换方法，例如<br>二进制10101110<br>转换成八进制，先以三个为一组，个数不够前面加0。再分别算出每组二进制对应的十进制，然后便得出八进制，如<br>010-101-110<br> 2   5   6即八进制表示就是0256<br>转换成十六进制<br>1010-1110<br> 10   14  即十六进制表示就是0xAE<br>结论：<br>八进制数，其实就是二进制位，3个二进制位为一个八进制<br>十六进制，其实就是二进制位，4个二进制位为一个十六进制</p>
<p>十进制转化成二进制<br>用2除取余数的方法，再从下往上看。</p>
<p>08 负数的进制<br>负数的二进制就是这个数的正数的二进制取反，加1<br>如-6<br>0000-0110 取反 1111-1001 加1即+0000-0001<br>等于1111-1010<br>凡是负数，其二进制的最高位是1</p>
<p>09 变量的介绍<br>概念：变量是内存中的一个存储区域，用来存储不确定的数据。当数据不确定时就要使用变量。<br>      该区域有自己的名称（变量名）和类型（数据类型），不同类型的数据不能放在同一区域<br>      该区域的数据可以在同一类型范围内不断变化<br>目的：用来不断地存放同一类型的常量，并可以重复使用。<br>注意：变量的作用范围<br>      初始化值<br>定义变量的格式：<br>数据类型 变量名=初始化值<br>注：格式是固定的，记住格式，以不变应万变<br>Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。<br>数据类型分为基本数据类型和引用数据类型<br>基本数据类型分为数值型、字符型和布尔型<br>数值型有整数类型（byte,short,int,long）<br>Byte：字节，内存中占一个八位，-27到27-1，即-128至127<br>Short：短整型，内存从占两个字节即16个比特位，-215到215-1<br>Int：内存占4个比特位，-231到231-1<br>Long：长整型，内存占8个比特位<br>一般情况下，整数默认为int类型。<br>浮点类型（float,double）<br>Float：单精度，由4个字节表示<br>Double：双精度，由8个字节表示<br>一般情况下，小数默认为double类型。<br>字符型（char）：取值范围0到65535，即两个字节。‘12’不能存放，但是一个中文比如你好的你，可以存放。<br>布尔型（boolean）：<br>以上8个都是关键字。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的一些基本操作</title>
    <url>/2020/03/06/hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="创建新文章并部署到远端"><a href="#创建新文章并部署到远端" class="headerlink" title="创建新文章并部署到远端"></a>创建新文章并部署到远端</h2><p>1.执行 hexo new[layout] 文章名 即可<br>layout为布局，Hexo有三种默认布局：post、page和draft，默认为post，可以在_config.yml中的default_layout 参数来指定默认布局</p>
<p>2.文章写完后保存文件，执行 hexo generate 或 hexo g 生成静态文件</p>
<p>3.执行 hexo deploy 将文件部署到远端</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/03/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这是我的第一个技术博客<br>希望能坚持下去，见证接下来的变化！</p>
<a id="more"></a>
<h2 id="639"><a href="#639" class="headerlink" title="639"></a>639</h2><p>639天下第一，不接受反驳</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
