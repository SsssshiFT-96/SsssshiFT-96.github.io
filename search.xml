<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaSE-其他对象API</title>
    <url>/2020/03/26/JavaSE-%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1API/</url>
    <content><![CDATA[<h1 id="其他对象API"><a href="#其他对象API" class="headerlink" title="其他对象API"></a>其他对象API</h1><h2 id="1-System类"><a href="#1-System类" class="headerlink" title="1 System类"></a>1 <strong>System类</strong></h2><p>System类包含一些有用的类字段和方法，它不能被实例化，即构造函数不对外提供。</p>
<p>System：类中的方法和属性都是静态的。</p>
<p>字段有：out、in、err    </p>
<p>常见方法：</p>
<p>long currentTimeMillis();获取当前时间的毫秒值。</p>
<a id="more"></a>

<p><strong>Properties类</strong></p>
<p>获取系统的属性信息，并存储到Properties集合中，Properties集合是map集合的子类</p>
<p>Properties集合中存储都是String类型的键和值</p>
<p>最好使用它自己的存储和取出的方法来完成元素的操作</p>
<p>System.getProperties();可以获得系统属性信息Properties类对象</p>
<p>由于<strong>不同系统的分隔符代码不同</strong>，所以需要定义一个字符串类型量来存储当前系统的分隔符符号。这样此程序就能适用于所有系统而不需要再此修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperties(<span class="string">"line.seperator"</span>);</span><br></pre></td></tr></table></figure>

<p>给系统设置一些属性信息，这些信息是全局的，其他程序也可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperties(<span class="string">"mykey"</span>,<span class="string">"myvalue"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-Runtime类"><a href="#2-Runtime类" class="headerlink" title="2 Runtime类"></a><strong>2 Runtime类</strong></h2><p>每个Java程序都有一个Runtime实例，使应用程序能够与其运行的环境相连接可以通过getRuntime方法获取当前运行时应用程序不能创建自己的Runtime类实例。</p>
<p>此类也没有对外提供构造函数，这时</p>
<p><strong>注意：</strong>如果没有提供构造函数，那么意味着这个类不能创建对象，这个类的方法都是静态的。</p>
<p>​    如果这个类有非静态的方法，则一定存在着至少一个方法是静态并返回构造对象。</p>
<p>Runtime：没有构造方法摘要，说明该类不可以创建对象。又发现还有非静态的方法，说明应该提供静态的返回该类对象的方法。而且只有一个，说明Runtime类使用了<strong>单例设计模式</strong></p>
<h2 id="3-Math类"><a href="#3-Math类" class="headerlink" title="3 Math类"></a>3 <strong>Math类</strong></h2><p>Math前面有final修饰，不能被继承，其包含用于执行基本数学运算的方法，如初等指数，对数，平方根和三角函数。都是静态方法</p>
<p>常用方法：</p>
<p>ceil();返回大于参数的最小整数。</p>
<p>floor();返回小于参数的最大整数。</p>
<p>round();返回四舍五入的整数</p>
<p>pow(a,b);返回a的b次方</p>
<p>random();返回0-1之间的伪随机数</p>
<p>random还可以封装成对象，即random对象</p>
<h2 id="4-Date类"><a href="#4-Date类" class="headerlink" title="4 Date类"></a>4 <strong>Date类</strong></h2><p>Date类表示特定的瞬间，精确到毫秒。</p>
<p>Date类可以接受或返回年、月、日、小时、分钟和秒值的方法，<strong>表示形式</strong>为</p>
<p>年份y由整数y-1900表示</p>
<p>月份从0至11的整数表示，0代表1月，11代表12月</p>
<p>日期从1至31的整数表示</p>
<p>小时从0至23的整数表示</p>
<p>秒从0至61的整数表示，60和61只对闰秒发生</p>
<p>日期对象和毫秒值之间的转换</p>
<p>毫秒值转成日期对象：</p>
<p>1.通过Date对象的构造方法完成 new Date(timeMillis)；</p>
<p>2.通过setTime(long time)设置</p>
<p>因为可以通过Date对象的方法对该日期中的各个字段（年月日等）进行操作</p>
<p>日期对象转成毫秒值：</p>
<p>1.getTime方法</p>
<p>因为可以通过具体的数值进行运算</p>
<p><strong>日期对象转换成字符串</strong></p>
<p>对日期对象进行格式化，需要用到<strong>日期格式对象</strong>，即<strong>DateFormat</strong>。</p>
<p>将日期对象转成日期格式的字符串</p>
<p>使用的是DateFormat类中的<strong>format</strong>方法。</p>
<p>获取日期格式对象，具备系统默认的风格。也可以指定FULL LONG SHORT MEDIUM风格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">String str = dateFormat.format(date);</span><br></pre></td></tr></table></figure>

<p>如果风格是自定义的如何解决？使用dateFormat的子类SimpleDateFormat</p>
<p><strong>字符串转成日期对象</strong></p>
<p>将日期格式的字符串转成日期对象</p>
<p>使用的是DateFormat类中的parse()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str_date = <span class="string">"2019-10-05"</span>;</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance();</span><br><span class="line">Date date = dateFormat.parse(str_date);</span><br></pre></td></tr></table></figure>

<h2 id="5-Calendar类"><a href="#5-Calendar类" class="headerlink" title="5 Calendar类"></a>5 <strong>Calendar类</strong></h2><p><strong>Calender类</strong>是一个<strong>抽象类</strong>，它为特定瞬间与一组诸如YEAR MONTH DAY_OF_MONTH HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法。</p>
<p>练习：</p>
<p>得出指定年份2月的天数</p>
<p>基于08的演示再加上下面的代码</p>
<p>思路：先将日期设置为指定那年的3月1日，在用偏移方法偏移一天即可得到结果。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常见对象API-集合框架4</title>
    <url>/2020/03/26/JavaSE-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1API-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B64/</url>
    <content><![CDATA[<h1 id="常见对象API-集合框架4"><a href="#常见对象API-集合框架4" class="headerlink" title="常见对象API-集合框架4"></a>常见对象API-集合框架4</h1><h2 id="集合-工具类-amp-JDK5-0特性"><a href="#集合-工具类-amp-JDK5-0特性" class="headerlink" title="集合-工具类&amp;JDK5.0特性"></a>集合-工具类&amp;JDK5.0特性</h2><h2 id="1-Collections"><a href="#1-Collections" class="headerlink" title="1 Collections"></a>1 Collections</h2><p>Collections:是集合框架的工具类，里面的方法都是静态的。</p>
<p>排序：Collections.sort();</p>
<p>调换位置顺序：Collections.swap();</p>
<p>若要按照其它方式排序就要重写比较器的方法并传入。</p>
<p>Collections.sort(List&lt;? extends T&gt; list, Comparator&lt;? Super T&gt; c);</p>
<a id="more"></a>

<p>用二分搜索法搜索指定列表，以获得指定对象，返回对象索引。</p>
<p>static int binarySearch(List&lt;? extends Comparable&lt;? Super T&gt;&gt; list,T key)</p>
<p>static int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? Super T&gt; c)</p>
<p>获取最大值</p>
<p>max(Collection&lt;? extends T&gt; coll)</p>
<p>max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp</p>
<p>逆序</p>
<p>reverseOrder();返回一个比较器，强行逆转了Comparable接口的对象collection的自然顺序</p>
<p>reverseOrder(Comparator&lt;T&gt;,comp);返回一个比较器，强行逆转指定比较器的顺序</p>
<p>reverse(List&lt;?&gt; list);反转指定列表中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用方法:</span><br><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;String&gt;(Collections.reverseOder());</span><br><span class="line">相当于传入了一个跟之前比较器比较顺序相反的比较器。</span><br></pre></td></tr></table></figure>

<p>替换</p>
<p>static boolean ReplaceAll(List(T) list,T oldVal,T newVal);使用另一个值替换列表中出现的所有某一指定值。</p>
<p>fill(List&lt;? super T&gt; list,T obj);使用指定元素替换列表中的所有元素</p>
<p>其他方法</p>
<p>shuffle(List&lt;?&gt; list);使用默认随机源对指定列表进行置换</p>
<p>enumertion(Collection&lt;T&gt; coll);返回指定集合上的枚举。</p>
<p>list(Enumeration&lt;T&gt; e);返回一个数组列表，它按返回顺序包含指定枚举返回的元素</p>
<p><strong>toArray方法</strong></p>
<p>toArray();返回包含此collection中所有元素的数组。</p>
<p>toArray(T[ ] a);返回包含此collection中所有元素的数组；返回数组运行时类型与指定数组的运行时类型相同。</p>
<p>集合转成数组</p>
<p>使用的就是Colletion接口中的toArray方法。</p>
<p>集合转成数组可以对集合中的元素操作的方法进行限定。不允许对其进行增删。</p>
<p>toArray方法需要传入一个指定类型的数组</p>
<p>​    如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组</p>
<p>​    如果长度大于集合的size，那么该该方法会使用指定的数组，存储集合中的元素，其他位置默认为null</p>
<p>​    所以建议最后长度指定为集合的size。</p>
<h2 id="2-将非同步集合转成同步集合的方法"><a href="#2-将非同步集合转成同步集合的方法" class="headerlink" title="2 将非同步集合转成同步集合的方法"></a>2 <strong>将非同步集合转成同步集合的方法</strong></h2><p>synchronizedCollection(Collection&lt;T&gt; coll);返回指定列表支持的同步（线程安全）集合。</p>
<p>synchronizedList(List&lt;T&gt; list);返回指定列表支持的同步（线程安全）列表。</p>
<p>synchronizedMap(Map&lt;K,V&gt; map);返回指定列表支持的同步（线程安全）映射。</p>
<p>synchronizedSet(Set&lt;T&gt; set);返回指定列表支持的同步（线程安全）set。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();<span class="comment">//非同步list</span></span><br><span class="line">list = synchronizedList(list);<span class="comment">//返回一个同步的list</span></span><br></pre></td></tr></table></figure>



<h2 id="3-Arrays-方法介绍、asList方法"><a href="#3-Arrays-方法介绍、asList方法" class="headerlink" title="3  Arrays-方法介绍、asList方法"></a>3  <strong>Arrays-方法介绍、asList方法</strong></h2><p>Arrays:集合框架的工具类。里面的方法都是静态的</p>
<p>重点：asList(T.. a);返回一个受指定数组支持的固定大小的列表。充当了基于数组的API与基于Collection的API之间的桥梁，<strong>将数组转成集合</strong></p>
<p>好处：其实可以使用集合的方法操作数组中的元素</p>
<p>1.数组的长度是固定的，所以对于集合的增删方法是不可以使用的。否则会发生UnsupportedOperationException异常。</p>
<p>\2. 如果数组中的元素是对象，那么转成集合时，将数组中的元素作为集合中的元素进行集合存储。如果数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line">结果：[I@<span class="number">139</span>a55]</span><br></pre></td></tr></table></figure>



<h2 id="4-JDK5-0特性-ForEach循环"><a href="#4-JDK5-0特性-ForEach循环" class="headerlink" title="4 JDK5.0特性-ForEach循环"></a>4 <strong>JDK5.0特性-ForEach循环</strong></h2><p>foreach语句：</p>
<p>​        格式：</p>
<p>​        for(类型 变量:Collection集合或者数组)</p>
<p>​        {</p>
<p>​        </p>
<p>​        }</p>
<p>传统for循环和高级for循环的区别：</p>
<p>​        传统for可以完成对语句执行很多次，因为可以定义控制循环的增量和条件。</p>
<p>​        </p>
<p>​        高级for是一种简化形式</p>
<p>​        它必须有被遍历的目标。该目标要么是数组要么是Collection单列集合</p>
<p>​        </p>
<p>​        对于数组的遍历，如果仅仅是获取数组中的元素，可以使用高级for。</p>
<p>​        如果要对数组的角标进行操作，建议使用传统for。</p>
<p>不可以使用高级for遍历map集合，但是可以将map转成单列的set就可以用。</p>
<h2 id="5-JDK5-0特性-函数可变参数"><a href="#5-JDK5-0特性-函数可变参数" class="headerlink" title="5 JDK5.0特性-函数可变参数"></a>5 <strong>JDK5.0特性-函数可变参数</strong></h2><p>函数的可变参数：就是方法的参数列表不确定有多少参数时可以用</p>
<p>其实就是一个数组，但是接受的是数组的元素</p>
<p>自动将这些元素封装成数组，简化了调用者的书写</p>
<p><strong>注意：</strong>可变参数类型必须定义在参数列表的结尾处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newAdd</span><span class="params">(<span class="keyword">int</span> ... arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length; i++)&#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = newAdd(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">结果：<span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="6-JDK5-0特性-静态导入"><a href="#6-JDK5-0特性-静态导入" class="headerlink" title="6 JDK5.0特性-静态导入"></a>6 <strong>JDK5.0特性-静态导入</strong></h2><p>静态导入可以省略代码的缩写，可用可不用。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常见对象API-集合框架3</title>
    <url>/2020/03/26/JavaSE-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1API-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B63/</url>
    <content><![CDATA[<h1 id="常见对象API-集合框架3"><a href="#常见对象API-集合框架3" class="headerlink" title="常见对象API-集合框架3"></a>常见对象API-集合框架3</h1><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><h2 id="1-Map集合特点-amp-常用方法、常用方法演示"><a href="#1-Map集合特点-amp-常用方法、常用方法演示" class="headerlink" title="1 Map集合特点&amp;常用方法、常用方法演示"></a><strong>1 Map集合特点&amp;常用方法、常用方法演示</strong></h2><p>Map：一次添加一对元素。Collection一次添加一个元素</p>
<p>​    Map也称为双列集合，Collection集合称为单列集合</p>
<p>​    其实map集合中存储的就<strong>键值对</strong></p>
<p>​    map集合中必须保证<strong>键的唯一性</strong></p>
<p>1.添加</p>
<p>​    value put(key,value):返回前一个和key关联的值，如果没有则返回null</p>
<p>2.删除</p>
<p>​    void clear():清空map集合</p>
<p>​    value remove(key):根据指定的key删除指定的键值对。</p>
<p>3.判断</p>
<p>​    boolean containsKey(key):是否包含该键</p>
<p>​    boolean containsValue(value):是否包含该值</p>
<p>​    boolean isEmpty():是否为空</p>
<p>4.获取</p>
<p>​    value get(key):通过键获取值，如果没有该键返回null。</p>
<p>​                  当然可以通过返回null来判断是否包含指定键。</p>
<p>​    int size():获取键值对的个数。</p>
<h2 id="2-Map集合重点方法keySet演示"><a href="#2-Map集合重点方法keySet演示" class="headerlink" title="2 Map集合重点方法keySet演示"></a><strong>2 Map集合重点方法keySet演示</strong></h2><p>取出Map中的所有元素，这里就用到keySet方法</p>
<p>Set keySet();返回此映射中的所有键的set集合</p>
<p>原理：通过keySet方法获取所有的键所在的set集合，再通过set的迭代器获取到每一个键，再对每一个键通过get方法获取其对应的值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">8</span>,<span class="string">"aaa"</span>);</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">"qqq"</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="string">"sss"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = keySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	<span class="keyword">int</span> key = it.next();</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Map集合重点方法entrySet演示"><a href="#3-Map集合重点方法entrySet演示" class="headerlink" title="3 Map集合重点方法entrySet演示"></a><strong>3 Map集合重点方法entrySet演示</strong></h2><p>另一种取出Map中所有元素的方法，这里用到entrySet方法</p>
<p>Map.Entry&lt;K,V&gt; entrySet();返回此映射的映射关系的set集合。</p>
<p>这样通过entrySet方法Map就转成set，这样就可以迭代</p>
<p>该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是Map.Entry类型（类似于结婚证）。</p>
<p>然后通过该类中的getKey和getValue方法得到Map中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">8</span>,<span class="string">"aaa"</span>);</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">"qqq"</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="string">"sss"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; ME = it.next();</span><br><span class="line">	<span class="keyword">int</span> key = it.getKey();</span><br><span class="line">    String value = it.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map.Entry是内部嵌套类</p>
<p>Entry包含键和值的内容，只有先有Map映射，才存在着关系，而把关系封装成对象，关系要访问Map中的键和值，即外部规则含有内部规则，内部规则直接访问外部规则的内容。</p>
<h2 id="4-方法Values演示"><a href="#4-方法Values演示" class="headerlink" title="4 方法Values演示"></a>4 <strong>方法Values演示</strong></h2><p>Colletion values();返回此映射中包含的值的Collection集合。</p>
<p>返回值是Collection不是Set是因为值可以重复，键不能重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">Iterator&lt;String&gt; it = values.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	String str = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-常见子类"><a href="#5-常见子类" class="headerlink" title="5 常见子类"></a>5 常见子类</h2><p>Map常见的子类</p>
<p>​    HashTable：内部结构是哈希表，是同步的。不允许null作为键，null作为值。</p>
<p>​               子类Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。</p>
<p>​    HashMap：内部结构是哈希表，是不同步的。允许null作为键，null作为值。</p>
<p>​    TreeMap：内部结构是二叉树，是不同步的。可以对Map集合中的键进行排序。</p>
<p>​    ConcurrentHashMap：内部结构是哈希表，线程安全，CAS+同步锁，数组+链表+红黑                                              树，不允许null作为键，null作为值。</p>
<h2 id="6-LinkedHashMap-amp-关联码"><a href="#6-LinkedHashMap-amp-关联码" class="headerlink" title="6 LinkedHashMap&amp;关联码"></a>6 <strong>LinkedHashMap&amp;关联码</strong></h2><p>LinkedHashMap存进去时，元素时按什么顺序存进去的就按什么顺序取出来。</p>
<p>演示略</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-泛型</title>
    <url>/2020/03/26/JavaSE-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>有时候编译程序会碰到如下问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">a.add(<span class="string">"abc"</span>);</span><br><span class="line">a.add(<span class="number">5</span>);</span><br><span class="line">编译不报错，运行时会报错</span><br></pre></td></tr></table></figure>

<p>这是因为5这个元素加进来类型是Int，无法强转成String类型。但是在编译的过程中不会报错，在运行时才会出现异常，这就不是非常的安全。所以要改写成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">a.add(&quot;abc&quot;);</span><br><span class="line">a.add(5);</span><br></pre></td></tr></table></figure>

<p>这样在编译时就出现报错，提升了安全性。同时发现之前的黄色感叹号也消失了，然后在给str赋值时，也不用强转，因为在之前定义集合时就已经说明里面装的是String类型的元素。</p>
<p><strong>尖括号里面的内容就是泛型。</strong></p>
<a id="more"></a>

<p>泛型：</p>
<p>jdk1.5出现的安全机制。</p>
<p>好处:</p>
<p>​    1.将运行时期的问题ClassCastException转到了编译时期</p>
<p>​    2.避免了强制转换的麻烦</p>
<p>&lt;&gt;什么时候用？</p>
<p>当操作的引用数据类型不确定的时候，就使用&lt;&gt;,将要操作的引用数据类型传入即可</p>
<p>其实&lt;&gt;就是一个用于接收具体<strong>引用数据类型</strong>的参数范围，数值数据类型不能用。</p>
<p>在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型。</p>
<h2 id="2-泛型-擦除-amp-补偿"><a href="#2-泛型-擦除-amp-补偿" class="headerlink" title="2 泛型-擦除&amp;补偿"></a>2 <strong>泛型-擦除&amp;补偿</strong></h2><p>泛型技术是给编译器使用的技术，用于编译时期。确保了类型的安全。</p>
<p>运行时会将泛型去掉，生成的class文件中是不带泛型的，这个称为泛型的<strong>擦除</strong>。</p>
<p>为什么擦除呢？</p>
<p>因为为了兼容运行的类加载器。</p>
<p>泛型的<strong>补偿</strong>：在运行时，通过获取元素的类型进行转换动作。不用使用者再强制转换了。</p>
<p>集合使用与之前没有使用泛型进行比较，有不同。然后<strong>equals方法不能用泛型</strong>，因为这个方法来自于Object，Object没有定义泛型。这里是固定类型，想要比较就要强转。</p>
<h2 id="3-泛型-泛型类"><a href="#3-泛型-泛型类" class="headerlink" title="3 泛型-泛型类"></a>3 <strong>泛型-泛型类</strong></h2><p>在jdk1.5后，使用泛型来接收类中要操作的引用数据类型</p>
<p>泛型类：什么时候用？</p>
<p>当类中的操作的引用数据类型不确定的时候，就使用泛型来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tool</span>&lt;<span class="title">QQ</span>&gt;</span>&#123;<span class="comment">//这就是泛型类</span></span><br><span class="line">    <span class="keyword">private</span> QQ q;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> QQ <span class="title">getObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObject</span><span class="params">(QQ object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.q = object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Tool&lt;Student&gt; tool = <span class="keyword">new</span> Tool&lt;Student&gt;;</span><br><span class="line">    tool.setObject(<span class="keyword">new</span> Student());</span><br><span class="line">    Student stu = tool.getObject();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子使用泛型类，就不必再强转。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-泛型-泛型方法"><a href="#4-泛型-泛型方法" class="headerlink" title="4 泛型-泛型方法"></a>4 <strong>泛型-泛型方法</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;w&gt;<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(W str)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"str"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(QQ str)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"str"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型定义在方法上，此时show方法中的参数类型跟着W走，而print方法中的参数类型跟着QQ走，即定义在类的泛型走。若W没有具体定义，那么就是Object。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(QQ str)</span></span>&#123;<span class="comment">//这是不行的</span></span><br><span class="line">    System.out.println(<span class="string">"str"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Y&gt;<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Y str)</span></span>&#123;<span class="comment">//这是可以的</span></span><br><span class="line">    System.out.println(<span class="string">"str"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当方法<strong>静态</strong>时，不能访问类上定义的泛型。如果静态方法使用泛型，只能将泛型定义在方法上。泛型只能定义在返回值的前面，修饰符的后面。使用的话就直接：类.方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Y&gt;<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Y aaa)</span></span>&#123;</span><br><span class="line">    System.out.println(aaa.length());<span class="comment">//这是不行的</span></span><br><span class="line">    System.out.println(aaa.toString());<span class="comment">//这是可以的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：不能直接在泛型方法内使用具体一个对象的方法，因为使用了泛型，就无法确定具体的类型是什么。但是可以使用Object方法，因为所有的对象都是Object类或子类。</p>
<h2 id="5-泛型接口"><a href="#5-泛型接口" class="headerlink" title="5  泛型接口"></a>5  <strong>泛型接口</strong></h2><p>泛型接口：将泛型定义在接口上</p>
<p>有两种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp1</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp2</span>&lt;<span class="title">Q</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">Q</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Q q)</span></span>&#123;</span><br><span class="line">        System.out.println(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-泛型限定（上下限）"><a href="#6-泛型限定（上下限）" class="headerlink" title="6 泛型限定（上下限）"></a>6 <strong>泛型限定（上下限）</strong></h2><p>如果想要在方法中对所有的泛型都能使用，就要用到通配符，这里通配符就是问号?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; a)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = a.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是两个集合分别是装String和Integer类型，但是方法上想都能用，就用?。</p>
<p>若方法只是能部分类型调用的，比如现在有Worker，Student和String类型的集合，但是只能前两者调用，前两者又是Person的子类，故可以使用<strong>泛型的限定</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;? extends Person&gt; a)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = a.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        Person p = it.next();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<strong>注意</strong>就是集合构建前后泛型要一致，否则失败</p>
<p>Collection&lt;Person&gt;=new ArrayList&lt;Worker&gt;(); 不行</p>
<p>Collection&lt;Worker&gt;=new ArrayList&lt;Person&gt;(); 不行</p>
<p>Collection&lt;Person&gt;=new ArrayList&lt;Person&gt;(); 行</p>
<p>泛型可以对类型进行限定</p>
<p>上限：? extends E:接收E类型或者E的子类型对象。</p>
<p>下限：? super E:接收E类型或者E的父类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Student&gt; a)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = a.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        Person p = it.next();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就只能接收Student和其父类Person，Worker不行。</p>
<h2 id="7-泛型的限定（上下限的体现）"><a href="#7-泛型的限定（上下限的体现）" class="headerlink" title="7 泛型的限定（上下限的体现）"></a>7 <strong>泛型的限定（上下限的体现）</strong></h2><p>上限的体现：一般在<strong>存储元素的时候都是用上限</strong>，因为这样取出都是按照上限类型来运算的，不会出现类型安全隐患。</p>
<p>API中，addAll(Collection&lt;? Extends Person&gt;);这就是上限的体现。</p>
<p>下限的体现</p>
<p>什么时候用下限？通常对<strong>集合中的元素进行取出操作时</strong>，<strong>可以使用下限</strong>。</p>
<p>从集合中取出元素，用本身或者父类来取出，可以保证全部接收。</p>
<p>TreeSet(Comparator&lt;? super E&gt; comp);下限的体现。</p>
<h2 id="8-泛型限定（通配符的体现）"><a href="#8-泛型限定（通配符的体现）" class="headerlink" title="8 泛型限定（通配符的体现）"></a>8 <strong>泛型限定（通配符的体现）</strong></h2><p>containsAll(Collection&lt;?&gt; coll)</p>
<p>包含的原理是用equals作判断，equals方法任何对象都具备，equals参数是Object。</p>
<p>所以传进来的集合类型是随机的未知的，所以用通配符?。</p>
<p>只要里面用的是Object方法，都用?。</p>
<p>containsAll(Collection&lt;?&gt; coll);通配符的体现。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常见对象API-集合框架2</title>
    <url>/2020/03/25/JavaSE-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1API-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B62/</url>
    <content><![CDATA[<h1 id="常见对象API-集合框架2"><a href="#常见对象API-集合框架2" class="headerlink" title="常见对象API-集合框架2"></a>常见对象API-集合框架2</h1><h2 id="list的子类与set"><a href="#list的子类与set" class="headerlink" title="list的子类与set"></a>list的子类与set</h2><h2 id="1-Vector集合"><a href="#1-Vector集合" class="headerlink" title="1 Vector集合"></a><strong>1 Vector集合</strong></h2><p>Vector集合中的方法基本都不太使用。都有ArrayList来取代了。下面例举一下其中几个方法，更多的可以去API中寻找，其中带element的都是原先Vector的方法。</p>
<p>addElement 添加</p>
<p>elements() 获得Enumeration类，使用hasMoreElements()和nextElement()方法可以对集合进行遍历。功能与Iterator接口的功能是重复的。此外Iterator接口添加了一个可选的移除操作，并使用较短的方法名。新的实现应优先考虑使用Iterator。</p>
<a id="more"></a>

<h2 id="2-LinkedList集合"><a href="#2-LinkedList集合" class="headerlink" title="2 LinkedList集合"></a><strong>2 LinkedList集合</strong></h2><p>LinkedList的一些常见的方法，更多的见API。</p>
<p>addFirst():将元素添加到第一个位置</p>
<p>addLast();将元素添加到最后一个位置</p>
<p>getFirst():获取第一个元素但不删除</p>
<p>getLast():获取最后一个元素但不删除</p>
<p>removeFirst():获取第一个元素但删除</p>
<p>removeLast():获取最后一个元素但删除</p>
<p><strong>栈和队列均可由LinkedList接口实现</strong></p>
<p>JDK在1.6后又添加了一些方法</p>
<p>​    addFirst();</p>
<p>​    addLast();</p>
<p>​    JDK1.6以后多了</p>
<p>​    offerFirst();</p>
<p>​    offetLast();</p>
<p>​    getFirst();//获取但不移除，如果链表为空，抛出NoSuchElementException</p>
<p>​    getLast();</p>
<p>​    JDK1.6以后多了</p>
<p>​    peekFirst();//获取但不移除，如果链表为空，返回null</p>
<p>​    peekLast();</p>
<p>​    </p>
<p>​    removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException</p>
<p>​    removeLast();</p>
<p>​    JDK1.6以后多了</p>
<p>​    pollFirst();//获取并移除，如果链表为空，返回null</p>
<p>​    pollLast();</p>
<h2 id="3-ArrayList集合存储自定对象"><a href="#3-ArrayList集合存储自定对象" class="headerlink" title="3 ArrayList集合存储自定对象"></a><strong>3 ArrayList集合存储自定对象</strong></h2><p>略</p>
<p>这里要注意：集合的add方法的参数类型是Object，所以什么类型的对象都能接收。接收完以后里面的对象都提升为了Object对象，用迭代器取其中的元素类型也是Object对象。Object中里面没有其子类特有的方法，故直接使用子类特有的方法会报错。所以需要创建对象来接收迭代出来的，这时需要对其进行强转。</p>
<h2 id="4-HashSet集合"><a href="#4-HashSet集合" class="headerlink" title="4 HashSet集合"></a><strong>4 HashSet集合</strong></h2><p>Set：元素不可以重复，是无序的</p>
<p>​    Set接口中的方法和Collection一致</p>
<p>常用子类之一</p>
<p>HashSet: 此类实现set接口，有哈希表支持。它不保证set的迭代顺序，特别是它不保证该顺序恒久不变。此类允许使用null元素。此实现是不同步</p>
<h2 id="5-哈希表"><a href="#5-哈希表" class="headerlink" title="5 哈希表"></a>5 哈希表</h2><p>每一个元素都会通过一个哈希算法来确定存储在集合中的位置，同一位置不能重复存储。当需要查找集合中是否存在此元素时，通过哈希算法算出位置，再判断两个元素是否相同。这样的查找速度更快，比遍历在快很多。</p>
<p>哈希表确定元素是否相同</p>
<p>1.判断的是两个元素的哈希值是否相同</p>
<p>​    如果相同，再判断两个对象的内容是否相同</p>
<p>2.判断哈希值相同，其实判断的是对象的hashCode的方法。</p>
<p>​    判断内容相同，用的是equals方法</p>
<p>注意：如果哈希值不同，是不需要判断equals。</p>
<p>如果相同， 则不再存储该值，若不同则依据当前位置再进行算法进行存储或顺延存储。</p>
<h2 id="6-HashSet存储自定义对象"><a href="#6-HashSet存储自定义对象" class="headerlink" title="6 HashSet存储自定义对象"></a>6 HashSet存储自定义对象</h2><p>往hashset集合中存储person对象。如果姓名和年龄相同，视为同一个人，视为同元素</p>
<p>具体略</p>
<p>注意：Person对象是继承Object的，也继承其hashCode和equals方法。在这个情况下equals方法中，是比较其地址值的，所以就算两个new的对象姓名和年龄一样，实际判断还是不相同。</p>
<p>所以我们需要自己建立算法和判断依据来存储数据，就需要对父类进行覆盖。</p>
<h2 id="7-LinkedHashSet集合"><a href="#7-LinkedHashSet集合" class="headerlink" title="7 LinkedHashSet集合"></a>7 LinkedHashSet集合</h2><p>LinkedHashSet具有可预知迭代顺序的Set接口的哈希表和链接列表实现</p>
<p>即保证唯一和有序</p>
<h2 id="8-TreeSet集合"><a href="#8-TreeSet集合" class="headerlink" title="8 TreeSet集合"></a>8 TreeSet集合</h2><p>TreeSet:可以对set集合中的元素进行指定顺序的排序。是不同步的。</p>
<p>判断元素唯一性的方式就是根据比较方法的返回结果是否是0.是0，就是相同元素，不存。</p>
<p>存储自定义对象</p>
<p>TreeSet集合中，要通过comparable接口来确定顺序。所以自定义对象需要实现这个接口。不实现这个接口存进去报错。</p>
<p>将自定义类实现comparable接口，复写compareTo方法</p>
<p>CompareTo方法比较此对象与指定对象的顺序，如果该对象小于，等于或者大于指定对象，则分别返回负整数，零或者正整数。返回1则排在后面。</p>
<h2 id="9-TreeSet集合-Comparator比较器"><a href="#9-TreeSet集合-Comparator比较器" class="headerlink" title="9 TreeSet集合-Comparator比较器"></a>9 TreeSet集合-Comparator比较器</h2><p>TreeSet对元素进行排序的方式一：</p>
<p>​    让元素自身具备比较功能，元素需要实现Comparable接口，覆盖compareTo方法。</p>
<p>如果不要按照对象中具备的自然顺序进行排序，如果对象中不具备自然顺序，怎么办</p>
<p>可以使用TreeSet集合的排序方式二：</p>
<p>让集合自身具备比较功能,定义一个类实现Comparator接口，覆盖compare方法</p>
<p>将该类对象作为参数传递给TreeSet集合的<strong>构造函数。</strong></p>
<p>比较器会比较常用一些。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常见对象API-集合框架1</title>
    <url>/2020/03/25/JavaSE-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1API-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B61/</url>
    <content><![CDATA[<h1 id="常见对象API-集合框架1"><a href="#常见对象API-集合框架1" class="headerlink" title="常见对象API-集合框架1"></a>常见对象API-集合框架1</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>集合类的由来</p>
<p>​    对象用于封装特有数据，对象多了就需要存储，如果对象的个数不确定，就是使用集合容器进行存储</p>
<p>集合特点</p>
<p>1.集合是用于存储对象的容器</p>
<p>2.集合的长度是可变的</p>
<p>3.集合中不可以存储基本数据类型值</p>
<a id="more"></a>

<h2 id="2体系-amp-共性功能"><a href="#2体系-amp-共性功能" class="headerlink" title="2体系&amp;共性功能"></a><strong>2体系&amp;共性功能</strong></h2><p>集合容器因为内部的数据结构不用，有多种具体容器,不断的向上抽取就形成了集合框架，框架的顶层就是collection接口</p>
<p>collection的常见方法：（<strong>做必要掌握</strong>）</p>
<p>1.添加</p>
<p>​    boolean add(Object obj);</p>
<p>​    boolean addAll(Collection coll);添加全部</p>
<p>2.删除</p>
<p>​    boolean remove(Object obj);删除第一次出现的对象</p>
<p>​    boolean removeAll(Collection coll);将两个集合中相同的元素从调用removeAll的集合中删除</p>
<p>​    void clear();将集合中的所有元素都删除</p>
<p>3.判断</p>
<p>​    boolean contains(Object Obj);判断集合内是否存在该元素</p>
<p>​    boolean containsAll(Collection coll);判断集合内是否存在指定集合内的所有元素</p>
<p>​    boolean isEmpty();判断集合中是否有元素，没有返回true</p>
<p>4.获取</p>
<p>​    int size();获取集合中元素个数即长度</p>
<p>​    Iterator iterator();取出元素的方式：迭代器</p>
<p>5.其他</p>
<p>​    boolean retainAll(Collection coll);取交集即保留和指定集合中相同的元素在当前集合中，删除不同的元素，和removeAll功能相反。</p>
<p>​    Object[ ] toArray();将集合转为数组</p>
<h2 id="3-迭代器使用"><a href="#3-迭代器使用" class="headerlink" title="3 迭代器使用"></a>3 <strong>迭代器使用</strong></h2><p>如果想取出集合中的元素则需要使用到迭代器。</p>
<p>首先使用Collection中iterator()方法.调用集合中的迭代器方法，获取集合中的迭代器对象。</p>
<p>在迭代器对象中有两个方法：</p>
<p>object next():返回迭代的下一个元素</p>
<p>Boolean hasNext():如果仍有元素可以迭代，则返回true。</p>
<p>然后利用while循环和上述两个方法可以将集合中的元素全部迭代出来。</p>
<p>若再使用next方法，则会出现找不到元素异常，因为之前都迭代完了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时存在一个问题，就是迭代完之后，it对象仍在存在占用空间，但是却没有了用处，所以要改变一下代码的写法，使用for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(Iterator it = coll.iterator();it.hasNext();)&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子循环结束，it对象也随之消失。</p>
<p>一般开发都用这种方法</p>
<h2 id="4-迭代器的原理"><a href="#4-迭代器的原理" class="headerlink" title="4 迭代器的原理"></a>4 <strong>迭代器的原理</strong></h2><p>每个集合中都有自己的迭代器，向上抽取形成迭代器接口类型的类，这是一个<strong>内部类</strong>，里面有hasNext()和next()方法。</p>
<p>然后每个集合中都实现这个迭代器，里面都覆盖了上述的两个方法。</p>
<p>迭代器对象必须依赖于具体容器，因为每一个容器的数据结构都不同，所以该迭代器对象是在容器中进行内部实现的。对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法。</p>
<h2 id="5-List（列表）和Set（集）的特点"><a href="#5-List（列表）和Set（集）的特点" class="headerlink" title="5 List（列表）和Set（集）的特点"></a><strong>5 List（列表）和Set（集）的特点</strong></h2><p>List和Set是集合体系的子体系，也是接口</p>
<p>List：有序（存入和取出的顺序一致）、元素都有索引（角标）、元素可以重复</p>
<p>Set：元素不能重复、无序</p>
<h2 id="6-List集合的常见方法"><a href="#6-List集合的常见方法" class="headerlink" title="6 List集合的常见方法"></a><strong>6 List集合的常见方法</strong></h2><p><strong>List特有</strong>的常见方法：有一个共性特点，就是都可以操作角标(index)</p>
<p>1.添加</p>
<p>​    void add(index,element);</p>
<p>​    void add(index,collection);</p>
<p>2.删除</p>
<p>​    Object remove(index);</p>
<p>​    </p>
<p>3.修改</p>
<p>​    Object set(index,element);</p>
<p>​    </p>
<p>4.获取</p>
<p>​    Object get(index);</p>
<p>​    int indexOf(object);</p>
<p>​    int lastIndexOf(object);</p>
<p>​    List subList(from,to);包含头不包含尾</p>
<p>List集合是可以完成对元素的增删改查的</p>
<h2 id="7-ListIterator接口"><a href="#7-ListIterator接口" class="headerlink" title="7 ListIterator接口"></a><strong>7 ListIterator接口</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"abc1"</span>);</span><br><span class="line">list.add(<span class="string">"abc2"</span>);</span><br><span class="line">list.add(<span class="string">"abc3"</span>);</span><br><span class="line">Iterator it = <span class="keyword">new</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span>(obj.equals(<span class="string">"abc2"</span>))&#123;</span><br><span class="line">        list.add(<span class="string">"abc5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> System.out.println(<span class="string">"next:"</span> + obj);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line">结果：报错：ConcurrentModificationException</span><br></pre></td></tr></table></figure>

<p>想实现当迭代到abc2时，添加abc9，但是此时出现异常，即集合不能同时进行添加和迭代。也就是在迭代过程中，不要使用集合操作元素，容易出现异常。</p>
<p>解决：可以使用Iterator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"abc1"</span>);</span><br><span class="line">list.add(<span class="string">"abc2"</span>);</span><br><span class="line">list.add(<span class="string">"abc3"</span>);</span><br><span class="line">ListIterator it = <span class="keyword">new</span> list.listIterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span>(obj.equals(<span class="string">"abc2"</span>))</span><br><span class="line">        list.add(<span class="string">"abc5"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line">结果：[abc1,abc2,abc5,abc3]</span><br></pre></td></tr></table></figure>

<p>Iterator接口的子接口ListIterato它可以实现在迭代过程中完成对元素的增删改查。</p>
<p>注意：只有list集合具备该迭代功能</p>
<p>ListIterator还有反向遍历的功能</p>
<p>previous()</p>
<p>hasPrevious()</p>
<h2 id="8-List常用子类的特点"><a href="#8-List常用子类的特点" class="headerlink" title="8 List常用子类的特点"></a>8 <strong>List常用子类的特点</strong></h2><p>List有三个常用子类对象</p>
<p>​    Vector:内部是数组数据结构，是同步的即线程安全。增删，查询都很慢</p>
<p>​    ArrayList:内部是数组数据结构，是不同步的。替代了Vector。查询的速度快</p>
<p>​    LinkedList:内部是链接列表即链表数据结构，是不同步的。增删元素的速度很快</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-基本数据类型对象包装类</title>
    <url>/2020/03/25/JavaSE-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="基本数据类型对象包装类"><a href="#基本数据类型对象包装类" class="headerlink" title="基本数据类型对象包装类"></a>基本数据类型对象包装类</h1><p>为了方便操作基本数据类型值，将其封装成了对象，在对象中定义了属性和行为丰富了该数据的操作。<br>用于描述该对象的类就称为<strong>基本数据类型对象包装类</strong>。</p>
<p>基本数据类型对应关系</p>
<p>基本数据类型(8种)   包装类</p>
<p>byte            Byte</p>
<p>short          Short</p>
<p>int             Integer</p>
<p>long           Long</p>
<p>float           Float</p>
<p>double          Double</p>
<p>char            Character</p>
<p>boolean        Boolean</p>
 <a id="more"></a>



<p>常用操作之一: 用于基本数据类型和字符串之间的转换</p>
<p>1.基本类型转换为字符串方法:</p>
<p>1)基本类型数值 + “”;</p>
<p>2)使用 String 类中的静态方法 valueOf(基本类型数值);</p>
<p>3)使用 Integer 类中的静态方法 valueOf(基本类型数值);</p>
<ol start="2">
<li>字符串转换为基本类型</li>
</ol>
<p>1)使用包装类中的静态方法 <code>xxx parseXxx(&quot;xxx类型的字符串&quot;);</code></p>
<p>int a = Integer.parseInt(“234”); // 直接使用类名调用对应方法</p>
<p>int parseInt(“intstring”);</p>
<p>long parseLong(“longstring”);</p>
<p>boolean parseBoolean(“booleanstring”);</p>
<p>只有 Charater, 没有 parse 方法</p>
<p>2)如果字符串被Integer进行对象的封装。</p>
<p>可使用另一个非静态方法，intValue();</p>
<p>将一个Integer对象转成基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(i.intValue() + <span class="number">1</span>);</span><br><span class="line">结果：<span class="number">124</span></span><br></pre></td></tr></table></figure>



<p>整数具备不同的进制体现</p>
<p><strong>十进制–&gt;其他进制</strong></p>
<p>​       toBinaryString 二进制</p>
<p>​       toOctalString 八进制</p>
<p>​       toHexString 十六进制</p>
<p>​       toString(int x,int radix) 转化为字符串，radix为以几进制的形式转化</p>
<p>其他进制–&gt;十进制</p>
<p>​       parseInt(String x,int radix)</p>
<h2 id="JDK1-5自动装箱拆箱"><a href="#JDK1-5自动装箱拆箱" class="headerlink" title="JDK1.5自动装箱拆箱"></a>JDK1.5自动装箱拆箱</h2><p>作比较</p>
<p>compareTo(another Integer)；大于、小于、等于分别返回1，-1和0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="string">"3"</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a.compareTo(b));</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line">结果：<span class="number">0</span></span><br><span class="line">     <span class="keyword">false</span></span><br><span class="line">     <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>Integer覆盖了Object中的equals方法。第一个输入的字符串自动转成数值</p>
<p>JDK1.5之后，简化了定义的方式</p>
<p>Integer i=new Integer(4);</p>
<p>可以直接写成Integer i=4; 这叫<strong>自动装箱</strong>，基本数据类型值赋值给引用数据类型值的时候会装箱，简化书写，这段代码等同于：Integer i=Integer.valueOf (4) 。</p>
<p>两个对象运算时可以写成i = i+ 6;</p>
<p>本来两个对象除了字符串是不能相加的，但这里做了一些动作：</p>
<p>i=new Integer(i.intValue()+6);//i.intValue() 这叫<strong>自动拆箱</strong>，即基本数据类型和引用数据类型进行运算时会拆箱。</p>
<p>这里注意Integer比int num多了一个null值，null一旦调用intValue()会发生控制异常，所以需要进行健壮性判断操作，这也是自动装箱拆箱的一个弊端</p>
<p>自动装箱拆箱一个特殊地方，可能会出<strong>面试题</strong></p>
<p><a href="https://blog.csdn.net/weixin_37650458/article/details/86714172" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37650458/article/details/86714172</a></p>
<p>这上面有具体的装箱和拆箱的题目实例，可以去看。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常用对象API-StringBuffer、StringBuilder类</title>
    <url>/2020/03/24/JavaSE-%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1API-StringBuffer%E3%80%81StringBuilder%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="常用对象API-StringBuffer、StringBuilder类"><a href="#常用对象API-StringBuffer、StringBuilder类" class="headerlink" title="常用对象API-StringBuffer、StringBuilder类"></a>常用对象API-StringBuffer、StringBuilder类</h1><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><h2 id="1特点-amp-添加功能-amp-插入"><a href="#1特点-amp-添加功能-amp-插入" class="headerlink" title="1特点&amp;添加功能&amp;插入"></a>1特点&amp;添加功能&amp;插入</h2><p>Buffer：缓冲区</p>
<p>StringBuffer:就是字符串缓冲区</p>
<p>​        用于存储数据的容器</p>
<p>特点：</p>
<p>1.长度是可变的</p>
<p>2.可以存储不同类型数据</p>
<p>3.最终要转成字符串进行使用</p>
<p>4.可以对字符串进行修改</p>
<a id="more"></a>

<p>功能：添加</p>
<p>StringBuffer append(data);</p>
<p>StringBuffer insert(index,data);//index是插入的位置索引，data是插入的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(<span class="number">2</span>).append(<span class="keyword">false</span>).append(<span class="string">"aa"</span>);</span><br><span class="line">sb.insert(<span class="number">2</span>,bb);</span><br><span class="line">结果：<span class="number">2f</span>alseaa</span><br><span class="line">     <span class="number">2f</span>bbalseaa</span><br></pre></td></tr></table></figure>

<p>2删除&amp;查找&amp;修改</p>
<p>删除</p>
<p>StringBuffer delete(int start,int end);包含头，不包含尾</p>
<p>StringBuffer deleteAt(int index);删除指定位置的元素</p>
<p>查找</p>
<p>char charAt(index);</p>
<p>int indexOf(string);</p>
<p>int lastIndexOf(string);</p>
<p>修改</p>
<p>StringBuffer replace(int start,int end,string str);</p>
<p>void setCharAt(index,char);</p>
<p>其他</p>
<p>设置长度：setLength(int num);</p>
<p>反转：reverse();</p>
<h2 id="3-可变长度数组"><a href="#3-可变长度数组" class="headerlink" title="3 可变长度数组"></a>3 可变长度数组</h2><p>StringBuffer有四种构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer();构造一个没有字符的字符串缓冲区，初始容量为<span class="number">16</span>个字符</span><br><span class="line">StringBuffer(CharSequence seq);构造一个包含与指定的相同字符的字符串缓冲区</span><br><span class="line">StringBuffer(<span class="keyword">int</span> capacity);构造一个没有字符的字符串缓冲区和指定的初始容量</span><br><span class="line">StringBuffer(String str);构造一个初始化为指定字符串内容的字符缓冲区</span><br></pre></td></tr></table></figure>

<p>如果用第一个构造方法，一开始默认是16个字符。若要进去第17个，则先复制原来的数组，创建为原来两倍的新数组，再将原来的数组复制到新数组。这是可变长度数组原理</p>
<p>第三个函数是指定初始容量。与第一个的区别是在于效率上。如果能一开始能确定数组在比如40个以内，则就构造40即可，若是第一个，一旦超过16，则要延长，要开辟空间，进行运算</p>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>1</p>
<p>StringBuilder类提供一个与StringBuffer兼容的API，功能一样，用法一样。其实就是一类。</p>
<p>但StringBuilder不保证同步，即不安全。</p>
<p>jdk1.5以后出现了功能和StringBuffer一模一样的对象，就是StringBuilder</p>
<p>不同的是</p>
<p>StringBuffer是线程同步的。通常用于多线程</p>
<p>StringBuilder是线程不同步的。通常用于单线程   </p>
<p>二者通常应该优先使用StringBuilder类，因为它支持所有相同的操作，但是由于它不执行同步，所以速度更快（不执行锁）。</p>
<p>jdk升级原因</p>
<p>1.简化书写</p>
<p>2.提高效率</p>
<p>3.增加安全性</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常用对象API-String类</title>
    <url>/2020/03/24/JavaSE-%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1API-String%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="常用对象API-String类"><a href="#常用对象API-String类" class="headerlink" title="常用对象API-String类"></a>常用对象API-String类</h1><h2 id="1特点"><a href="#1特点" class="headerlink" title="1特点"></a>1特点</h2><p>字符串对象一旦被初始化就不会被改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"abc"</span>;</span><br><span class="line">s = <span class="string">"nba"</span>;</span><br><span class="line">System.out.println(s);</span><br><span class="line">结果：nba</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p>s是引用型变量，“abc”是被创建的字符串变量，它是不会被改变的。s=“nba”只是s引用的地址发生了变化。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"abc"</span>;</span><br><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s == s1);</span><br><span class="line">结果：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>原因：”abc”存储在字符串常量池中。如果没有就创建，如果有就直接拿来用。所以s建立时，到字符串常量池中找abc，发现没有，就建立，然后相应的地址赋给s。当s1也创建abc时，也在常量池中找，发现有，就直接拿其地址赋给s1，所以s和s1地址一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"abc"</span>;</span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s == s1);</span><br><span class="line">System.out.println(s.equals(s1));</span><br><span class="line">结果：<span class="keyword">false</span></span><br><span class="line">     <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>首先第一条是创建一个字符串对象在常量池中，第二条是创建两个对象一个new一个字符串对象在堆内存当中。然后s所引用的地址是常量池中abc的地址，s1引用的地址是new对象在堆内存中的地址，所以直接这两者比较是false。但是使用了equals方法结果是true是因为string类是Object类的子类，其equals复写Object中的equals建立了string类自己的判断字符串对象是否相同的依据，其实也就是比较字符串内容。</p>
<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h2><p>String(char[ ] value) </p>
<p>分配一个新的String ，以便它表示当前包含在字符数组参数中的字符序列。</p>
<p>字符数组的内容被复制; 字符数组的后续修改不会影响新创建的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">'w'</span>,<span class="string">'a'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'x'</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(arr);</span><br><span class="line">结果：s = wapqx</span><br></pre></td></tr></table></figure>

<p>String(char[ ] value,int offset,int count) </p>
<p>分配一个新的String ，其中包含字符数组参数的子阵列中的字符。 </p>
<p>offset参数是子阵列的第一个字符的索引，count参数指定子阵列的长度。 </p>
<p>副本的内容被复制; 字符数组的后续修改不会影响新创建的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">'w'</span>,<span class="string">'a'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'x'</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(arr,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">结果：s = pqx</span><br></pre></td></tr></table></figure>

<p>String(byte[ ] bytes)</p>
<p>通过使用平台的默认字符集解码指定的字节数组来构造新的String 。 </p>
<p>新的String的长度是字符集的函数，因此可能不等于字节数组的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arr = &#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(arr);</span><br><span class="line">结果：s = ABCD</span><br></pre></td></tr></table></figure>

<p>数字相应转变为ASCII码中对应的字母。</p>
<p>更多的构造函数可以查看API文件</p>
<h2 id="3-常见功能-获取"><a href="#3-常见功能-获取" class="headerlink" title="3 常见功能-获取"></a>3 常见功能-获取</h2><p>1.获取</p>
<p>1.1 获取字符串中字符的个数(长度)</p>
<p>int length();</p>
<p>这与数组获取长度不用，数组获取长度是用的属性，而字符串是函数。</p>
<p>1.2 根据位置获取字符</p>
<p>char charAt(int index);</p>
<p>1.3 根据字符获取在字符串中第一次出现的位置即索引</p>
<p>int indexOf(int ch);参数是int类型，因为它会转成ASCII码。如果该字符不在则返回为-1</p>
<p>int indexOf(int ch,int fromIndex);从指定位置进行字符的查找，返回第一次出现的位置</p>
<p>int indexOf(String str);返回字符串在此字符串中第一次出现的位置</p>
<p>int indexOf(String str,int fromIndex);从指定位置进行字符串的查找，返回第一次出现的位置</p>
<p>根据字符获取在字符串中最后一次出现的位置即索引</p>
<p>int lastIndexOf(int ch);返回最后一次出现的位置</p>
<p>int lastIndexOf(int ch,int fromIndex);</p>
<p>int lastIndexOf(String str);</p>
<p>int lastIndexOf(String str,int fromIndex);</p>
<p>1.4 获取字符串中的一部分字符串，也叫子串</p>
<p>String substring (int beginIndex ,int endIndex);包含开始不包含结束</p>
<p>String substring (int beginIndex);</p>
<h2 id="4-常见功能-转换"><a href="#4-常见功能-转换" class="headerlink" title="4 常见功能-转换"></a>4 常见功能-转换</h2><p>2.1 将字符串变成字符串数组（字符串的切割）</p>
<p>String[ ] split(String regex);根据正则表达式的匹配拆分此字符串 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"张三,李四,王五"</span>;</span><br><span class="line">String[] arr = s.split(<span class="string">','</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">结果：张三</span><br><span class="line">     李四</span><br><span class="line">     王五</span><br></pre></td></tr></table></figure>

<p>如果是.的话，就需要转义一下，因为在正则表达式中.具有特殊的意义。转义需要两条反斜线，因为\.在正则表达式中也有特殊意义。</p>
<p>2.2 将字符串变成字符数组</p>
<p>char[ ] toCharArray();</p>
<p>2.3 将字符串转成字节数组</p>
<p>byte[ ] getBytes();</p>
<p>2.4 将字符串中的字母转成大小写</p>
<p>String toUpperCase();大写</p>
<p>String toLowerCase();小写</p>
<p>2.5 将字符串中的内容进行替换</p>
<p>String replace(char oldch,char newch);</p>
<p>String replace(string s1,string s2);</p>
<p>若要替换的字母在字符串中不存在，则该方法无效。然后两个引用变量的地址相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">String s2 = s1.replace(<span class="string">'a'</span>,<span class="string">'o'</span>);</span><br><span class="line">System.out.prinyln(s2);</span><br><span class="line">System.out.prinyln(s1 == s2);</span><br><span class="line">结果：jovo</span><br><span class="line">     <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>2.6 将字符串两端的空格去除</p>
<p>String trim();</p>
<p>2.7 将字符串进行连接</p>
<p>Srting concat(String str);</p>
<h2 id="5-常见功能-判断"><a href="#5-常见功能-判断" class="headerlink" title="5 常见功能-判断"></a>5 常见功能-判断</h2><p>3.1 两个字符串内容是否相同</p>
<p>boolean equals(Object obj);</p>
<p>boolean equalsIgnoreCase(String str);忽略大写比较字符串内容，原理就是全部转换成小写</p>
<p>3.2 字符串当中是否包含指定字符串</p>
<p>boolean contains(string str);</p>
<p>3.3 字符串是否以指定字符串开头，是否以指定字符串结尾</p>
<p>boolean startsWith(string str);</p>
<p>boolean endsWith(string str);</p>
<h2 id="6-常见功能-比较"><a href="#6-常见功能-比较" class="headerlink" title="6 常见功能-比较"></a>6 常见功能-比较</h2><p>对数值的比较用的是&lt;&gt;==等，如4&gt;1</p>
<p>对对象的比较如字符串用的是函数方法，如 “a”.compareTo(“A”)</p>
<p>字符串的比较是基于字符串中各个字符的Unicode值，按字典顺序将此String对象表示的字符序列与参数字符串所表示的字符序列进行比较</p>
<p>如果参数字符串等于此字符串，则返回值0。如果此字符串按字典顺序小于字符串参数，则返回一个小于0的值，如果此字符串按字典顺序大于字符串参数，则返回一个大于0的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.prinln(<span class="string">"abc"</span>.compareTo(<span class="string">"aqw"</span>));</span><br><span class="line">结果：-<span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="7-intern方法"><a href="#7-intern方法" class="headerlink" title="7 intern方法"></a>7 intern方法</h2><p>返回字符串对象的规范表示，可以对字符串池进行操作。 </p>
<p>最初为空的字符串池由类String私有地维护。 </p>
<p>当调用intern方法时，如果池已经包含与equals(Object)方法确定的等于此String对象的字符串，则返回来自池的字符串。否则，此String对象将添加到池中，并返回对此String对象的引用。 </p>
<p>它遵循以下规则，对于任何两个字符串s和t ，当且仅当s.equals(t)是true 时s.intern() == t.intern()是true。 </p>
<p>结果 </p>
<p>一个字符串与该字符串具有相同的内容，则保证来自一个唯一的字符串池。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-线程通信</title>
    <url>/2020/03/24/JavaSE-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="1-等待-唤醒机制"><a href="#1-等待-唤醒机制" class="headerlink" title="1 等待/唤醒机制"></a>1 等待/唤醒机制</h2><p>如何完成你输入一次我输出一次的操作。</p>
<p>这里就涉及到等待/唤醒机制</p>
<p>等待/唤醒机制</p>
<p>涉及的方法：</p>
<p>1.wait();</p>
<p>让线程处于冻结状态</p>
<p>被wait的线程会被存储到线程池中</p>
<p>如果线程在r锁被wait了，就存储在r锁的线程池中</p>
<p>就只能用r锁的notify来唤醒，锁就用来监视这个线程。</p>
<a id="more"></a>

<p>2.notify();</p>
<p>唤醒线程池中的一个线程（任意的）</p>
<p>3.notifyAll();</p>
<p>唤醒线程池中的所有线程</p>
<p>这些方法必须定义在同步中</p>
<p>因为这些方法是用于操作线程状态的方法，必须要明确到底操作的是哪个锁上的线程</p>
<p>为什么操作线程的方法定义在Object类中？</p>
<p>因为这些方法是监视器的方法，监视器其实就是锁。</p>
<p>锁可以是任意的对象，任意的对象调用的方法一定定义在Object当中。</p>
<p>if判断标记，只有一次，会导致不该运行的线程运行了，出现了数据错误的情况</p>
<p>while判断标记，解决了线程获取执行权后是否要运行！</p>
<p>notify只能唤醒一个线程，如果本方唤醒了本方，没有意义。而且while判断标记+notify会导致死锁</p>
<p>notifyAll解决了本方线程一定会唤醒对方线程。</p>
<p>但是唤醒所有的线程后，cpu执行的又是不需要的线程，则又要进行判断，这样效率不高，所以需要新的方法。</p>
<h2 id="2-JDK1-5新特性-Lock、Condition"><a href="#2-JDK1-5新特性-Lock、Condition" class="headerlink" title="2 JDK1.5新特性-Lock、Condition"></a>2 JDK1.5新特性-Lock、Condition</h2><p>1.5版本以后，有对同步进行技术更新              </p>
<p>原来synchronized(obj)中锁的操作是隐式的</p>
<p>1.5以后，引入lock 接口</p>
<p>Lock实现提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition。</p>
<p>思想：将同步和锁封装成了对象，并将操作锁的隐式方式定义到了该对象中，将隐式动作变成了显示动作。</p>
<p>所以相应的代码转变为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        code...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转变为</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock()<span class="comment">//获取锁</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock.unlock()放在finally中是因为万一执行代码出现异常，如果不放在这里，则不会执行解锁，但我们需要每步之后都要解锁。</p>
<p>Condition将Object监视器方法（ wait，notify和notifyAll）分装成不同的对象，以便通过将这些对象与任意Lock实现组合使用，为每个对象提供多个等待set（wait-set）。其中，Lock替换synchronized方法和语句的使用，Condition取代了Object监视器方法的使用。</p>
<p>即以前一个锁只有一组监视器方法，现在可以创建多个Condition对象，这样现在一个锁就可以有多个监视器方法</p>
<p>转变如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    notify();</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"><span class="keyword">synchronized</span>(d)&#123;</span><br><span class="line">    d.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Condition</span></span>&#123;</span><br><span class="line">    await();<span class="comment">//对标wait();</span></span><br><span class="line">    signal();<span class="comment">//对标notify();</span></span><br><span class="line">    signalAll();<span class="comment">//对标signalAll();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转变为</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> reentrantLock();</span><br><span class="line">Condition c1 = lock.newCondition();</span><br><span class="line">Condition c2 = lock.newCondition();</span><br></pre></td></tr></table></figure>

<p>Lock接口：出现替代了同步代码块或者同步函数，将同步的隐式锁操作变成现实锁操作</p>
<p>同时更为灵活，可以一个锁上加上多组监视器</p>
<p>lock();获取锁</p>
<p>unlock();释放锁，通常需要定义在finally代码块中</p>
<p>Conditon接口：出现替代了Object中的wait notify notifyAll方法</p>
<p>​              将这些监视器方法单独进行了封装，变成Condition监视器对象</p>
<p>​              可以任意锁进行组合</p>
<p>await(); signal(); signalAll();</p>
<h2 id="3-wait和sleep的区别"><a href="#3-wait和sleep的区别" class="headerlink" title="3  wait和sleep的区别"></a>3  wait和sleep的区别</h2><p>wait和sleep区别</p>
<p>1.wait可以指定时间也可以不指定</p>
<p> sleep必须指定时间</p>
<p>2.在同步中是，对cpu的执行权和锁的处理不同</p>
<p> wait：释放执行权，释放锁</p>
<p> sleep：释放执行权，不释放锁</p>
<p>同步中可以进入有多个线程，但是要执行只能拿到锁的才能执行。</p>
<h2 id="4-停止线程的方式"><a href="#4-停止线程的方式" class="headerlink" title="4 停止线程的方式"></a>4 停止线程的方式</h2><p>第一种方式：定义标记</p>
<p>1.stop方法，已过时，不建议使用</p>
<p>2.run方法结束</p>
<p>怎么控制线程的任务结束</p>
<p>任务中都会有循环结构，只要控制住循环就可以结束任务。</p>
<p>控制循环通常就用定义标记来完成</p>
<p>第二种方式：Interrupt</p>
<p>但是如果线程处于冻结状态，就无法读取标记</p>
<p>可以使用interrupt();方法将线程从冻结状态强制恢复到运行状态中来，让线程具备cpu执行资格</p>
<p>但是强制动作会发生InterruptedException，记得要处理</p>
<h2 id="5-守护线程-setDaemon"><a href="#5-守护线程-setDaemon" class="headerlink" title="5 守护线程-setDaemon"></a>5 守护线程-setDaemon</h2><p>setDaemon();该方法将此线程标记为daemon线程或用户线程。</p>
<p>当正在运行的线程都是守护进程线程时，Java虚拟机将退出。</p>
<p>该方法必须在线程启动前调用。</p>
<p>也可以称为联合线程，后台线程</p>
<p>后台线程：它和前台线程都正常进行开启，运行也一样。结束时。前台线程结束需要手动结束，而后台线程如果所有前台都结束了，后台线程无论处于什么状态，都将结束。</p>
<h2 id="6-其他方法"><a href="#6-其他方法" class="headerlink" title="6 其他方法"></a>6 其他方法</h2><p>join</p>
<p>在进行线程运算时，希望临时加入一个线程进来进行运算，这是就要使用join方法。</p>
<p>join方法：等待这个线程结束，会抛出InterruptedException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="function">Thread <span class="title">t1</span><span class="params">(d)</span></span>;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="function">Thread <span class="title">t2</span><span class="params">(d)</span></span>;</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        </span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中：</p>
<p>第一个join方法：t1线程申请要加入进来，运行，然后主线程释放执行权和执行资格，主线程处于冻结状态。然后等待该线程运行结束才重新获得执行权</p>
<p>第二个join方法：若join在这，则主线程释放执行权和执行资格，处于冻结状态，t1和t2争抢执行权。主线程只有等t1执行完之后才能够重新获得执行资格和执行权</p>
<p>toString();返回此线程的字符串表示，包括线程的名称、优先级和线程组</p>
<p>*.setPriority(Thread.MAX_PRIORITY);可以将其设置为最高优先级</p>
<p>线程组</p>
<p>表示一个线程的集合。此外，线程组也可以包含其他线程。线程组构成一颗树，在树中，除了初始线程组外，每个线程组都有一个父线程组。具体以后再说。</p>
<p>yield();暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>即当线程执行该方法时，释放执行权。这样别的线程和该线程又开始同时竞争执行权</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-线程安全、同步、锁</title>
    <url>/2020/03/23/JavaSE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E9%94%81/</url>
    <content><![CDATA[<h1 id="线程安全、同步、锁"><a href="#线程安全、同步、锁" class="headerlink" title="线程安全、同步、锁"></a>线程安全、同步、锁</h1><h2 id="1-线程安全问题的现象、问题产生的原因"><a href="#1-线程安全问题的现象、问题产生的原因" class="headerlink" title="1 线程安全问题的现象、问题产生的原因"></a>1 线程安全问题的现象、问题产生的原因</h2><p>建立多线程进行买票操作时，可能会出现这样一种状况：假设当票数减到1时，cpu切到线程0运行，符合票数&gt;0的条件，线程0就具备执行资格，但这时cpu突然切换到线程1，同样这时票数还是为1，线程1也符合条件，具备执行资格，然后这时cpu又切换回线程0，执行输出语句，执行完，票数变为0，然后切到线程1，执行输出语句，这时票数输出为0，但这是不符合条件的，却又输出了。这就出现了线程安全问题。</p>
<p><strong>线程安全问题产生的原因</strong>:</p>
<p>1.多个线程在操作共享数据。</p>
<p>2.操作共享数据的线程代码有多条</p>
<p>当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问题的产生。</p>
<a id="more"></a>

<h2 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2 同步代码块"></a>2 同步代码块</h2><p>解决上述问题的方法</p>
<p>解决思路</p>
<p>就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码时,其他线程不可以参与运算，</p>
<p>必须要当前线程把这些代码都执行完毕以后，其他线程才可以参与运算。</p>
<p>在java中，用同步代码块就可以解决这个问题</p>
<p>同步代码块的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">				<span class="keyword">if</span>(num &gt; <span class="number">0</span>)</span><br><span class="line">                    System.out.println(num--);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-同步的原理"><a href="#3-同步的原理" class="headerlink" title="3 同步的原理"></a>3 同步的原理</h2><p>原理：synchronized(对象)，里面的对象是同步锁，当线程0运行到此时判断锁为1，就运行里面的代码，同时同步锁变为0。当线程0被睡眠时，cpu执行线程1，但是线程1运行到此时，同步锁为0，不能运行里面的代码，所以就解决了上述的问题。</p>
<h2 id="4-同步的前提"><a href="#4-同步的前提" class="headerlink" title="4 同步的前提"></a>4 同步的前提</h2><p>同步的前提：同步中必须有多个线程并使用同一个锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">            <span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">				<span class="keyword">if</span>(num &gt; <span class="number">0</span>)</span><br><span class="line">                    System.out.println(num--);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述中将同步对象定义在run函数中，这样当线程执行start()时，每个线程就都有一个锁，安全问题就没有得到解决。</p>
<h2 id="5-同步函数"><a href="#5-同步函数" class="headerlink" title="5 同步函数"></a>5 同步函数</h2><p>我们引入同步函数，即同步的第二种表现形式。被同步关键字修饰的函数就是同步函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num &gt; <span class="number">0</span>)</span><br><span class="line">            	System.out.println(num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证同步函数的锁</p>
<p><strong>同步函数使用的锁是：this</strong></p>
<p>同步函数和同步代码块的<strong>区别</strong>：</p>
<p>同步函数的锁是固定的this</p>
<p>同步代码块的锁是任意的对象</p>
<p><strong>建议使用同步代码块。</strong></p>
<p>验证程序：构造两个线程，一个线程用同步代码，一个线程用同步函数，若改变同步代码块里的锁，若不出现安全问题，则同步代码块里的锁就是同步函数的锁。</p>
<p>验证<strong>静态</strong>同步函数的锁</p>
<p>静态的同步函数使用的锁：</p>
<p><strong>该函数所属字节码文件对象</strong>，可以用getClass方法获取，也可以用当前 类名.class 表示。</p>
<p>锁对象是唯一的。</p>
<h2 id="6-单例模式涉及的多线程问题"><a href="#6-单例模式涉及的多线程问题" class="headerlink" title="6 单例模式涉及的多线程问题"></a>6 单例模式涉及的多线程问题</h2><p>懒汉式在多线程时会遇到安全问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样多线程就会产生多个对象，达不到单例效果</p>
<p>为了解决该问题，则同步</p>
<p>1.使用同步函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然解决了安全问题，但是效率会很低</p>
<p>2使用同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>()&#123;</span><br><span class="line">            	<span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            		s = <span class="keyword">new</span> Single();</span><br><span class="line">        		&#125;	 </span><br><span class="line">        	&#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样既解决了安全问题，又解决了效率问题</p>
<h2 id="7-死锁示例"><a href="#7-死锁示例" class="headerlink" title="7 死锁示例"></a>7 死锁示例</h2><p>死锁：常见情景之一：同步的嵌套，即假设有两个线程，它们各自拿着一个锁，想进去有着另一个锁的同步代码块，但双方拿着锁不放，这样就进不去另一锁的同步代码块，就死锁了。</p>
<p>一个简单的死锁程序代码，面试若让当场写出一个就可以写这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    Test(<span class="keyword">boolean</span> flag)&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Myclock.locka)&#123;</span><br><span class="line">                System.out.println(<span class="string">"if locka..."</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(Myclock.lockb)&#123;</span><br><span class="line">                     System.out.println(<span class="string">"if lockb..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Myclock.lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"else lockb..."</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(Myclock.locka)&#123;</span><br><span class="line">                     System.out.println(<span class="string">"else locka..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mylock</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object locka = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lockb = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test(<span class="keyword">true</span>);</span><br><span class="line">        Test b = <span class="keyword">new</span> Test(<span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(b);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-多线程</title>
    <url>/2020/03/23/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-多线程-概述"><a href="#1-多线程-概述" class="headerlink" title="1 多线程-概述"></a>1 多线程-概述</h2><p>进程：正在进行中的程序（直译）</p>
<p>线程：就是进程中一个负责程序执行的控制单元（执行路径）</p>
<p>一个进程中可以有多个执行路径，称之为多线程</p>
<p>一个进程当中至少有个线程。</p>
<p>开启多个线程是为了同时运行多部分代码</p>
<p>每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务。</p>
<p>好处与弊端</p>
<p>好处：解决了多部分同时运行的问题。</p>
<p>弊端：线程太多会导致效率低下，因为一个cpu只能同行运行一个线程，线程太多则会让cpu效率降低。</p>
<p>其实应用程序的执行都是cpu在做着快速的切换完成的。这个切换是随机的。</p>
<a id="more"></a>

<h2 id="2-JVM中的多线程解析"><a href="#2-JVM中的多线程解析" class="headerlink" title="2 JVM中的多线程解析"></a>2 JVM中的多线程解析</h2><p>JVM启动时就启动了多个线程，至少有两个线程可以分析的出来</p>
<p>1.执行main函数的线程，</p>
<p>​       该线程的任务代码都定义在main函数中。</p>
<p>2.负责垃圾回收的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;<span class="comment">//当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</span></span><br><span class="line">        System.out.println(<span class="string">"demo ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">        System.gc();<span class="comment">//运行垃圾回收器</span></span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果<span class="number">1</span>：hello world		结果<span class="number">2</span>：demo ok			结果<span class="number">3</span>：hello world</span><br><span class="line">      demo ok				hello world			  demo ok</span><br><span class="line">      demo ok				demo ok</span><br></pre></td></tr></table></figure>

<p>这个例子显示了有两个线程在运行。当启动垃圾回收器时，就运行了垃圾回收线程，然后主线程仍在运行，所以会出现Hello World！。因为cpu运行线程的时候是随机的，所以Hello World！和demo ok出现顺序也是随机的。当函数运行结束时，虚拟机关闭，导致强制回收，所以出现demo ok的个数也不一样。</p>
<h2 id="3-主线程运行实例、多线程创建的方式-继承Thread类"><a href="#3-主线程运行实例、多线程创建的方式-继承Thread类" class="headerlink" title="3 主线程运行实例、多线程创建的方式-继承Thread类"></a>3 主线程运行实例、多线程创建的方式-继承Thread类</h2><p>Thread：是程序中的执行线程。Java虚拟机允许应用程序<strong>并发</strong>地运行多个执行线程。</p>
<p>创建线程的目的是为了开启一条执行路径，让指定的代码和其他代码实现同时运行</p>
<p>而运行的指定代码就是这个执行路径的任务</p>
<p>而自定义的线程它的任务在哪呢？</p>
<p>Thread类用于描述线程，线程是需要任务的。所以Thread类也有对任务的描述</p>
<p>这个任务就通过<strong>Thread类中的run方法</strong>来体现，也就是说run方法就是封装自定义线程运行任务的函数。</p>
<p>run方法中定义就是线程要运行的任务代码。所以需要<strong>覆盖Thread类中的run方法</strong>。</p>
<p>开启线程是为了运行指定代码，所有只有继承Thread类并复写run方法，将运行的代码定义在run方法中即可。</p>
<p>如何创建一个线程</p>
<p><strong>创建线程方式一</strong>：继承Thread类</p>
<p>步骤：</p>
<p>1.定义一个类继承Thread类</p>
<p>2.覆盖Thread类中run方法</p>
<p>3.直接创建Thread类中的子类对象创建线程</p>
<p>4.调用start方法开启线程，并调用线程的任务，run方法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Threads</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Demo(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">"...x="</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo d1 = <span class="keyword">new</span> Demo(<span class="string">"啊啊啊"</span>);</span><br><span class="line">        Demo d2 = <span class="keyword">new</span> Demo(<span class="string">"aaa"</span>);</span><br><span class="line">        d1.start();<span class="comment">//开启线程</span></span><br><span class="line">        d2.start();</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考</strong>：调用run和调用start有什么区别</p>
<p>调用run相当于调用了一个普通的方法，还是在主线程中运行，没有实现多线程。调用start开启了新的线程，run方法自动在该新线程运行。</p>
<h2 id="4-Thread类中的方法-amp-线程名称"><a href="#4-Thread类中的方法-amp-线程名称" class="headerlink" title="4 Thread类中的方法&amp;线程名称"></a>4 Thread类中的方法&amp;线程名称</h2><p>可以通过Thread类中的getName方法获取线程的名称：Thread-编号（从0开始）</p>
<p>当线程一创建时就会有名称，不管它有没有开启。</p>
<p>返回当前运行线程的名字用currentThread方法：Thread.currentThread().getName();</p>
<p>返回对当前正在执行的线程对象的引用。 </p>
<p>结果：当前正在执行的线程。</p>
<p>也可以给线程命名，因为Thread类中有Thread(String name)构造函数</p>
<h2 id="5-多线程运行图解"><a href="#5-多线程运行图解" class="headerlink" title="5 多线程运行图解"></a>5 多线程运行图解</h2><p>主线程路径在执行的过程中，当读到d1.start()时，开启一条路径run，当读到d2.start()时。又开启一条路径run。相当于每个路径在栈中都有一个独立的空间，且互不冲突。每个run方法里面都有个变量x。如果有个线程执行一个方法，则这个方法就进这个线程所在的栈区，结束后弹栈。这个线程的run方法结束，则这个线程所占用的空间就释放。如果主线程结束了，虚拟机不会结束，因为还有线程在运行。所以只要有线程在运行，虚拟机就不会结束。</p>
<p>如果哪个线程发生了异常，则这个线程就停止执行，但其他线程不受到影响。</p>
<h2 id="6-线程的状态"><a href="#6-线程的状态" class="headerlink" title="6 线程的状态"></a>6 线程的状态</h2><p>线程有四种状态</p>
<p>被创建、运行、冻结、消亡</p>
<p>CPU的执行资格：可以被cpu处理，在处理队列中排队</p>
<p>CPU的执行权：正在被cpu处理</p>
<h2 id="7-创建线程的第二种方式-实现Runnable接口"><a href="#7-创建线程的第二种方式-实现Runnable接口" class="headerlink" title="7 创建线程的第二种方式-实现Runnable接口"></a>7 创建线程的第二种方式-实现Runnable接口</h2><p>如果类已经继承了一个父类，则若准备扩展Demo类的功能，让其中的内容可以作为线程的任务执行，需要通过接口完成。所有就有了第二种方式</p>
<p>Runnable接口：应该由那些打算通过某一线程执行其实例的类来实现。类必须定义为一个称为run的无参数方法。</p>
<p>创建线程的第二种方式：实现Runnable接口</p>
<p>1.定义类实现Runnable接口</p>
<p>2.覆盖接口中的run方法，将线程的任务代码封装到run方法中</p>
<p>3.通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类构造函数的</p>
<p>参数进行传递</p>
<p>​    <strong>为什么</strong>？</p>
<p>​    因为线程任务都封装在Runnable接口子类对象的run方法中，所以要在线程对象创建时就必须明确要运行的任务。</p>
<p>4.调用线程对象的start方法开启线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"..."</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节：</p>
<p>Thread t1= new Thread(d);</p>
<p>这里有个细节就是本身Thread类里面有一个run方法，对象d里面也有一个run方法，那么到底是执行哪个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable r;</span><br><span class="line">    Thread()&#123;&#125;;</span><br><span class="line">    Thread(Runnable r)&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> run <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadImp1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Threads</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"haha"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadImp1 i = <span class="keyword">new</span> ThreadImp1();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(i);</span><br><span class="line">Demo t2 = <span class="keyword">new</span> Demo();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>从这个化简的源代码进行分析。</p>
<p>第二个方式的好处</p>
<p>Runnable接口的出现仅仅是将线程的任务进行了对象的封装。这是思想上的转变，需要重点关注。</p>
<p>Thread类对Runnable接口进行了默认实现。</p>
<p>实现Runnable接口的好处：</p>
<p>1.将线程的任务从线程的子类中分离出来进行了单独的封装，按照面向对象的思想将任务封装成对象。</p>
<p>2.避免了java单继承的局限性</p>
<p>所以创建线程的第二种方式较为常用。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象-包</title>
    <url>/2020/03/22/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8C%85/</url>
    <content><![CDATA[<h1 id="面向对象-包"><a href="#面向对象-包" class="headerlink" title="面向对象-包"></a>面向对象-包</h1><h2 id="1-面向对象-包-概述"><a href="#1-面向对象-包-概述" class="headerlink" title="1 面向对象-包-概述"></a>1 面向对象-包-概述</h2><p>对类文件进行分类管理</p>
<p>给类提供多层命名（名称）空间</p>
<p><strong>写在程序文件第一行</strong></p>
<p><strong>类名的全称的：包名.类名。</strong></p>
<p>包也是一种封装形式</p>
<p>包在系统中的表现形式是文件夹</p>
<p>包命名时字母都小写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br></pre></td></tr></table></figure>

<p>也可以创建多级包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack.aa.bb.cc.dd</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-面向对象-包-包之间的访问-protected"><a href="#2-面向对象-包-包之间的访问-protected" class="headerlink" title="2 面向对象-包-包之间的访问-protected"></a>2 面向对象-包-包之间的访问-protected</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PackageDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DemoA d = <span class="keyword">new</span> DemoA();</span><br><span class="line">        d.show();</span><br><span class="line">        System.out.println(<span class="string">"hello package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> packa;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"demoa show run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，要先编译DemoA.java。以前在同一个包中时，先编译PackageDemo.java时，会在当前包中找所需要的类，如果没有就找需要的.java源文件。但是现在不在同一个包中，DemoA有个包所属，所以我们要用的这个类全称是packa.DemoA.class，如果没有就找packa.DemoA.java，然而在目前的情况下是找不到，因为其源文件不在packa文件夹中，在别的地方，所以是找不到的。所以要先编译后者。</p>
<p>按顺序编译后出现问题</p>
<p>原因 类型名写错</p>
<p>因为DemoA类已经有包的所属，所以必须要明确其包名</p>
<p>记住：DemoA这个名字是错的，正确的名称是<strong>包名.类名. packa.DemoA</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">packa.Demoa d = <span class="keyword">new</span> packa.DemoA();</span><br></pre></td></tr></table></figure>

<p>再次编译，仍出现问题</p>
<p>原因：DemoA不是公共的，加public</p>
<p>加了之后，还是出现问题</p>
<p>原因：show()不是公共的，加public</p>
<p>总结：</p>
<p>包与包之间的类进行访问，被访问的包中的类必须是public的，被访问包中的类的方法也必须是public的。</p>
<p>protected（保护）：被这个修饰的类、函数。同一包中的类可以访问，不同包中，只有其子类才可以使用。</p>
<table>
<thead>
<tr>
<th>四种权限</th>
<th>public</th>
<th>protected</th>
<th>default(默认全限)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
</tr>
<tr>
<td>同一包中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
</tr>
<tr>
<td>子类中</td>
<td>ok</td>
<td>ok</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中</td>
<td>ok</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-面向对象-包-导入import"><a href="#3-面向对象-包-导入import" class="headerlink" title="3 面向对象-包-导入import"></a>3 面向对象-包-导入import</h2><p>Import：导入其他包中的类。这样在调用其他包中的类就不用加包名称，简化类名书写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br><span class="line"><span class="keyword">import</span> packa.DemoA;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PackageDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DemoA d = <span class="keyword">new</span> DemoA();</span><br><span class="line">        d.show();</span><br><span class="line">        System.out.println(<span class="string">"hello package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>import packa.<em>;：导入了packa包中所有的类，但*</em>不导入其包中的子包**。</p>
<p>比如</p>
<p>packa\DemoA.class</p>
<p>packa\abc\DemoAbc.class</p>
<p>import packa.*时，不导入DemoAbc.class。</p>
<p><strong>导包原则</strong>：用到哪个类，就导入哪个类，不建议一起全部导入。</p>
<p>4 面向对象-包-jar包</p>
<p>Jar：java的压缩包，不是图形化界面的工具，是dos命令行形式的工具</p>
<p>用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files …</p>
<p>选项:</p>
<p>  -c 创建新档案</p>
<p>  -t 列出档案目录</p>
<p>  -x 从档案中提取指定的 (或所有) 文件</p>
<p>  -u 更新现有档案</p>
<p>  -v 在标准输出中生成详细输出</p>
<p>  -f 指定档案文件名</p>
<p>  -m 包含指定清单文件中的清单信息</p>
<p>  -n 创建新档案后执行 Pack200 规范化</p>
<p>  -e 为捆绑到可执行 jar 文件的独立应用程序</p>
<p>​    指定应用程序入口点</p>
<p>  -0 仅存储; 不使用任何 ZIP 压缩</p>
<p>  -P 保留文件名中的前导 ‘/‘ (绝对路径) 和 “..” (父目录) 组件</p>
<p>  -M 不创建条目的清单文件</p>
<p>  -i 为指定的 jar 文件生成索引信息</p>
<p>  -C 更改为指定的目录并包含以下文件</p>
<p>如果任何文件为目录, 则对其进行递归处理。</p>
<p>清单文件名, 档案文件名和入口点名称的指定顺序</p>
<p>与 ‘m’, ‘f’ 和 ‘e’ 标记的指定顺序相同。</p>
<p>示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中:</p>
<p>​    jar cvf classes.jar Foo.class Bar.class</p>
<p>示例 2: 使用现有的清单文件 ‘mymanifest’ 并将 foo/ 目录中的所有文件归档到 ‘classes.jar’ 中:</p>
<p>​    jar cvfm classes.jar mymanifest -C foo/ .</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象-Object类</title>
    <url>/2020/03/22/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="面向对象-Object类"><a href="#面向对象-Object类" class="headerlink" title="面向对象-Object类"></a>面向对象-Object类</h1><h2 id="1-面向对象-Object类-equals方法、equals方法覆盖"><a href="#1-面向对象-Object类-equals方法、equals方法覆盖" class="headerlink" title="1 面向对象-Object类-equals方法、equals方法覆盖"></a>1 面向对象-Object类-equals方法、equals方法覆盖</h2><p>equals比较对象是否相同，<strong>比较的是地址</strong>。</p>
<p>但是单纯比较地址值没有意义，一般都会覆盖equals方法，根据对象的特有内容，建立判断对象是否相同的依据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))<span class="comment">//先判断是否为同类型&#123;</span></span><br><span class="line">            <span class="function">thow new <span class="title">ClassCastException</span><span class="params">(<span class="string">"类型错误"</span>)</span></span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	Person p = (Person) obj;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.age == p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">30</span>);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">20</span>);</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-面向对象-Object类-hashCode方法"><a href="#2-面向对象-Object类-hashCode方法" class="headerlink" title="2 面向对象-Object类-hashCode方法"></a>2 面向对象-Object类-hashCode方法</h2><p>hashCode：返回该对象的哈希码值</p>
<p>实际上Object类定义的hashCode方法确实会针对不同的对象返回不同的整数（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是Java编程语言不需要这种实现技巧）。</p>
<p>在Java应用程序执行期间，在对同一个对象多次调用hashCode方法时，必须一致地返回相同的整数，前提是将对象进行equals比较时所用的信息没有被修改，</p>
<p>如果根据equals方法两个对象是相等的，那么对这两个对象进行hashCode方法都必须生成相同的整数结果。</p>
<p>当equals被重写时，通常有必要重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
<p>同样也可以复写其方法，改变哈希值的算法定义</p>
<h2 id="3-面向对象-Object类-getClass方法"><a href="#3-面向对象-Object类-getClass方法" class="headerlink" title="3 面向对象-Object类-getClass方法"></a>3 面向对象-Object类-getClass方法</h2><p>getClass方法返回此Object的运行时类，返回的是当前对象所属的字节码文件对象，</p>
<p>即class Class，里面有名称、字段（属性）、构造器、方法。</p>
<p>如果加载进一个Person类，第一步在堆中产生一个对应的字节码文件对象，即Person.Class</p>
<p>所以当类加载时，就会有对象产生，</p>
<h2 id="4-面向对象-Object类-toString方法"><a href="#4-面向对象-Object类-toString方法" class="headerlink" title="4 面向对象-Object类- toString方法"></a>4 面向对象-Object类- toString方法</h2><p>toString方法返回该对象的字符串表示</p>
<p>Object类的该方法返回一个字符串，该字符串有类名、@、和此对象哈希码的无符号+十六进制表示组成，换句话说，该方法返回一个字符串，它的值等于</p>
<p>getClass().getName()+”@”+Interger.toHexString(hashCode())</p>
<p>建议所有子类都重写该方法。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象异常</title>
    <url>/2020/03/22/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="面向对象-异常"><a href="#面向对象-异常" class="headerlink" title="面向对象-异常"></a>面向对象-异常</h1><h2 id="1-面向对象-异常-概述"><a href="#1-面向对象-异常-概述" class="headerlink" title="1 面向对象-异常-概述"></a>1 面向对象-异常-概述</h2><p>异常：是在运行时期发生的不正常情况。</p>
<p>在java中用类的形式对不正常情况进行描述和封装对象</p>
<p>描述不正常的情况的类，就称为异常类。</p>
<p>以前正常流程代码和问题处理代码相结合，</p>
<p>现在将正常流程代码和问题处理代码分离，提高阅读性。</p>
<p>其实异常就是java通过面向对象的思想将问题封装成了对象</p>
<p>用异常类对其进行描述。</p>
<p>不同的问题用不同的类进行具体的描述。比如角标越界，空指针等等。</p>
<a id="more"></a>

<h2 id="2-面向对象-异常-体系"><a href="#2-面向对象-异常-体系" class="headerlink" title="2 面向对象-异常-体系"></a>2 面向对象-异常-体系</h2><p>问题很多，意味着描述的类也很多</p>
<p>将其共性进行向上抽取，形成了异常体系</p>
<p>最终问题（不正常情况）分成两大类</p>
<p>Throwable:无论是error还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理</p>
<p>​           该体系的特点就在于Throwable及其所有的子类都具有可抛性。</p>
<p>可抛性指的是什么？如何体现可抛性？</p>
<p>​           通过两个关键字来体现的，分别是throws，throw</p>
<p>​           凡是可以被这两个关键字所操作的类和对象都具备可抛性。</p>
<p>1.一般不可处理的。用Error表示</p>
<p>​    特点：是有jvm抛出的严重性的问题</p>
<p>​       这种问题发生一般不针对性处理。直接修改程序。</p>
<p>2.可处理的。用Exception表示</p>
<p>该体系特点：</p>
<p>子类的后缀名都是用其父类名作为后缀，阅读性很强。</p>
<h2 id="3-面向对象-异常-原理-amp-异常对象的抛出throw"><a href="#3-面向对象-异常-原理-amp-异常对象的抛出throw" class="headerlink" title="3 面向对象-异常-原理&amp;异常对象的抛出throw"></a>3 面向对象-异常-原理&amp;异常对象的抛出throw</h2><p>原理：</p>
<p>1.遇到识别的问题进行对象的封装</p>
<p>2.将问题抛给调用者，结束函数。</p>
<p>我们可以自己设置异常</p>
<p>谁调用就将异常抛给谁，还可以自己定义异常信息，这里用到了throw 关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组引用不能为空"</span>);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= arr.length)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"角标越界"</span>);</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"角标不能为负数"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">int</span> num = d.method(<span class="keyword">null</span>, -<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：Exception in thread <span class="string">"main"</span> java.lang.NullPointException：数组的引用不能为空</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-异常-自定义异常-amp-异常类的抛出throws"><a href="#4-面向对象-异常-自定义异常-amp-异常类的抛出throws" class="headerlink" title="4 面向对象-异常-自定义异常&amp;异常类的抛出throws"></a>4 面向对象-异常-自定义异常&amp;异常类的抛出throws</h2><p>对于角标是整数不存在，可以用角标越界表示</p>
<p>对于负数为角标的情况，准备用负数角标异常来表示</p>
<p>负数角标这种异常在java中并没有定义过</p>
<p>那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象</p>
<p>这种自定义的问题描述称为自定义异常</p>
<p><strong>注意</strong>：如果让一个类成为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性才可以被两个关键字所操作，throws，throw</p>
<p>除此之外，如果函数内发生了异常，<strong>还需要在函数上进行声明</strong>，如下所示。否则编译失败，声明的目的是为了处理。调用发生异常的函数，必须要处理，处理的方式之一就是抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(...)</span> <span class="keyword">throws</span> xxxException</span></span><br></pre></td></tr></table></figure>

<h2 id="5-编译时检测异常和运行时异常的区别-amp-throw和throws的区别"><a href="#5-编译时检测异常和运行时异常的区别-amp-throw和throws的区别" class="headerlink" title="5 编译时检测异常和运行时异常的区别&amp;throw和throws的区别"></a>5 编译时检测异常和运行时异常的区别&amp;throw和throws的区别</h2><p>异常的分类</p>
<p>1.编译时被检测异常：只要是Exception和其子类都是，除了特殊子类RuntimeException体系。</p>
<p>​    这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。</p>
<p>​    这样的问题都可以针对性的处理。</p>
<p>2.编译时不检测异常（运行时异常）：就是Exception中的RuntimeException和其子类</p>
<p>​    RuntimeException是那些可能在Java虚拟机正常运行期间抛出的异常超类。</p>
<p>​    这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的或者引发了内部状态的改变导致的。</p>
<p>​    这种问题一般不处理，直接编译通过，在运行时，让调用者调用时的程序强制停止，让调用者对代码进行修正。</p>
<p>​    在执行方法期间抛出但未被捕获的RuntimeException的任何子类都无需再throws子句中进行声明。</p>
<p>throws和throw的区别</p>
<ol>
<li><p>throws使用在函数上</p>
<p>throw使用在函数内</p>
</li>
<li><p>throws抛出的是异常类，可以抛出多个，用逗号隔开</p>
<p>throw抛出的是异常对象，只能抛出一个，因为抛出后函数就停止了。</p>
</li>
</ol>
<h2 id="6-面向对象-异常-异常捕捉trycatch"><a href="#6-面向对象-异常-异常捕捉trycatch" class="headerlink" title="6 面向对象-异常-异常捕捉trycatch"></a>6 面向对象-异常-异常捕捉trycatch</h2><p>异常处理的捕捉形式：</p>
<p>这是可以对异常进行针对性处理的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//需要被检测异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 变量)<span class="comment">//该变量用于接收发生的异常对象&#123;</span></span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候用trycatch</p>
<p>当在这里可以处理时用trycatch，如果不能处理，则继续抛出。</p>
<p>过程：</p>
<p>执行method函数，函数进栈，往里面传值。-30满足条件，则异常抛出被触发，然后将异常抛出到主函数调用的部分中。然后try开始检测，检测到后丢给了catch，然后catch里的参数变量接收异常对象即FuShuIndexException e=new FuShuIndexException(“角标变成负数啦”);</p>
<p>若传入的值是不发生异常的，则程序正常运行</p>
<p>对catch里面的异常类对象进行常见方法调用</p>
<p>e.getMessage()</p>
<p>e.printStackTrace()</p>
<p>略</p>
<h2 id="7-面向对象-异常-多catch情况"><a href="#7-面向对象-异常-多catch情况" class="headerlink" title="7 面向对象-异常-多catch情况"></a>7 面向对象-异常-多catch情况</h2><p>有几个抛出就有几个catch</p>
<p>有多个catch，抛出的异常就按顺序进行catch。</p>
<p>然后多catch情况下父类的catch放在最下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(...)</span> <span class="keyword">throws</span> xxxException，yyyException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>() <span class="keyword">throw</span> <span class="keyword">new</span> xxxException();</span><br><span class="line">    <span class="keyword">if</span>() <span class="keyword">throw</span> <span class="keyword">new</span> yyyException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//因为有trycatch了所以不用声明</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">int</span> num = d.method(<span class="keyword">null</span>, -<span class="number">30</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(xxxException e)&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(yyyException e)&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	System.out.println(“over”);</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-面向对象-异常-异常处理原则"><a href="#8-面向对象-异常-异常处理原则" class="headerlink" title="8 面向对象-异常-异常处理原则"></a>8 面向对象-异常-异常处理原则</h2><p>异常处理的原则：</p>
<p>1.函数内部如果抛出异常需要检测的异常，那么函数上必须要声明，否则必须在函数内用trycatch捕捉，否则编译失败。</p>
<p>2.如果调用到了声明异常的函数，要么trycatch要么throws，否则编译失败。</p>
<p>3.什么时候catch，什么时候throws：功能内部可以解决用catch，解决不了用throws，告诉调用者，由调用者解决。</p>
<p>4.一个功能如果抛出了多个异常，那么调用时必须有对应多个catch进行针对性的处理。内部有几个需要检测的异常，就抛出几个，就catch几个。</p>
<h2 id="9-面向对象-异常-finally代码块"><a href="#9-面向对象-异常-finally代码块" class="headerlink" title="9 面向对象-异常-finally代码块"></a>9 面向对象-异常-finally代码块</h2><p>finally通常用于关闭（释放）资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//一定会被执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try catch finally 代码块组合特点：</p>
<p>1.try catch finally</p>
<p>2.try catch(多个)d当没有必要资源需要释放时，可以不用定义finally</p>
<p>3.try finally//异常无法直接catch处理，但是资源需要关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		开启资源</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		关闭资源</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//这时没有catch就没有处理，就需要声明即throws。</span></span><br></pre></td></tr></table></figure>

<h2 id="10-面向对象-异常-异常注意事项"><a href="#10-面向对象-异常-异常注意事项" class="headerlink" title="10 面向对象-异常-异常注意事项"></a>10 面向对象-异常-异常注意事项</h2><p>异常的注意事项：</p>
<p>1.子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的子类或者不抛。</p>
<p>2.如果父类抛出多个异常，那么子类只能抛出父类异常的子集。即父类有ABCD 四个异常，子类只能抛出其中3个及其以下的异常</p>
<p>简单说子类覆盖父类，只能抛出父类的异常或者子类或者子集。</p>
<p><strong>注意</strong>：如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，就只能try。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象多态内部类</title>
    <url>/2020/03/21/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="面向对象-多态-amp-内部类"><a href="#面向对象-多态-amp-内部类" class="headerlink" title="面向对象-多态&amp;内部类"></a>面向对象-多态&amp;内部类</h1><h2 id="1-面向对象-多态-概述、好处"><a href="#1-面向对象-多态-概述、好处" class="headerlink" title="1 面向对象-多态-概述、好处"></a>1 面向对象-多态-概述、好处</h2><p>定义：某一类型事物的多种存在形态</p>
<p>对象的多态性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 猫 <span class="keyword">extends</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 狗 <span class="keyword">extends</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoTaiDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        猫 x=<span class="keyword">new</span> 猫();</span><br><span class="line">		动物 x=<span class="keyword">new</span> 猫();<span class="comment">//一个对象两种形态。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猫这类事物即具备着猫的形态，又具备着动物的形态</p>
<p>这就是对象的多态性。</p>
<p>简单说<strong>就是一个对象对应着不同类型。</strong></p>
<p>多态在代码中的体现：父类或者接口的引用指向其子类的对象。</p>
<p>多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容</p>
<h2 id="2-面向对象-多态-弊端-amp-前提"><a href="#2-面向对象-多态-弊端-amp-前提" class="headerlink" title="2 面向对象-多态-弊端&amp;前提"></a>2 面向对象-多态-弊端&amp;前提</h2><p>多态的弊端：前期定义的内容不能使用（调用）后期子类的特有内容。</p>
<p>动物 x = new 猫();这个对象x不能调用猫类中的特有内容。但方法若能调用，则都是猫类中复写的方法。</p>
<p>多态的前提</p>
<p>1.必须有关系，继承，实现</p>
<p>2.要有覆盖</p>
<h2 id="3-面向对象-多态-转型"><a href="#3-面向对象-多态-转型" class="headerlink" title="3 面向对象-多态-转型"></a>3 面向对象-多态-转型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal x=<span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>

<p>自动类型提升，猫对象提升了为动物类型。但是特有功能无法访问。</p>
<p>作用就是提高扩展性和限制对特有功能的访问。</p>
<p>专业讲：向上转型。将子类型隐藏，就不能使用子类的特有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c = (Cat)x;</span><br></pre></td></tr></table></figure>

<p>如果还想用具体动物猫的特有功能，你可以将该对象进行向下转型</p>
<p>写法与强制转型相同</p>
<p>向下转型的目的是为了使用子类中的特有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a1 = <span class="keyword">new</span> Dog();</span><br><span class="line">Cat c1 = (Cat)a1;</span><br></pre></td></tr></table></figure>

<p>这样会转型失败。</p>
<p><strong>注意</strong>：对于转型，自始至终都是子类对象在做着类型的变化。而cat和dog没有继承关系</p>
<h2 id="4-面向对象-多态-类型判断-instanceof"><a href="#4-面向对象-多态-类型判断-instanceof" class="headerlink" title="4 面向对象-多态-类型判断-instanceof"></a>4 面向对象-多态-类型判断-instanceof</h2><p>instanceof 用于判断对象的具体类型。只能用于引用数据类型判断。</p>
<p>通常在向下转型前用于健壮性的判断</p>
<h2 id="5-面向对象-多态-成员变量"><a href="#5-面向对象-多态-成员变量" class="headerlink" title="5 面向对象-多态-成员变量"></a>5 面向对象-多态-成员变量</h2><p>1.成员变量</p>
<p>​    编译时：参考的是引用型变量所属的类中是否有调用的成员变量，有，编译通过，没有，编译失败</p>
<p>​    运行时：参考的是引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量</p>
<p>​    简单说：编译和运行都参考等号左边的类中是否存在需要的成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoTaiDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">		System.out.print(f.num);<span class="comment">//此时会编译失败，因为Fu类中不存在num这个成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-面向对象-多态-成员函数（非静态）"><a href="#6-面向对象-多态-成员函数（非静态）" class="headerlink" title="6 面向对象-多态-成员函数（非静态）"></a>6 面向对象-多态-成员函数（非静态）</h2><p>图解：</p>
<p>主函数进栈，然后Fu类加载，接着Zi类加载。堆中创建Zi对象，先生成地址，没有变量，无需初始化，将地址赋给f。调用show()方法，show进栈，f的地址指向Zi对象，先在Zi类中寻找show方法，若Zi类中没有，则在Fu类中寻找。</p>
<p>编译时：参考的是引用型变量所属的类中是否有调用的成员函数，有，编译通过，没有，编译失败</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：编译看左边，运行看右边。</p>
<h2 id="7-面向对象-多态-静态函数"><a href="#7-面向对象-多态-静态函数" class="headerlink" title="7 面向对象-多态-静态函数"></a>7 面向对象-多态-静态函数</h2><p>与上述不同，加载时，两个类中的静态show在静态区，调用直接和类绑定，与对象无关。所以f.show（）；，一看f是属于Fu类吗，就直接调用Fu的show。</p>
<p>编译时：参考的是引用型变量所属的类中是否有调用的静态方法，有，编译通过，没有，编译失败</p>
<p>运行时：参考的是引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：编译和运行都参考左边</p>
<p>其实对于静态方法，是不需要对象的，直接用类名调用即可。</p>
<h2 id="8-面向对象-内部类-概述"><a href="#8-面向对象-内部类-概述" class="headerlink" title="8 面向对象-内部类-概述"></a>8 面向对象-内部类-概述</h2><p>将一个类定义在另一个类的里面，对里面那个类就称为内部类（内置类、嵌套类）。</p>
<p>内部类生成文件的名字为：外部类$内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.内部类可以直接访问外部类中的成员</p>
<p>2.外部类要访问内部类，必须建立内部类的对象</p>
<p>一般用于类的设计</p>
<p>分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述事物的内容</p>
<p>这时就是还有的事物定义成内部类来描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">		System.out.print(<span class="string">"aaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="9-面向对象-内部类-修饰符"><a href="#9-面向对象-内部类-修饰符" class="headerlink" title="9 面向对象-内部类-修饰符"></a>9 面向对象-内部类-修饰符</h2><p>直接访问外部类中的内部类的成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br><span class="line">in.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，相当于一个外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in =<span class="keyword">new</span> Outer.Inner();</span><br><span class="line">in.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，成员是静态的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = Outer.Inner.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类中定义了静态成员，该内部类也必须是静态。</p>
<h2 id="10-面向对象-内部类-细节"><a href="#10-面向对象-内部类-细节" class="headerlink" title="10 面向对象-内部类-细节"></a>10 面向对象-内部类-细节</h2><p>为什么内部类能直接访问外部类中成员呢？</p>
<p>那是因为内部类持有了外部类的引用。外部类名.this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">            System.out.print(<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果是<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="11-面向对象-内部类-局部内部类"><a href="#11-面向对象-内部类-局部内部类" class="headerlink" title="11 面向对象-内部类-局部内部类"></a>11 面向对象-内部类-局部内部类</h2><p>内部类可以存放在局部位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            	System.out.print(num);</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">答案：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p>内部类在局部位置上只能访问局部中被final修饰的局部变量。</p>
<h2 id="12-面向对象-匿名内部类-概述"><a href="#12-面向对象-匿名内部类-概述" class="headerlink" title="12 面向对象-匿名内部类-概述"></a>12 面向对象-匿名内部类-概述</h2><p>匿名内部类，就是内部类的简写格式</p>
<p><strong>必须有前提</strong></p>
<p>内部类必须继承或者实现一个外部类或者接口</p>
<p>匿名内部类：其实就是一个匿名子类对象。</p>
<p>格式：new 父类or接口名(){子类内容}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Demo()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function">abtract <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="13-面向对象-匿名内部类-应用、细节"><a href="#13-面向对象-匿名内部类-应用、细节" class="headerlink" title="13  面向对象-匿名内部类-应用、细节"></a>13  面向对象-匿名内部类-应用、细节</h2><p>通常使用场景之一：</p>
<p>当函数参数是接口类型时，而且接口中的方法不超过三个</p>
<p>可以用匿名内部类作为实际参数进行传递</p>
<p>细节：1.匿名内部类这个子类对象被向上转型了为Object类型，这样就不能再使用子类的特有方法了。</p>
<p>​            2.在静态方法中不能创建匿名内部类。</p>
<h2 id="14-面向对象-对象的初始化过程（总结）"><a href="#14-面向对象-对象的初始化过程（总结）" class="headerlink" title="14 面向对象-对象的初始化过程（总结）"></a>14 面向对象-对象的初始化过程（总结）</h2><p>1.首先产生对象，堆中开辟内存，默认初始化变量。</p>
<p>2.然后先进Zi类的构造函数，根据super();进入Fu类的构造函数，执行语句</p>
<p>3.调用其中的show函数，这个show函数为Zi类中的show函数，因为被覆盖了。</p>
<p>4.开始显示初始化</p>
<p>5.开始构造代码块初始化</p>
<p>6.构造函数具体初始化</p>
<p>7.调用show函数</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象抽象类接口</title>
    <url>/2020/03/21/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="面向对象-抽象类-amp-接口"><a href="#面向对象-抽象类-amp-接口" class="headerlink" title="面向对象-抽象类&amp;接口"></a>面向对象-抽象类&amp;接口</h1><h2 id="1-抽象类概述-amp-特点"><a href="#1-抽象类概述-amp-特点" class="headerlink" title="1 抽象类概述&amp;特点"></a>1 抽象类概述&amp;特点</h2><p>抽象：笼统、模糊</p>
<p>当一个类描述一个事物时，没有足够的信息描述时，就叫抽象类。</p>
<p>比如狗和狼都会吼叫，他们提取出来都是犬科，犬科也有吼叫，但是吼叫内容不一样，所以就是有着相同的函数声明，但内容不同，这样就出现了抽象的概念。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> 吼叫();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 狗 <span class="keyword">extends</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 吼叫()&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 狼 <span class="keyword">extends</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 吼叫()&#123;</span><br><span class="line">        System.out.println(<span class="string">"嗷嗷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>特点：</p>
<p>1.方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰</p>
<p>​    抽象方法必须定义在抽象类中，该类必须也被关键字修饰</p>
<p>2.抽象类不可以被实例化，即不能被new创建对象。因为调用抽象方法没有意义。</p>
<p>3.抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化</p>
<p>​    否则这个子类还是抽象类。</p>
<h2 id="2-面向对象-抽象类-细节"><a href="#2-面向对象-抽象类-细节" class="headerlink" title="2 面向对象-抽象类-细节"></a>2 面向对象-抽象类-细节</h2><p>1)抽象类中有构造函数吗？</p>
<p>有，用于给子类对象进行初始化</p>
<p>2)抽象类可以不定义抽象方法吗？</p>
<p>可以的。但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类</p>
<p>通常这个类中的方法有方法体，但是没有内容</p>
<p>3)抽象关键字不可以和哪些关键字共存？</p>
<p>private 抽象方法需要被覆盖，私有了子类就无法访问就无法覆盖。</p>
<p>static 成员变静态，不需要对象，抽象方法没有方法体，运行没有意义，</p>
<p>final 抽象需要覆盖，而final不让覆盖</p>
<p>4)抽象类和一般类的异同点</p>
<p>相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员</p>
<p>不同点：</p>
<p>1.一般类有足够的信息描述事物，抽象类描述事物的信息有可能不足。</p>
<p>2.一般类中不能定义抽象方法，只能定义非抽象方法，而抽象类中可以定义抽象方法金和非抽象方法。</p>
<p>3.一般类可以被实例化，抽象类不可被实例化</p>
<p>5)抽象类一定是个父类吗？</p>
<p>是的，因为需要子类覆盖其方法后才可以对子类实例化。</p>
<h2 id="3-面向对象-接口-定义interface、实现implements"><a href="#3-面向对象-接口-定义interface、实现implements" class="headerlink" title="3 面向对象-接口-定义interface、实现implements"></a>3 面向对象-接口-定义interface、实现implements</h2><p>当一种抽象类中的<strong>方法都是抽象</strong>的时候，这是可以将该抽象类用另一种形式定义和表示，就是接口，interface</p>
<p>定义接口使用的关键字不是class，是interface,但编译出来的文件后缀名仍是class。</p>
<p>对于接口当中常见的成员，而且这些成员都有固定的修饰符</p>
<p>1.全局常量：public static final</p>
<p>2.抽象方法；public abstract</p>
<p>由此得出结论：<strong>接口中的成员都是公共的权限即权限都是最大的</strong>。</p>
<p>因为接口中的成员修饰符是固定的，所以可以省略前面的修饰符，编译器会自动加上。例如abstract因为接口中的方法必是抽象方法，所有可以省略abstract。</p>
<p>虽说如此，但修饰符还是要带上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">4</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<p><strong>类与类之间是继承关系，类与接口之间是实现关系</strong></p>
<p>接口<strong>不可以实例化</strong></p>
<p>只能由实现了接口的子类并<strong>覆盖了接口中所有的抽象方法</strong>后，该子类才可以实例化</p>
<p>否则这个子类就是一个抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoImp1</span> <span class="keyword">implements</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DemoImp1 d = <span class="keyword">new</span> DemoImp1();</span><br><span class="line">        System.out.println(d.NUM);</span><br><span class="line">        System.out.println(Demo.NUM);</span><br><span class="line">        System.out.println(DemoImp1.NUM);<span class="comment">//这三种调用皆可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-接口-多实现"><a href="#4-面向对象-接口-多实现" class="headerlink" title="4 面向对象-接口-多实现"></a>4 面向对象-接口-多实现</h2><p>在java中不直接支持多继承，因为会出现调用的不确定性</p>
<p>所以java将多继承机制进行改良，在java中变成了多实现</p>
<p>一个类可以实现多接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-面向对象-接口-细节"><a href="#5-面向对象-接口-细节" class="headerlink" title="5 面向对象-接口-细节"></a>5 面向对象-接口-细节</h2><p>一个类继承另一个类的同时，还可以实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Q</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口与接口之间是继承关系，而且接口可以多继承，原理在于是否存在方法体，是否存在不确定性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ZZ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">QQ</span> <span class="keyword">extends</span> <span class="title">AA</span>, <span class="title">ZZ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">QQ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-面向对象-接口-特点"><a href="#6-面向对象-接口-特点" class="headerlink" title="6 面向对象-接口-特点"></a>6 面向对象-接口-特点</h2><p>接口是对外暴露的规则</p>
<p>接口是程序的功能扩展</p>
<p>接口的出现降低耦合性</p>
<p>接口可以用来多实现</p>
<p>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</p>
<p>接口与接口之间可以有继承关系</p>
<h2 id="7-面向对象-接口-接口和抽象类的区别"><a href="#7-面向对象-接口-接口和抽象类的区别" class="headerlink" title="7 面向对象-接口-接口和抽象类的区别"></a>7 面向对象-接口-接口和抽象类的区别</h2><p>抽象类和接口的异同点</p>
<p>相同点：</p>
<p>都是不断向上抽取而来的</p>
<p>不同点：</p>
<p>1.抽象类需要被继承，而且只能单继承</p>
<p>   接口需要被实现，而且可以多实现</p>
<p>2.抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法</p>
<p>   接口中只能定义抽象方法，必须有子类去实现</p>
<p>3.抽象类的继承是is a 关系，所属关系，在定义该体系的基本共性内容</p>
<p>   接口的实现时like a关系，像关系，在定义体系额外功能</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象4</title>
    <url>/2020/03/20/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14/</url>
    <content><![CDATA[<h1 id="面向对象4"><a href="#面向对象4" class="headerlink" title="面向对象4"></a>面向对象4</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h2 id="1-面向对象-继承-概述"><a href="#1-面向对象-继承-概述" class="headerlink" title="1 面向对象-继承-概述"></a>1 面向对象-继承-概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span>/*继承*/ <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">"..."</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        s.name = <span class="string">"aaa"</span>;</span><br><span class="line">        s.age = <span class="number">22</span>;</span><br><span class="line">        s.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：aaa…22</p>
<a id="more"></a>

<p>上述代码中，Person是Student的父类，Student继承了Person中的name和age。</p>
<p>继承的好处</p>
<p>1.提高代码的复用性</p>
<p>2.让类与类之间产生了关系，给第三个特征多态提供了前提。</p>
<h2 id="2-面向对象-继承-单继承与多重继承"><a href="#2-面向对象-继承-单继承与多重继承" class="headerlink" title="2 面向对象-继承-单继承与多重继承"></a>2 面向对象-继承-单继承与多重继承</h2><p>java中支持单继承，不直接支持多继承，但对c++中的多继承机制进行改良</p>
<p>单继承：一个子类只能有一个直接父类</p>
<p>多继承：一个子类可以有多个直接父类（java中不允许，进行改良）。</p>
<p>​               不直接支持，是因为若父类中有相同的成员，会产生调用的不确定性。</p>
<p>​               在java中是通过“多实现”的方式来体现。</p>
<p>java支持多层（多重）继承</p>
<p>即C继承B，B继承A。</p>
<p>就会出现继承体系</p>
<p>当要使用继承体系时</p>
<p>1.查看该体系中的顶层类，了解该体系的基本功能</p>
<p>2.创建体系中的最子类对象，完成功能的使用</p>
<h2 id="3-面向对象-继承-定义继承"><a href="#3-面向对象-继承-定义继承" class="headerlink" title="3 面向对象-继承-定义继承"></a>3 面向对象-继承-定义继承</h2><p>什么时候定义继承</p>
<p>当类与类之间存在着所属关系的时候，就定义继承。</p>
<p>如xxx是yyy中的一种，则xxx extends yyy。</p>
<p>若A类有a方法和b方法，B类有a方法和c方法，即使B类有a方法，但是A类中没有c方法，所有这两个类不能构成继承关系。</p>
<h2 id="4-面向对象-继承-子父类中成员变量的特点"><a href="#4-面向对象-继承-子父类中成员变量的特点" class="headerlink" title="4 面向对象-继承-子父类中成员变量的特点"></a>4 面向对象-继承-子父类中成员变量的特点</h2><p>当本类的成员和局部变量同名用this区分</p>
<p>当子父类中的成员变量同名用<strong>super</strong>区分父类</p>
<p>this和super的用法很相似。</p>
<p>this代表一个本类对象的引用</p>
<p>super代表一个父类空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.num + <span class="string">"..."</span> + <span class="keyword">super</span>.num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若调用show()，结果为4…5。</p>
<h2 id="5-面向对象-继承-子父类中成员变量的内存图解"><a href="#5-面向对象-继承-子父类中成员变量的内存图解" class="headerlink" title="5 面向对象-继承-子父类中成员变量的内存图解"></a>5 面向对象-继承-子父类中成员变量的内存图解</h2><p>主函数先进栈，然后先在方法区加载一个父类空间，其次加载子类空间。之后在堆内存中开辟空间，产生地址，创建对象，<strong>然后在该堆空间中，分别开辟空间存储子类和父类变量</strong>，然后进行初始化。然后将地址给z。然后进行show方法，进栈，将地址赋给this指向堆内存。父类成员变量已经随着子类建立已经存储在子类空间当中。打印super.num时，就直接找到那个空间的父类成员变量。</p>
<p>一般开发时，同名这种情况不多见，面试的时候比较常见。</p>
<p><strong>子类不能直接访问父类当中的私有内容</strong></p>
<h2 id="6-面向对象-继承-子父类中成员函数的特点-覆盖"><a href="#6-面向对象-继承-子父类中成员函数的特点-覆盖" class="headerlink" title="6 面向对象-继承-子父类中成员函数的特点-覆盖"></a>6 面向对象-继承-子父类中成员函数的特点-覆盖</h2><p>当子父类中出现成员函数一模一样的情况，会运行子类的函数</p>
<p>这种现象，称为<strong>覆盖操作</strong>，这是函数在子父类中的特性。</p>
<p>函数两个特性（只有函数有）：</p>
<p>1.重载，同一个类中</p>
<p>2.覆盖，子类中，覆盖也称为重写，覆写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"fu run"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"zi run"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：Zi show run。</p>
<p><strong>覆盖注意事项</strong>：</p>
<p>1.子类方法覆盖父类方法时，子类权限必须大于等于父类的权限，才可以引发覆盖。</p>
<p> 如果父类是权限为private，则就不称之为覆盖，因为父类就不能访问，故称不上覆盖。</p>
<p>2.静态只能覆盖静态，或被静态覆盖。</p>
<h2 id="7-面向对象-继承-子父类中成员函数的特点-覆盖的使用场景"><a href="#7-面向对象-继承-子父类中成员函数的特点-覆盖的使用场景" class="headerlink" title="7 面向对象-继承-子父类中成员函数的特点-覆盖的使用场景"></a>7 面向对象-继承-子父类中成员函数的特点-覆盖的使用场景</h2><p>什么时候使用覆盖操作</p>
<p>当对一个类进行子类的扩展时，子类需要保留父类的功能声明，</p>
<p>但是要定义子类中该功能的特有内容时，就使用覆盖操作完成。</p>
<h2 id="8-面向对象-继承-子父类中的构造函数-子类的实例化过程、细节"><a href="#8-面向对象-继承-子父类中的构造函数-子类的实例化过程、细节" class="headerlink" title="8 面向对象-继承-子父类中的构造函数-子类的实例化过程、细节"></a>8 面向对象-继承-子父类中的构造函数-子类的实例化过程、细节</h2><p>在子类构造对象时，发现访问子类构造函数时，父类也运行了。</p>
<p>原因是：在子类的构造函数中第一行有一个默认的隐式语句。super(){ };这会让父类中构造函数也运行。</p>
<p>super();//调用的就是父类中的空参数的构造函数。如果父类没有空参，则会编译失败，若父类是带参的，即Fu(int x)，那么就写成super(4);类型即可。</p>
<p>子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数。</p>
<p>为什么子类实例化的时候要访问父类中的构造函数？</p>
<p>因为子类继承了父类，获取到了父类中内容（属性），所以在使用父类内容之前，</p>
<p>要先看父类是如何对自己的内容进行初始化的。</p>
<p>所以子类在构造对象时，必须访问父类中的构造函数</p>
<p>为了完成这个必须的动作，就在子类的构造函数中加入了super()；语句。</p>
<p>如果父类没有定义空参数构造函数，那么子类的构造函数必须用super明确调用父类中的一个构造函数。</p>
<p><strong>注意</strong>：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成。</p>
<p>同时子类构造函数中如果使用this调用了本类构造函数时，super就没有了，因为super和this都只能定义在第一行，所以只能有一个。</p>
<p>但是可以保证的是，若使用的子类的构造函数中有this，那么创建对象时会使用子类中其他的构造函数访问父类的构造函数。</p>
<p>Java中有若干对象，他们有个最顶层的类，是Object，创建的任何对象都是Object的子类。class Demo extends Object，一般extends Object不写。</p>
<h2 id="9-面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解"><a href="#9-面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解" class="headerlink" title="9 面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解"></a>9 面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    Fu()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fu show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">8</span>;</span><br><span class="line">    Zi()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"zi show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：zi show…0<br>               zi show…8</p>
<p>先主函数进栈，出现z，要创建对象，加载Zi类，但是Zi类有继承Fu类，所以先加载Fu类，Fu就进内存中的方法区，然后加载Zi类。之后在堆中创建new Zi对象，赋予地址，对变量进行默认初始化，num=0。默认初始化结束后，Zi的构造函数进栈，里面有个super函数，Fu类构造函数进栈，然后运行show()函数，这里注意，这里的函数全写为this.show();所以先从this所指的对象中开始找show();发现在new Zi中有show()函数，所以就调用子类的show()函数。此时Fu类的构造结束，弹栈。然后才将8赋给num值，即显示初始化。之后Zi类构造函数弹栈。然后地址赋给z。</p>
<p><strong>总结</strong></p>
<p>一个对象实例化过程</p>
<p>Person p=new Person();</p>
<p>1.JVM会读取指定的路径下的Person.class 文件，并加载进内存</p>
<p>​    并会先加载Person的父类（如果有直接父类的情况下）</p>
<p>2.在堆内存中开辟空间，分配地址</p>
<p>3.并在对象空间中，对对象中的属性进行默认初始化</p>
<p>4.调用对应的构造函数进行初始化</p>
<p>5.在构造函数中，第一行会先到调用父类中构造函数中进行初始化</p>
<p><strong>6.父类初始化完毕后，再对子类的属性进行显示初始化。//这一块是分水岭。</strong></p>
<p>7.再进行自类构造函数的特定初始化</p>
<p>8.初始化完毕后，将地址值赋给引用变量。</p>
<h2 id="10-面向对象-final关键字"><a href="#10-面向对象-final关键字" class="headerlink" title="10 面向对象-final关键字"></a>10 面向对象-final关键字</h2><p>1.Final可以修饰类，方法，变量</p>
<p>2.Final修饰的类不可以被继承</p>
<p>3.Final修饰的方法不可以被覆盖</p>
<p>4.Final修饰的变量是一个常量。只能被赋值一次</p>
<p>为什么要用final修饰变量</p>
<p>其实在程序中，如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差</p>
<p>所以它该数据起个名称，而且这个变量名称的值不能变化，所以加上final固定。</p>
<p>写法规范：常见所有字母都大写，多个单词中间用下划线“_”连接，MY_NUM。</p>
<p>Final固定的是显示初始化值，不是默认初始化值。</p>
<p>public static为全局的意思</p>
<p>public static final double PI=3.14 全局常量。</p>
<p>5.内部类只能访问被final修饰的局部变量</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象3</title>
    <url>/2020/03/20/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13/</url>
    <content><![CDATA[<h1 id="面向对象3"><a href="#面向对象3" class="headerlink" title="面向对象3"></a>面向对象3</h1><h2 id="1-数组对象建立、数组工具类中静态的使用"><a href="#1-数组对象建立、数组工具类中静态的使用" class="headerlink" title="1 数组对象建立、数组工具类中静态的使用"></a>1 数组对象建立、数组工具类中静态的使用</h2><p>可以建立一个数组对象，将对数组的操作方法定义在类中。用到了面向对象的方法。</p>
<h2 id="2-文档注释"><a href="#2-文档注释" class="headerlink" title="2 文档注释"></a>2 文档注释</h2><p>Javadoc.exe可以提取文档注释，只能解析/** */的内容</p>
<p>提取操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -d. -author -version xxx.java</span><br></pre></td></tr></table></figure>

<p>-d指输出文件的目标目录， . 指在当前目录下， -***，指需要提取的目录。</p>
<p>要将文档用该程序提取注释，则需要将类公有化，否则无法执行</p>
<h2 id="3-面向对象-单例设计-概念-amp-体现"><a href="#3-面向对象-单例设计-概念-amp-体现" class="headerlink" title="3  面向对象-单例设计-概念&amp;体现"></a>3  面向对象-单例设计-概念&amp;体现</h2><p>设计模式：对问题行之有效的解决方式，其实它是一种思想。</p>
<p>1.单例设计模式</p>
<p>解决的问题：可以保证一个类在内存中的对象唯一性。</p>
 <a id="more"></a>

<p>比如对于多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性。</p>
<p>如何保证对象的唯一性：</p>
<p>1.不允许其他程序用new创建该类对象。这样可以避免产生更多对象</p>
<p>2.在该类中创建一个本类实例。</p>
<p>3.对外提供方法让其他程序可以获取该对象。</p>
<p>步骤：</p>
<p>1.私有化该类的构造函数</p>
<p>2.通过new在本类中创建一个本类并私有的对象</p>
<p>3.定义一个公有的方法将创建的对象返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//设置这个函数是为了可控因为可以在里面设置条件</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span>()</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Sinlge ss = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-单例设计-内存图解"><a href="#4-面向对象-单例设计-内存图解" class="headerlink" title="4 面向对象-单例设计-内存图解"></a>4 面向对象-单例设计-内存图解</h2><p>略</p>
<h2 id="5-面向对象-单例设计-饿汉式和懒汉式"><a href="#5-面向对象-单例设计-饿汉式和懒汉式" class="headerlink" title="5 面向对象-单例设计-饿汉式和懒汉式"></a>5 面向对象-单例设计-饿汉式和懒汉式</h2><p>饿汉式：类一加载，对象就已经存在，即上述3中的代码就是饿汉式</p>
<p>懒汉式：类加载进来，没有对象，只有调用了getInstance()方法时，才会创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) s = <span class="keyword">new</span> Single();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正式开发中饿汉式用的多，因为懒汉式后期被另外一种技术比如多线程技术操作时，可能会保证不了唯一性。</p>
<p><strong>面试几乎涉及懒汉式</strong>，里面涉及的知识点比较多。</p>
<p><strong>单例模式作为重点掌握</strong></p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象2</title>
    <url>/2020/03/19/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/</url>
    <content><![CDATA[<h1 id="面向对象2"><a href="#面向对象2" class="headerlink" title="面向对象2"></a>面向对象2</h1><h2 id="1-面向对象-构造函数-概述、默认构造函数"><a href="#1-面向对象-构造函数-概述、默认构造函数" class="headerlink" title="1 面向对象-构造函数-概述、默认构造函数"></a>1 面向对象-构造函数-概述、默认构造函数</h2><p>构造函数：构建创造对象时调用的函数。</p>
<p>作用：可以给对象进行初始化。</p>
<p>特点：</p>
<p>1.函数名与类名相同。</p>
<p>2.不用定义返回值。</p>
<p>3.没有具体的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	Person()&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象都必须要通过构造函数初始化。</p>
<a id="more"></a>

<p><strong>默认构造函数</strong></p>
<p>一个类中如果没有定义过构造函数，那么该类中会有一个默认的空参数构造函数。</p>
<p>如果在类中定义了指定的构造函数，那么类中的默认构造函数就没有了。</p>
<h2 id="2-面向对象-构造函数-构造函数和一般函数的区别"><a href="#2-面向对象-构造函数-构造函数和一般函数的区别" class="headerlink" title="2 面向对象-构造函数-构造函数和一般函数的区别"></a>2 面向对象-构造函数-构造函数和一般函数的区别</h2><p>一般函数和构造函数的区别</p>
<p>构造函数：对象创建时，就会调用与之对应的构造函数，对对象进行初始化</p>
<p>一般函数：对象创建后，需要函数功能时才调用。</p>
<p>构造函数：对象创建时，会调用只调用一次</p>
<p>一般函数：对象创建后，可以被调用多次。</p>
<h2 id="3-面向对象-构造函数-重载"><a href="#3-面向对象-构造函数-重载" class="headerlink" title="3 面向对象-构造函数-重载"></a>3 面向对象-构造函数-重载</h2><p>构造函数重载与一般函数重载相同：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。</p>
<p><strong>注意</strong>：小括号中，参数个数和参数类型相同，但顺序不同也可以重载，因为java是强类型语言，是十分严谨的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    Person(<span class="keyword">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">     Person(String n,<span class="keyword">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">        name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-构造函数-内存图解"><a href="#4-面向对象-构造函数-内存图解" class="headerlink" title="4 面向对象-构造函数-内存图解"></a>4 面向对象-构造函数-内存图解</h2><p>与之前不一样的是，中间多了一步构造函数初始化。图解略</p>
<h2 id="5-面向对象-构造函数-细节"><a href="#5-面向对象-构造函数-细节" class="headerlink" title="5 面向对象-构造函数-细节"></a>5 面向对象-构造函数-细节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.上述二者函数功能一样，但用法不同，所以第二种需要存在。</p>
<p>2.一般函数中不能调用构造函数，构造函数可以调用一般函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.上述这是可以的，虽然构造函数前面不能加返回值，但这图中，它不当作构造函数，当作是一般函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.上述定义类的情况下， 在主函数中用下列语句创建对象</p>
<p>Person p = new Person();</p>
<p>编译是不行的。因为这种情况下，没有默认构造函数即空参构造函数，第二个Person函数是构造函数，故就没有默认构造函数，编译不成功。</p>
<p>5.构造函数中是可以有return的，但不多见。</p>
<h2 id="6-面向对象-this关键字-使用场景-amp-this原理"><a href="#6-面向对象-this关键字-使用场景-amp-this原理" class="headerlink" title="6 面向对象-this关键字-使用场景&amp;this原理"></a>6 面向对象-this关键字-使用场景&amp;this原理</h2><p>场景1：当成员变量和局部变量重名，可以用this关键字区分。</p>
<p>this ：代表对象，代表当前对象</p>
<p>​       this就是所在函数所属对象的引用。</p>
<p>​       <strong>简单说，哪个对象调用了this所在的函数，this就代表哪个对象，即拿到那个对象的地址。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(String n, <span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">		<span class="keyword">this</span>.age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入this关键字后，之前的内存图解重新解释：运行主函数，在栈里面划出内存给主函数，构建一个p对象，堆中也出现一块内存给这个对象，然后给这个空间赋予地址，内存存入两个变量，并对其进行默认初始化。然后调用构造函数，因此在栈中又划出内存给构造函数，然后出现this关键字，将堆中的内存地址与this绑定，这样就知道之后的变量赋值是赋给哪个内存的对应变量。然后将旺财赋给对应内存当中的name，赋值结束弹栈，地址赋给p。运行下一个指令，p.speak()。在栈内存中给出一块内存给speak函数，同样的在此中将调用的对象的相应地址与speak中的this绑定，输出语句，之后弹栈。</p>
<p><strong>这里注意</strong>：其实之前的写这些时都把this省去了，因为成员变量和局部变量没有重复。其实真正的写法是this.name，this.age。</p>
<p>场景2：一个类当中，所有的成员想要运行，就必须有对象调用。</p>
<p>想在构造函数中调用构造函数，也可以使用this，用this代替构造函数名，形式：this(…,…,…) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(String n)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(String n, <span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">this</span>(n);</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：凡是调用构造函数，this只能定义在构造函数的第一行，因为初始化动作要先执行。</p>
<h2 id="7-面向对象-this关键字-应用"><a href="#7-面向对象-this关键字-应用" class="headerlink" title="7 面向对象-this关键字-应用"></a>7 面向对象-this关键字-应用</h2><p>判断是否为同龄人</p>
<p>思路：对象是人，所以函数的参量是人。参量的个数可以是2，但是可以认为比较这个功能可以是人本身具备的，可以理解为一个人用这个功能来与另外一个人进行年龄的比较，只要调用即可，故这个函数的参量个数是一个。在函数里面，p1调用了这个函数，故this就代表着p1，p代表着p2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(<span class="keyword">int</span> a)</span><br><span class="line">        <span class="keyword">this</span>.age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == p.age; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-面向对象-static关键字-数据共享、特点"><a href="#8-面向对象-static关键字-数据共享、特点" class="headerlink" title="8 面向对象-static关键字-数据共享、特点"></a>8 面向对象-static关键字-数据共享、特点</h2><p>static特点</p>
<p>1.static是一个修饰符，用于修饰成员</p>
<p>2.static修饰的成员被所有的对象共享</p>
<p>3.static优先于对象存在。因为static的成员随着类的加载就已经存在了</p>
<p>4.static修饰的成员多了一种调用方式，即可以直接被类名所调用。</p>
<p>调用方式：类名.静态成员</p>
<p>5.static修饰的数据是共享数据，对象中的存储的是特有数据</p>
<h2 id="9-面向对象-static关键字-成员变量和静态变量的区别"><a href="#9-面向对象-static关键字-成员变量和静态变量的区别" class="headerlink" title="9 面向对象-static关键字-成员变量和静态变量的区别"></a>9 面向对象-static关键字-成员变量和静态变量的区别</h2><p>成员变量和静态变量的区别</p>
<p>1.两个变量的生命周期不一样。</p>
<p>成员变量随着对象的创建而存在，随着对象的被回收而释放</p>
<p>静态变量随着类的加载而存在，随着类的消失而消失</p>
<p>2.调用方式不同</p>
<p>成员变量只能被对象调用</p>
<p>静态变量可以被对象调用，还可以被类名调用。一般建议用类名调用。</p>
<p>3.别名不同</p>
<p>成员变量也称为实例变量</p>
<p>静态变量也称为类变量</p>
<p>4.数据的存储位置不同</p>
<p>成员变量数据存储在堆内存的对象中，所有也叫对象的特有数据</p>
<p>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据</p>
<h2 id="10-面向对象-static关键字-注意事项"><a href="#10-面向对象-static关键字-注意事项" class="headerlink" title="10  面向对象-static关键字-注意事项"></a>10  面向对象-static关键字-注意事项</h2><p>1.静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）</p>
<p>2.静态方法中不可以使用this或super等关键字</p>
<p>3.主函数是静态的</p>
<h2 id="11-面向对象-static关键字-main函数解析"><a href="#11-面向对象-static关键字-main函数解析" class="headerlink" title="11  面向对象-static关键字-main函数解析"></a>11  面向对象-static关键字-main函数解析</h2><p>public static void main(String[ ] args)</p>
<p>主函数特殊之处：</p>
<p>1.格式是固定的，上述每个单词都不能换成其他的。</p>
<p>2.被JVM所识别和调用</p>
<p>public：因为权限必须是最大的。</p>
<p>static：虚拟机调用主函数的时候不需要对象，直接用主函数所属类名调用即可。</p>
<p>void：主函数没有具体的返回值。</p>
<p>main：函数名，不是关键字只是一个JVM识别的固定的名字</p>
<p>String[ ] args：这是主函数的参数列表，是一个数组类型的参数，而且元素都是字符串类型。</p>
<p>args可以用其他替代</p>
<h2 id="12-面向对象-static关键字-内存图解"><a href="#12-面向对象-static关键字-内存图解" class="headerlink" title="12 面向对象-static关键字-内存图解"></a>12 面向对象-static关键字-内存图解</h2><p>先划分一片空间出来给栈、堆、方法区等。当StaticDemo2被执行时，类进内存，开辟空间。在非静态区存储StaticDemo2(){ }，静态区存储Static main()。非静态区都用this来调用对象。然后在栈空间开辟一个main函数空间。运行第一句话，Peson类开始加载，它就开始找在classpath下找有没有Person.class文件，找到后加载进内存，静态类进去静态区，其他类进去非静态区。然后在内存中寻找method方法，因为是静态，所以到静态区找。找到后在栈中开辟空间给method。然后开始执行method方法，执行结束后，弹栈。执行第二句话，开始创建对象，在堆中开辟空间，然后这句话的执行与前述相同。执行第三句话，show方法进栈，将地址赋值给this，执行语句，country在静态区找，name和age到对象中找，执行结束弹栈。然后主函数弹栈，之后虚拟机也结束。</p>
<h2 id="13-面向对象-static关键字-什么时候用"><a href="#13-面向对象-static关键字-什么时候用" class="headerlink" title="13  面向对象-static关键字-什么时候用"></a>13  面向对象-static关键字-什么时候用</h2><p>1.静态变量</p>
<p>当分析对象中所具备的成员变量的值都是相同的这时这个成员可以被静态修饰</p>
<p>只要数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。</p>
<p>如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。</p>
<p>2.静态函数</p>
<p>函数是否用静态修饰，就参考一点：该函数功能是否需要访问到对象中的特有数据</p>
<p>简单点说，从源代码看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的。如果不需要，就可以将该功能定义成静态的。</p>
<p>当然，也可以定义成非静态，但是非静态需要被对象调用，而仅创建对象调用非静态的，没有访问特有数据的方法，该对象的创建是没有意义的。</p>
<h2 id="14-面向对象-static关键字-静态代码块"><a href="#14-面向对象-static关键字-静态代码块" class="headerlink" title="14 面向对象-static关键字-静态代码块"></a>14 面向对象-static关键字-静态代码块</h2><p>静态代码块</p>
<p> static{</p>
<p>}</p>
<p>随着类的加载而执行，而且只执行一次。</p>
<p>作用：用于给类进行初始化。如果没有对象，那么就可以用这种方法进行初始化。</p>
<p>在静态代码块中可以对静态变量进行运算等操作。</p>
<p>它也先于主函数执行。</p>
<h2 id="15-面向对象-static关键字-构造代码块"><a href="#15-面向对象-static关键字-构造代码块" class="headerlink" title="15 面向对象-static关键字-构造代码块"></a>15 面向对象-static关键字-构造代码块</h2><p>构造代码块</p>
<p>{</p>
<p>}</p>
<p>特点：可以给所有对象进行初始化。每次创建对象的时候都会提前调用一次构造代码块</p>
<p>构造函数</p>
<p>是给对应的对象进行针对性的初始化。</p>
<p>面试：静态代码块、构造代码块、构造函数操作执行顺序</p>
<p>静态代码块先执行，然后构造代码块执行，最后构造函数执行。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象</title>
    <url>/2020/03/18/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-面向对象-概述"><a href="#1-面向对象-概述" class="headerlink" title="1 面向对象-概述"></a>1 面向对象-概述</h2><p>有两个思想，面向过程和面向对象。</p>
<p>面向过程</p>
<p>举例：大象装进冰箱</p>
<p>打开冰箱</p>
<p>存储大象</p>
<p>关闭冰箱</p>
<p>对于面向过程思想，强调的是过程（动作），比如C语言就是面向过程。</p>
 <a id="more"></a>

<p>面向对象</p>
<p>举例：大象装进冰箱</p>
<p>冰箱打开</p>
<p>冰箱存储</p>
<p>冰箱关闭</p>
<p>只要找到冰箱这个实体就能完成后面的动作。</p>
<p>对于面向对象思想，强调的是对象（实体），比如java、C++、C#就是面向对象。</p>
<p>特点：</p>
<p>1.面向对象就是一种常见的思想，符合人们的思考习惯。</p>
<p>2.面向对象的出现，将复杂的问题简单化。</p>
<p>3.面向对象的出现，让曾经在过程中的执行者，变成了对象中的指挥者。</p>
<h2 id="2-面向对象-举例"><a href="#2-面向对象-举例" class="headerlink" title="2 面向对象-举例"></a>2 面向对象-举例</h2><p>Java中万物皆可作为对象。（这是一种境界，面试的时候不要说）</p>
<p>有对象用对象，没对象造对象，不断的去维护各个对象之间的关系。</p>
<p><strong>使用面向对象的三个特征：封装、继承、多态</strong></p>
<p>例子：人开门</p>
<p>对象：人和门，名词提炼法找对象</p>
<p>动作/功能赋予：开这个是门的功能，哪个对象最清楚动作就赋予给哪个对象</p>
<h2 id="3-类与对象的关系"><a href="#3-类与对象的关系" class="headerlink" title="3 类与对象的关系"></a>3 类与对象的关系</h2><p>类</p>
<p>Java通过类的形式来对现实生活中的事物进行描述。</p>
<p>对于事物描述通常只关注两方面：属性，行为。</p>
<p>只要明确该事物的属性和行为并定义在类中即可</p>
<p>对象</p>
<p>其实就是该类事物实实在在的个体。</p>
<p>类与对象之间的关系</p>
<p>类:事物的描述</p>
<p>对象：类的实例。在java中通过new来创建的</p>
<h3 id="4-类与对象的体现"><a href="#4-类与对象的体现" class="headerlink" title="4 类与对象的体现"></a>4 类与对象的体现</h3><p>描述小汽车</p>
<p>分析：</p>
<p>1.属性</p>
<p>轮胎数</p>
<p>颜色</p>
<p>2.行为</p>
<p>运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Car c = <span class="keyword">new</span> Car();</span><br><span class="line">		c.num = <span class="number">4</span>;</span><br><span class="line">		c.color = <span class="string">"red"</span>;</span><br><span class="line">		c.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义类其实就是在定义类中的成员</p>
<p>成员:成员变量、成员函数。前者对应变量，后者对应行为。</p>
<p>成员变量定义在类中，其作用范围是最大的。</p>
<p>Car类中没有定义主函数，它专门用来描述某一事物，不需要独立运行</p>
<p>如果被用到才需要独立运行。当然，也可以让其独立运行，在类中定义主函数即可。</p>
<p>要使用对象中的内容，可以通过 <strong>对象.成员</strong> 的形式完成调用。</p>
<h2 id="5-面向对象-对象的内存体现"><a href="#5-面向对象-对象的内存体现" class="headerlink" title="5 面向对象-对象的内存体现"></a><strong>5 面向对象-对象的内存体现</strong></h2><p>在主函数中创建car对象内存过程:<br>因为定义的c是局部变量，所以c在栈中会占用内存。然后定义的是对象，故打开堆内存，占用内存并赋予一个地址，在里面定义变量，同时进行默认初始化。接下来给变量赋予数值。找到c，然后根据地址找到堆内存中位置，并赋予数值。<br>一个对象封装着其所对应的数据，比如num、color。</p>
<h2 id="6-面向对象-成员变量和局部变量的区别"><a href="#6-面向对象-成员变量和局部变量的区别" class="headerlink" title="6 面向对象-成员变量和局部变量的区别"></a>6 面向对象-成员变量和局部变量的区别</h2><p>成员变量和局部变量的区别</p>
<p>1.成员变量定义在类中，整个类中都可以访问。</p>
<p>   局部变量定义在函数、语句、局部代码块中，只在所属的区域有效。</p>
<p>2.成员变量存在于堆内存的对象中</p>
<p>   局部变量存在于栈内存的方法中</p>
<p>3.成员变量随着对象的创建而存在，随着对象的消失而消失</p>
<p>   局部变量随着所属区域的执行而存在，随着所属区域的结束而释放</p>
<p>4.成员变量都有默认初始化值</p>
<p>   局部变量没有默认初始化值</p>
<h2 id="7-面向对象-成员变量和局部变量的同名-amp-显示初始化"><a href="#7-面向对象-成员变量和局部变量的同名-amp-显示初始化" class="headerlink" title="7 面向对象-成员变量和局部变量的同名&amp;显示初始化"></a>7 面向对象-成员变量和局部变量的同名&amp;显示初始化</h2><p>如果在类中描述时变量同名，则运行时先在哪个内存中找到这个变量就显示哪个。上述例子就是先打开是栈内存，并找到num。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Car c = <span class="keyword">new</span> Car();</span><br><span class="line">		c.color = <span class="string">"red"</span>;</span><br><span class="line">		c.run();</span><br><span class="line">		System.out.println(c.num + <span class="string">"..."</span> + c.color);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上述打印结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5...red</span><br><span class="line">6...red</span><br></pre></td></tr></table></figure>

<p>显示初始化</p>
<p>可以在类中的描述直接赋值，这与继承有关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-面向对象-类类型参数"><a href="#8-面向对象-类类型参数" class="headerlink" title="8 面向对象-类类型参数"></a>8 面向对象-类类型参数</h2><p> 类类型的变量一定指向对象，要不就是null。</p>
<h2 id="9-面向对象-匿名对象"><a href="#9-面向对象-匿名对象" class="headerlink" title="9 面向对象-匿名对象"></a>9 面向对象-匿名对象</h2><p>匿名对象：</p>
<p>没有名字的对象。</p>
<p>new Car();//匿名对象其实就是定义对象的简写格式。</p>
<p>使用方式：</p>
<p>1.当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。</p>
<p>new Car().run();</p>
<p>2.匿名对象可以作为实际参数进行传递。</p>
<p>show(new Car());</p>
<h2 id="10-基本数据类型和引用数据类型参数传递图解"><a href="#10-基本数据类型和引用数据类型参数传递图解" class="headerlink" title="10 基本数据类型和引用数据类型参数传递图解"></a>10 基本数据类型和引用数据类型参数传递图解</h2><p>基本数据类型参数传递不用涉及到堆，而引用数据类型涉及到堆。</p>
<p>图解略。</p>
<h2 id="11-面向对象-封装-代码实例、思想"><a href="#11-面向对象-封装-代码实例、思想" class="headerlink" title="11 面向对象-封装-代码实例、思想"></a>11 面向对象-封装-代码实例、思想</h2><p>封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
<p>Java中最小的封装体是函数。类，框架等都是封装体。</p>
<p>好处：</p>
<p>将变化隔离</p>
<p>便于使用</p>
<p>提高重用性</p>
<p>提高安全性</p>
<p>封装原则：</p>
<p>将不需要对外提供的内容都隐藏起来</p>
<p>把属性都隐藏，提供公共方法对其访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Person类中的age是私有的，所以在主函数中不能使用直接调用age，只能利用getAge函数来获得。</p>
<p><strong>Private（私有关键字）</strong>:是一个权限修饰符，用于修饰成员。私有的内容只在本类中有效。</p>
<p>常用之一：将成员变量私有化，对外提供对应的set，get。</p>
<p>​                   方法对其进行访问。提高数据访问的安全性。</p>
<p><strong>注意</strong>：私有仅仅是封装的一种体现而已。不私有也能进行封装。</p>
<p>​           私有是封装，但封装不是私有。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-二维数组</title>
    <url>/2020/03/18/JavaSE-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1.定义方式"></a>1.定义方式</h2><p>第一种命名格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[][] arr&#x3D;new int [3][2];</span><br></pre></td></tr></table></figure>

<p>二维数组可以理解为一个大箱子，里面有若干个小箱子。箱子里面又有若干个格子即元素。</p>
<a id="more"></a>

<p>二维数组定义过程如下：</p>
<p>首先在栈内存中开辟临时内存，定义一个arr。arr使得在堆内存中开辟内存来储存arr中的数组（这里数组指的是第一个中括号的数组），并赋予一个地址，进行初始化。因为这时候初始化的东西是引用类型的数据，所以初始化为null。然后继续为数组的第二个中括号开辟内存，也就是底下三个，并赋予各自的地址，初始化，这里初始化的内容是int类型的数，所以为0。然后这三个内存对应的地址填到刚刚的null对应的格子里，这样完成数组定义。</p>
<p>第二种命名格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[] [] arr&#x3D;new int [3][];</span><br></pre></td></tr></table></figure>

<p>这种定义过程与上述类似，只是它是只定义到二维数组，也就是第一个中括号处。如果要进行二维数组中的每一个维数组也就是第二个中括号的定义，则需要再输入定义语句。所以一开始，二维数组里面存的地址为null。</p>
<p>第三种定义方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[][]arr &#x3D;&#123;&#123;2,3,1&#125;,&#123;2,5,2,1&#125;,&#123;5,7&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是直接输入数字。</p>
<p>打印二维数组的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(arr.length);<span class="comment">//打印二维数组的长度，相当于行数</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>].length);<span class="comment">//打印二维数组中角标为0的一维数组的长度，相当于列数</span></span><br></pre></td></tr></table></figure>

<p>二维数组遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = [<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-数组</title>
    <url>/2020/03/17/JavaSE-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>定义：同一种类型数据的集合。其实数组就是一个容器。<br>好处：可以自动给数组中的元素从0开始编号，方便操作这些元素。<br>格式：元素类型[ ] 数组名=new 元素类型[元素个数或数组长度]<br>数组索引从0开始，这里MySQL数据库索引是从1开始。</p>
<a id="more"></a>

<h2 id="2-内存空间的划分、栈内存、堆内存内存的划分"><a href="#2-内存空间的划分、栈内存、堆内存内存的划分" class="headerlink" title="2 内存空间的划分、栈内存、堆内存内存的划分"></a>2 内存空间的划分、栈内存、堆内存内存的划分</h2><p>1.寄存器：cpu处理</p>
<p>2.本地方法区：所在系统相关。</p>
<p>3.方法区：目前涉及不到</p>
<p>4.栈内存：</p>
<p>存储的都是局部变量</p>
<p>而且变量所属的作用域一旦结束，该变量就自动释放。</p>
<p>5.堆内存：</p>
<p>存储的是数组和对象（其实数组也是对象），凡是new建立的都在堆中。</p>
<p>堆里面存的都是实体。实体就是实实在在存储的个体，用于封装一个或多个数据。</p>
<p>只要看到new，就会在堆里面建立新的空间</p>
<p>特点</p>
<p>1.每一个实体都有一个首地址值</p>
<p>2.堆内存中的每一个变量都有默认初始化值，根据类型不同而不同，整数是0，小数是0.0或者0.0f，boolean是false，char是’\u0000’，字符串String类型是null。</p>
<p>3.释放方式为垃圾回收机制。</p>
<h2 id="3-内存图解（略）"><a href="#3-内存图解（略）" class="headerlink" title="3  内存图解（略）"></a>3  内存图解（略）</h2><h2 id="4-数组常见问题"><a href="#4-数组常见问题" class="headerlink" title="4  数组常见问题"></a>4  数组常见问题</h2><p>ArrayIndexOutOfBoundsException</p>
<p>NullPointerException</p>
<h2 id="5-数组其他定义格式"><a href="#5-数组其他定义格式" class="headerlink" title="5  数组其他定义格式"></a>5  数组其他定义格式</h2><p>格式2：元素类型[ ] 数组名=new 元素类型[ ]{元素，元素，…}；</p>
<p>​       int[ ] arr=new int[ ]{23,13,123,21};需要一个容器，存储已知的具体数据。</p>
<p>格式3：元素类型[ ] 数组名={元素，元素，…}；</p>
<p>​       int[ ] arr={12,21,31,12};</p>
<h2 id="6-常见操作-遍历"><a href="#6-常见操作-遍历" class="headerlink" title="6  常见操作-遍历"></a>6  常见操作-遍历</h2><p>对数组操作最基本的动作是存和取。</p>
<p>​       核心思想：对角标的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++)&#123;<span class="comment">//正向遍历</span></span><br><span class="line">    System.out.println(arr[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = arr.length - <span class="number">1</span>; x &gt;= <span class="number">0</span>; x--)&#123;<span class="comment">//反向遍历</span></span><br><span class="line">    System.out.println(arr[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-常见操作-最值"><a href="#7-常见操作-最值" class="headerlink" title="7  常见操作-最值"></a>7  常见操作-最值</h2><p>获取数组中的最大值</p>
<p>​    思路：</p>
<p>​    1.需要进行比较。并定义变量记录每次比较后较大值</p>
<p>​    2.对数组中的元素进行遍历取出，和变量中记录的元素进行比较。</p>
<p>​       如果遍历到的元素大于变量中记录的元素，就用变量记录住该大的值。</p>
<p>​    3.遍历结果，该变量记录就是最大值。</p>
<p>​    定义的函数中，初始化变量可以是数组中的元素，也可以是0.前者就是比较元素，后者是因为数组中存在角标，角标和数组中的数字是一一对应的，所以也可以用0来初始化，不会担心存在负数的情况。</p>
<p>代码略</p>
<h2 id="8-常见操作-选择排序"><a href="#8-常见操作-选择排序" class="headerlink" title="8 常见操作-选择排序"></a>8 常见操作-选择排序</h2><p>方法：第一轮，比较整个数组即N次，将最小的数放置在第一个位置。第二轮比较N-2次，将第二小的数放置在第二个位置，这样比较N轮完成排序。时间复杂度：O(N2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = arr[i];</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; arr[j])&#123;</span><br><span class="line">                num = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-常见操作-冒泡排序"><a href="#9-常见操作-冒泡排序" class="headerlink" title="9  常见操作-冒泡排序"></a>9  常见操作-冒泡排序</h2><p>方法：先将数组中第一个数和第二数比较，较大的在后面，接着第二个和第三个排序，较大的排在第三个，后面依次类推，直到最后一个，这样最后一个数就是最大的。紧接着用同样的方法将第二大的数排在倒数第二个位置。时间复杂度：O(N2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-查找、折半查找（略）"><a href="#10-查找、折半查找（略）" class="headerlink" title="10 查找、折半查找（略）"></a>10 查找、折半查找（略）</h2><h2 id="11进制转换、查表法"><a href="#11进制转换、查表法" class="headerlink" title="11进制转换、查表法"></a>11进制转换、查表法</h2><p>在计算机中完成10进制到16进制的转换，具体步骤如下：<br>在计算机中，表现形式为二进制，然后开始四个四个与1111进行“与”计算，因为“与”计算可以提取想要的位数。当最底的4位提取完毕后，进行下一步，就将其移4位，进行下一个4位数的提取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0000-0000 0000-0000 0000-0000 0011-1100  60</span><br><span class="line">&amp;0000-0000 0000-0000 0000-0000 0000-1111</span><br><span class="line">-----------------------------------------</span><br><span class="line"> 0000-0000 0000-0000 0000-0000 0000-1100  12即C</span><br><span class="line"> &gt;&gt;&gt;  0000-0000 0000-0000 0000-0000 0011-1100  60&gt;&gt;&gt;4</span><br><span class="line">&amp;0000-0000 0000-0000 0000-0000 0000-1111</span><br><span class="line">-----------------------------------------</span><br><span class="line"> 0000-0000 0000-0000 0000-0000 0000-0011  3</span><br><span class="line"> 最后得到3C</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> pos = arr.length;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num &amp; <span class="number">15</span>;</span><br><span class="line">        arr[--pos] = chs[temp];</span><br><span class="line">        num = num &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; arr.length; i++)&#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化成其他进制类似。</p>
<p>除了自己写之外，在Java中有对应的内置函数来实现，如Integer.toBinaryString(int num);</p>
<p>什么时候使用数组</p>
<p>​    如果数据出现了对应关系，而且对应关系的一方是有序的数字编号。并作为角标使用</p>
<p>​    这时就必须要想到数组的使用</p>
<p>​    就可以将这些数据存储在数组中</p>
<p>​    根据运算的结果作为角标直接去查数组中对应的元素即可。</p>
<p>​    这种方式：<strong>称为查表法</strong></p>
<p>该过程用到了一些思想，值得去回味。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-流程控制语句</title>
    <url>/2020/03/14/JavaSE-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>1.程序流程控制-语句if<br>程序流程控制有四种结构：顺序结构、判断结构、选择结构、循环结构。<br>判断结构-if语句<br>三种格式<br>第一种<br>if(条件表达式)<br>{<br>    执行语句;<br>    }</p>
<a id="more"></a>
<p><strong>注意</strong>：if语句要明确控制范围，用大括号来控制，但当if语句中控制语句是单条语句时大括号可以省略。如果if语句没写大括号，就只能控制离它最近的单条语句。</p>
<p>这里单条语句不是指单行语句。如下图中，红色方框可以看成一个单条语句，所以外面的两个红圈圈起来的大括号可以省略。</p>
<p>第二种<br>if(条件表达式)<br>{<br>    执行语句;<br>}else{<br>    执行语句;<br>}</p>
<p>注意：三运运算符就是if else 语句简写格式。简写格式是运算符，必须要有运算结果，否则不能运行。简写格式当ifesle运算后有一个具体的结果时，可以简化成三元运算符。<br>第三种<br>if(条件表达式)<br>{<br>    执行语句;<br>}else if(条件表达式){<br>    执行语句;<br>}<br>…<br>else{<br>    执行语句;<br>}<br>这里再来一个括号省略的例子</p>
<p>2.局部代码块<br>任何在大括号之间的叫做代码块，加了if，就是if代码块，还有主函数代码块，类代码块如：</p>
<p>如果前面什么也没有，就叫局部代码块。</p>
<p>局部代码块可以定义局部变量的生命周期，可以有效腾出内存空间。</p>
<p>3.语句-switch<br>选择结构-switch<br>switch(表达式)<br>{<br>    case 取值1:<br>    break;<br>    case 取值2:<br>    执行语句;<br>    break;<br>    …<br>    default:默认<br>    执行语句;<br>    break;<br>}<br><strong>Switch语句只支持byte、short、int、char四种类型值</strong>。<br>备选答案是无序的，不是某个选择一定要放在第几个，但是执行是有顺序的。必须先执行case再执行default。<br>Switch结束方式有两种，一种是break结束，一种是执行到大括号结束，所以在最后的选择中，break是可以省略的。</p>
<p>若是这种情况，default和case4没有break，运行过程是先case4、case1、case3判断，然后不属于就来到default，判断对了之后，由于没有break，就继续执行可执行的语句。因为case是执行过，不会再执行，所以就直接执行System.out.printIn，直到遇到break，所以最后结果是：</p>
<p>3.switch与if的区别<br>If：<br>1.对具体的值进行判断<br>2.对区间进行判断<br>3.对运算结果是boolean类型的表达式进行判断</p>
<p>Switch:<br>1.对具体的值进行判断<br>2.值的个数通常的是固定的<br>对于几个固定的值判断建议使用switch语句，因为switch语句会将具体的答案都加载进内存，效率相对高一些。</p>
<p>4.while、do while语句<br>循环结构-while、do while、for<br>While语句<br>while(条件表达式)<br>{<br>    执行语句;<br>}</p>
<p>Do while<br>do<br>{<br>    执行语句;<br>}<br>while(条件表达式);</p>
<p>do while语句特点：无论条件是否满足，循环体至少执行一次。</p>
<p>5.while练习-计数器思想<br>需求：求1~100中6的倍数有几个</p>
<p>6.for语句<br>for(初始化表达式;循环条件表达式;循环后的操作表达式)<br>{<br>    执行语句;(循环体)<br>}</p>
<p>其中需要明白for循环基本运行过程。</p>
<p>有时候也会有上述形式，需要注意不要固化思维。</p>
<p>7.for和while的区别<br>1.for和while可以互换。<br>2.格式上的不同，在使用上有点小区别。<br>如果需要通过变量来对循环进行控制，该变量只作为循环增量的存在，区别就体现出来。<br>即在for括号里面进行的初始化表达式只在for循环中使用，一旦for循环结束，这个量就从内存中移除。</p>
<p>有时候会用到无限循环，所以给出两者无限循环的最简单的表达式</p>
<p>for的三个表达式都可以不写。头尾两个不写就是没有，中间的不写就是默认为true。<br>使用循环结构的场景：<br>当对某些代码执行很多次时，使用循环结构完成。<br>当对一个条件进行一次判断时，可以使用if语句。<br>当对一个条件进行多次判断时，可以使用while语句。<br>注意：1.在使用循环时，一定要明确哪些语句要参与循环，哪些不需要。<br>    2.循环通常情况下需要定义条件和控制次数。</p>
<p>8.for循环嵌套练习</p>
<p>9.语句-break&amp;continue<br>break:跳出<br>break作用范围：要么是switch语句，要么是循环语句。<br>注意：当break语句单独存在时，下面不要定义其他语句，因为执行不到。<br>如：</p>
<p>这种情况并不是break控制if语句，因为break只能控制switch和循环。这里它只是作为if的一个执行，当循环到x=1时，就执行break。</p>
<p>break跳出所在的当前循环<br>如果出现了循环嵌套，break想要跳出指定的循环，可以通过标号来完成。</p>
<p>Continue:<br>continue:结束本次循环，继续下次循环<br>作用范围：循环结构。<br>如果continue单独存在时，下面不要有任何语句，因为执行不到。</p>
<p>这种情况与break类似，同样执行不到下面语句。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-运算</title>
    <url>/2020/03/14/JavaSE-%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>基本的运算，运算两端必须是同一类型数值。<br>1.类型提升和强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">x = x + b;</span><br></pre></td></tr></table></figure>

<p>如果两端是数值型，不是同一类型也可以计算。因为计算时会把不同类型转换成相同类型进行计算，以占用内存比较大的为主。占用内存较小的会进行自动类型提升，如从一个字节提升为四个字节，这个过程是自动进行，最后得结果类型与内存占用较大的一致。如上述情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">b = b + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>这种情况进行编译时会报错，说是缺少精度。因为4是默认为int型，在计算完b=b+4时，b的类型变为int型，而不是byte，所以会报错。如果非要是byte型，则进行强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">b = (<span class="keyword">byte</span>)(b + <span class="number">125</span>);</span><br></pre></td></tr></table></figure>

<p>上面b的结果是-126。它会将高位的字节略去不要，留下低位字节。如果计算完的数在高位字节中有占用，则计算出来的结果不会有高位字节，结果会出现错误。所以强制类型转换会有风险。</p>
<a id="more"></a>
<p>2.字符类型运算过程<br>(‘a’ + 1)<br>对于括号里面的运算，是可以进行编译的，且得出来的结果是98。这里要首先知道存在一个二进制的生活中文字的对应关系表，也就是编码表，简称ASCII。这个表里面只有英文字母，数字和一些符号与二进制的对应关系。其中对应的二进制就是01100001，十进制中也就是97。在上述的计算中，其过程是首先将a转化为编码表里对应的二进制数（占两个字节）然后1是默认为int类型，占4个字节，将a进行类型升级，二者再相加，得到结果98。若想得到字符，则在前面加char，进行强制转换。<br>(char)(‘a’ + 1)<br>A对应65，a对应97,0对应48。<br>中文和二进制也有一一对应的关系，其形成的表叫做GB2312。后期扩展成GBK，之后又扩展成GB18030。<br>存在一个Unicode码表，含有国际上各个文字的码表。基本上都是有国际标准码表来完成。</p>
<p>3.类型运算细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">7</span>;</span><br><span class="line">b = b1 + b2;</span><br></pre></td></tr></table></figure>

<p>这种情况下，编译器会报错，说是缺少精度，应该转成int类型，请问原因（<strong>面试题</strong>）<br>在一开始中，byte b=4，系统检测4，发现int型的4是可以用byte表示，于是默认将int型的4强制转换成byte型。但是在上述代码中b=b1+b2，b1和b2都是变量，就算前面赋值，系统也是检测是变量，变量的话就不知道值是什么，如果还是强行转换成byte类型的话，是有可能装不下的，所以要转换成int类型。<br>如果int运算中也超了，编译是可以的，但是结果是，本来int最多是32位，超出的话会到33位及以上，这是系统就会把33位及以上的位数舍弃，只剩下32位，所以只显示32位的结果。</p>
<p>4.算术运算符和赋值运算符<br>算术运算符有<br> ‘+’- * /    java是强位型语言，其中两个整数除法运算会自动转换，舍弃小数点后的数字。<br>%（取余，模运算）  模运算，5%2是1,-5%2是-1,5%-2是1，所以模运算最后结果的符号看被模数，被模数是负，结果就是负。<br>+（连接） 任何数据用+与字符串相加，都是相连接。</p>
<p>++（自增，在原有数据基础上+1，再赋值给原有数据）<br>a=3；b=a++；这时的运算过程是a要自增，在自增之前，若参与了其他运算，先进行了a自己值的保留值的动作，再自增，再将保留值进行运算。<br>int i=3;i=i++;这时i的值是3。<br>–同上<br>赋值运算符 =、+=、-=、/=、*=、%=<br>int a=4;a+=2;该意思为左边等于左右两边的和即a=4+2=6<br>+=也是赋值运算符，也有做转换动作，底层会自动做强转。</p>
<p>5.比较运算符&amp;逻辑运算符<br>比较运算符<br>比较运算符运算完必定有结果，它的运算结果要么是true，要么是false。<br>比较运算符有：==、!=、&lt;、&gt;、&lt;=、&gt;=、instanceof(检查是否是类的对象，”hello” instanceof String   true)</p>
<p>逻辑运算符<br>逻辑运算符用于连接两个boolean类型的表达式<br>例：<br>&amp;与</p>
<p>|或</p>
<p>^异或<br>和或有些不同，两边都是true或false结果的话，结果是false，即两边比较结果都是一样的话是false，不同则是true。</p>
<p>！非<br>判断事物的另一面<br>!true=false; !false=true; !!true=true<br>&amp;&amp;双与<br>运算结果和单与相同，过程不同，双与只要符号左边一旦为假，则不再执行右边的运算，运算为假。单与则是无论左边的运算结果是什么，右边都参与运算。（<strong>面试会涉及</strong>）<br>||双或<br>运算结果和单或相同，过程不同，双或只要符号左边一旦为真，则不再执行右边的运算，运算为真。单或则是无论左边的运算结果是什么，右边都参与运算。</p>
<p>6.位运算符<br>位运算符有：&lt;&lt;左移，&gt;&gt;右移，&gt;&gt;&gt;无符号右移，&amp;与运算，!或运算，^异或运算，~反码<br>位运算是直接对二进制进行运算<br>这里注意<br>与运算符可以保留想要的后几位数</p>
<p>或运算符可以保留有效位即1</p>
<p>异或运算符中，一个数异或同一个数两次，结果还是这个数，可以用来加密。</p>
<p>7.移位运算符<br>左移&lt;&lt;：<br>如3&lt;&lt;2，将3左移两位，先把3表示成二进制形式，然后左移两位，结果是12。同理3&lt;&lt;3，3左移三位，结果是24，可以发现左移几位就是该数据乘以2的几次方。左移可以完成2的次幂运算。<br>右移&gt;&gt;：<br><strong>注意</strong>：右移后高位出现的空位，原来高位是什么就用什么补这个空位。如负数前面是1则就用1来补充。然后右移几位，其实就是该数据除以2的几次幂。<br>无符号右移&gt;&gt;&gt;：<br>数据进行右移时，高位出现的空位，无论原高位是什么，空位都用0补。</p>
<p>8.位运算符练习<br>1.最有效的方式算出2乘以8等于几？<br>想要运算高效，一般选用位运算。直接对二进制位上的数据进行操作。<br>所以这道题我们观察到8是2的三次方，可以直接使用左移位运算，即2&lt;&lt;3，这样运算的效率更高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>2.对两个整数变量进行互换（不需要第三方变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c = a; a = b; b = c;</span><br></pre></td></tr></table></figure>

<p>这种用了第三方变量，一般在开发时都是使用这种方法，因为能够提高阅读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>


<p>但开发时不用，因为阅读性低</p>
<p>9.三元运算符<br>三个元素参与运算的符号。无论表达形式什么样，都是运算符。只要是运算符，肯定就有结果<br>格式<br>(条件表达式) ? 表达式1 : 表达式2；<br>条件为true 结果是表达式1；条件为false结果是表达式2；<br>例：获取两个整数中较大的整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>,y = <span class="number">4</span>, z;</span><br><span class="line">z = (x &gt; y) ? x : y;</span><br></pre></td></tr></table></figure>


<p>获取三个整数中较大的整数</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-函数</title>
    <url>/2020/03/13/JavaSE-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>1 函数-定义<br>定义：定义在类中的具有特定功能的一段独立小程序。函数也称方法。</p>
<p>2 函数-格式<br>定义函数的格式：<br>    修饰符 返回值类型 函数名（参数类型 形式参数1，参数类型 形式参数2，…）<br>    {<br>        执行语句；<br>        return 返回值；<br>    }</p>
<a id="more"></a>
<p>函数名若是用到多个单词，则第一个单词首字母小写，后面的单词首字母大写。<br>形式参数也可以没有。<br>Return除了返回值的作用还有结束函数的作用。</p>
<p>3 函数-细节-void<br>特殊情况：<br>    功能没有具体的返回值。<br>    这时return的后面直接用分号结束。<br>    返回值类型怎么体现？因为没有具体值，所以不可以写具体的数据类型。<br>    在JAVA中，只能用一个关键字来表示这种情况。关键字是：void<br>    总结：没有具体返回值时，返回值类型用void来表示<br>注意：如果返回值类型是void，那么函数中的return语句可以省略不写。</p>
<p>4、5 函数-细节-错误格式、定义思想错误<br>函数的特点：<br>定义函数可以将功能代码进行封装<br>便于对该功能进行复用<br>函数只有被调用才会被执行<br>函数的出现提高了代码的复用性<br><strong>注意</strong>：<br>(1)函数中只能调用函数，不可以在函数内部定义函数。如下述代码是不行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	myPrint();	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)定义函数时，函数的结果应该返回给调用者，交由调用者处理。<br>如果想要在System.out.println(函数)中有结果，则函数不能是void类型，因为void类型没有返回值，没有输出结果。</p>
<p>6、7 、8函数-两个明确、练习<br>通过两个明确来完成<br>    明确1：这个功能的结果是什么？<br>    是和。是功能的结果，所以该功能的返回值类型是int。<br>    其实就是在明确函数的返回类型。<br>    明确2：这个功能实现过程中是否需要未知内容参与运算？<br>    有，加数和被加数。这就是函数的参数列表（参数的个数、参数类型）<br>    其实就是在明确参数列表<br><strong>注意</strong>：返回值类型和参数类型没有直接关系。</p>
<p>9 函数-内存加载过程<br>Java虚拟机先运行main函数，当遇到新函数或方法时，调用其，开始占用内存空间。等函数或方法调用结束，就不再占用内存，继续main函数，知道main函数执行完毕，也移出内存。<br>在这里提到栈的概念<br>特点：先进后出，先进来的放在栈底。</p>
<p>10 函数-重载<br>概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。<br>特点：与返回值类型无关，只看参数列表。如下述代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java是严谨性语言，如果出现的调用的不确定性，会编译失败。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-语言基础</title>
    <url>/2020/03/13/JavaSE-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>任何高级语言的基础组成<br>关键字、运算符、标识符、语句、注释、函数、常量与变量、数组</p>
<p>01 关键字</p>
<p>被赋予特殊java含义的单词<br>用于定义数据类型的关键字<br>class、interface、byte、short、int、long、float、double、char、boolean、void<br>用于定义数据类型值的关键字<br>true、false、null<br>用于定义流程控制的关键字<br>if、else、swich、case、default、while、do、for、break、continue、return<br>一般情况下，关键字全部是小写</p>
<a id="more"></a>
<p>02 标识符<br>在程序中自定义的一些名称。<br>由26个英文字母大小写，数字：0-9，符号：_$组成<br>定义符合标识符规则：<br>1.数字不可以开头<br>2.不可以使用关键字<br>Java中严格区分大小写。凡是名称都可以算是标识符，比如main函数中的main。</p>
<p>03 注释<br>用于注解说明程序中的文字。<br>单行注释：//说明文字。<br>多行注释：/*<br>          说明<br>          文字。<br>          <em>/<br>文档注释：java特有注释<br>/**<br>文档注释。<br><em>/<br>文档注释可以被javadoc提取，将文字和代码生成一个网页，形成程序说明书。<br>单行注释里面可以嵌套单行注释，即//asd//asd<br>单行注释里面可以嵌套多行注释，即//asd/</em>asd</em>/asd<br>多行注释里面可以嵌套单行注释，即/<em>asd//asd <em>/<br>多行注释里面可以嵌套多行注释，即/</em>asd/*asd</em>/，这里注意后面只有一个*/。<br>注释文字在编译时不编译进去。</p>
<p>04 注释的应用<br>工作或者面试时写代码，一定要添加注释。<br>以后一开始写程序时先写多行注释。</p>
<p>05 常量<br>表示不能改变的数值<br>分类：</p>
<ol>
<li>整数常量。所有整数 如2</li>
<li>小数常量。所有小数 如1.2</li>
<li>布尔（boolean）型常量。较为特殊，只有两个数值：true false</li>
<li>字符常量。将一个数字字母或者符号用单引号(‘’)标识 如‘2’‘a’</li>
<li>字符串常量。将一个或者过个字符用双引号(“”)标识 如“212”“asd”</li>
<li>null常量（空常量）。只有一种数值就是null。</li>
</ol>
<p>06 进制的由来<br>对于整数有四种表现形式<br>二进制：0.1，满2进1<br>八进制：0-7，满8进1，用0开头表示<br>十进制：0-9，满10进1<br>十六进制：0-9，A-F，满16进1.用0x开头表示</p>
<p>将八个二进制位成一个数据存储最小单元，称之为byte字节<br>每一个二进制位叫做bit位<br>1k=1024字节；<br>由于这样8个表示太麻烦，于是让三个bit位为一组，为八进制，四个为一组为16进制</p>
<p>07 进制转换<br>由于这样8个表示太麻烦，于是让三个bit位为一组，为八进制，四个为一组为16进制<br>这也是二进制转换成八进制和十六进制的比较快速的转换方法，例如<br>二进制10101110<br>转换成八进制，先以三个为一组，个数不够前面加0。再分别算出每组二进制对应的十进制，然后便得出八进制，如<br>010-101-110<br> 2   5   6即八进制表示就是0256<br>转换成十六进制<br>1010-1110<br> 10   14  即十六进制表示就是0xAE<br>结论：<br>八进制数，其实就是二进制位，3个二进制位为一个八进制<br>十六进制，其实就是二进制位，4个二进制位为一个十六进制</p>
<p>十进制转化成二进制<br>用2除取余数的方法，再从下往上看。</p>
<p>08 负数的进制<br>负数的二进制就是这个数的正数的二进制取反，加1<br>如-6<br>0000-0110 取反 1111-1001 加1即+0000-0001<br>等于1111-1010<br><strong>凡是负数，其二进制的最高位是1</strong></p>
<p>09 变量的介绍<br>概念：变量是内存中的一个存储区域，用来存储不确定的数据。当数据不确定时就要使用变量。<br>      该区域有自己的名称（变量名）和类型（数据类型），不同类型的数据不能放在同一区域<br>      该区域的数据可以在同一类型范围内不断变化<br>目的：用来不断地存放同一类型的常量，并可以重复使用。<br><strong>注意</strong>：变量的作用范围<br>      初始化值<br>定义变量的格式：<br>数据类型 变量名=初始化值<br>注：格式是固定的，记住格式，以不变应万变<br>Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。<br>数据类型分为基本数据类型和引用数据类型<br>基本数据类型分为数值型、字符型和布尔型<br>数值型有整数类型（byte,short,int,long）<br>Byte：字节，内存中占一个八位，-27到27-1，即-128至127<br>Short：短整型，内存从占两个字节即16个比特位，-215到215-1<br>Int：内存占4个字节，-2^31到2^31-1<br>Long：长整型，内存占8个字节<br>一般情况下，整数默认为int类型。<br>浮点类型（float,double）<br>Float：单精度，由4个字节表示<br>Double：双精度，由8个字节表示<br>一般情况下，小数默认为double类型。<br>字符型（char）：取值范围0到65535，即两个字节。‘12’不能存放，但是一个中文比如你好的你，可以存放。<br>布尔型（boolean）：<br>以上8个都是关键字。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的一些基本操作</title>
    <url>/2020/03/06/hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="创建新文章并部署到远端"><a href="#创建新文章并部署到远端" class="headerlink" title="创建新文章并部署到远端"></a>创建新文章并部署到远端</h2><p>1.执行 hexo new[layout] 文章名 即可<br>layout为布局，Hexo有三种默认布局：post、page和draft，默认为post，可以在_config.yml中的default_layout 参数来指定默认布局</p>
<p>2.文章写完后保存文件，执行 hexo generate 或 hexo g 生成静态文件</p>
<p>3.执行 hexo deploy 将文件部署到远端</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/03/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这是我的第一个技术博客<br>希望能坚持下去，见证接下来的变化！</p>
<a id="more"></a>
<h2 id="639"><a href="#639" class="headerlink" title="639"></a>639</h2><p>639天下第一，不接受反驳</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
