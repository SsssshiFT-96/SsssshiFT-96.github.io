<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaSE-面向对象多态内部类</title>
    <url>/2020/03/21/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="面向对象-多态-amp-内部类"><a href="#面向对象-多态-amp-内部类" class="headerlink" title="面向对象-多态&amp;内部类"></a>面向对象-多态&amp;内部类</h1><h2 id="1-面向对象-多态-概述、好处"><a href="#1-面向对象-多态-概述、好处" class="headerlink" title="1 面向对象-多态-概述、好处"></a>1 面向对象-多态-概述、好处</h2><p>定义：某一类型事物的多种存在形态</p>
<p>对象的多态性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 猫 <span class="keyword">extends</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 狗 <span class="keyword">extends</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoTaiDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        猫 x=<span class="keyword">new</span> 猫();</span><br><span class="line">		动物 x=<span class="keyword">new</span> 猫();<span class="comment">//一个对象两种形态。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猫这类事物即具备着猫的形态，又具备着动物的形态</p>
<p>这就是对象的多态性。</p>
<p>简单说<strong>就是一个对象对应着不同类型。</strong></p>
<p>多态在代码中的体现：父类或者接口的引用指向其子类的对象。</p>
<p>多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容</p>
<h2 id="2-面向对象-多态-弊端-amp-前提"><a href="#2-面向对象-多态-弊端-amp-前提" class="headerlink" title="2 面向对象-多态-弊端&amp;前提"></a>2 面向对象-多态-弊端&amp;前提</h2><p>多态的弊端：前期定义的内容不能使用（调用）后期子类的特有内容。</p>
<p>动物 x = new 猫();这个对象x不能调用猫类中的特有内容。但方法若能调用，则都是猫类中复写的方法。</p>
<p>多态的前提</p>
<p>1.必须有关系，继承，实现</p>
<p>2.要有覆盖</p>
<h2 id="3-面向对象-多态-转型"><a href="#3-面向对象-多态-转型" class="headerlink" title="3 面向对象-多态-转型"></a>3 面向对象-多态-转型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal x=<span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>

<p>自动类型提升，猫对象提升了为动物类型。但是特有功能无法访问。</p>
<p>作用就是提高扩展性和限制对特有功能的访问。</p>
<p>专业讲：向上转型。将子类型隐藏，就不能使用子类的特有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c = (Cat)x;</span><br></pre></td></tr></table></figure>

<p>如果还想用具体动物猫的特有功能，你可以将该对象进行向下转型</p>
<p>写法与强制转型相同</p>
<p>向下转型的目的是为了使用子类中的特有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a1 = <span class="keyword">new</span> Dog();</span><br><span class="line">Cat c1 = (Cat)a1;</span><br></pre></td></tr></table></figure>

<p>这样会转型失败。</p>
<p><strong>注意</strong>：对于转型，自始至终都是子类对象在做着类型的变化。而cat和dog没有继承关系</p>
<h2 id="4-面向对象-多态-类型判断-instanceof"><a href="#4-面向对象-多态-类型判断-instanceof" class="headerlink" title="4 面向对象-多态-类型判断-instanceof"></a>4 面向对象-多态-类型判断-instanceof</h2><p>instanceof 用于判断对象的具体类型。只能用于引用数据类型判断。</p>
<p>通常在向下转型前用于健壮性的判断</p>
<h2 id="5-面向对象-多态-成员变量"><a href="#5-面向对象-多态-成员变量" class="headerlink" title="5 面向对象-多态-成员变量"></a>5 面向对象-多态-成员变量</h2><p>1.成员变量</p>
<p>​    编译时：参考的是引用型变量所属的类中是否有调用的成员变量，有，编译通过，没有，编译失败</p>
<p>​    运行时：参考的是引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量</p>
<p>​    简单说：编译和运行都参考等号左边的类中是否存在需要的成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoTaiDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">		System.out.print(f.num);<span class="comment">//此时会编译失败，因为Fu类中不存在num这个成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-面向对象-多态-成员函数（非静态）"><a href="#6-面向对象-多态-成员函数（非静态）" class="headerlink" title="6 面向对象-多态-成员函数（非静态）"></a>6 面向对象-多态-成员函数（非静态）</h2><p>图解：</p>
<p>主函数进栈，然后Fu类加载，接着Zi类加载。堆中创建Zi对象，先生成地址，没有变量，无需初始化，将地址赋给f。调用show()方法，show进栈，f的地址指向Zi对象，先在Zi类中寻找show方法，若Zi类中没有，则在Fu类中寻找。</p>
<p>编译时：参考的是引用型变量所属的类中是否有调用的成员函数，有，编译通过，没有，编译失败</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：编译看左边，运行看右边。</p>
<h2 id="7-面向对象-多态-静态函数"><a href="#7-面向对象-多态-静态函数" class="headerlink" title="7 面向对象-多态-静态函数"></a>7 面向对象-多态-静态函数</h2><p>与上述不同，加载时，两个类中的静态show在静态区，调用直接和类绑定，与对象无关。所以f.show（）；，一看f是属于Fu类吗，就直接调用Fu的show。</p>
<p>编译时：参考的是引用型变量所属的类中是否有调用的静态方法，有，编译通过，没有，编译失败</p>
<p>运行时：参考的是引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：编译和运行都参考左边</p>
<p>其实对于静态方法，是不需要对象的，直接用类名调用即可。</p>
<h2 id="8-面向对象-内部类-概述"><a href="#8-面向对象-内部类-概述" class="headerlink" title="8 面向对象-内部类-概述"></a>8 面向对象-内部类-概述</h2><p>将一个类定义在另一个类的里面，对里面那个类就称为内部类（内置类、嵌套类）。</p>
<p>内部类生成文件的名字为：外部类$内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.内部类可以直接访问外部类中的成员</p>
<p>2.外部类要访问内部类，必须建立内部类的对象</p>
<p>一般用于类的设计</p>
<p>分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述事物的内容</p>
<p>这时就是还有的事物定义成内部类来描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">		System.out.print(<span class="string">"aaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="9-面向对象-内部类-修饰符"><a href="#9-面向对象-内部类-修饰符" class="headerlink" title="9 面向对象-内部类-修饰符"></a>9 面向对象-内部类-修饰符</h2><p>直接访问外部类中的内部类的成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br><span class="line">in.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，相当于一个外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in =<span class="keyword">new</span> Outer.Inner();</span><br><span class="line">in.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，成员是静态的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = Outer.Inner.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类中定义了静态成员，该内部类也必须是静态。</p>
<h2 id="10-面向对象-内部类-细节"><a href="#10-面向对象-内部类-细节" class="headerlink" title="10 面向对象-内部类-细节"></a>10 面向对象-内部类-细节</h2><p>为什么内部类能直接访问外部类中成员呢？</p>
<p>那是因为内部类持有了外部类的引用。外部类名.this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">            System.out.print(<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果是<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="11-面向对象-内部类-局部内部类"><a href="#11-面向对象-内部类-局部内部类" class="headerlink" title="11 面向对象-内部类-局部内部类"></a>11 面向对象-内部类-局部内部类</h2><p>内部类可以存放在局部位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            	System.out.print(num);</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">答案：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p>内部类在局部位置上只能访问局部中被final修饰的局部变量。</p>
<h2 id="12-面向对象-匿名内部类-概述"><a href="#12-面向对象-匿名内部类-概述" class="headerlink" title="12 面向对象-匿名内部类-概述"></a>12 面向对象-匿名内部类-概述</h2><p>匿名内部类，就是内部类的简写格式</p>
<p><strong>必须有前提</strong></p>
<p>内部类必须继承或者实现一个外部类或者接口</p>
<p>匿名内部类：其实就是一个匿名子类对象。</p>
<p>格式：new 父类or接口名(){子类内容}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Demo()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function">abtract <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="13-面向对象-匿名内部类-应用、细节"><a href="#13-面向对象-匿名内部类-应用、细节" class="headerlink" title="13  面向对象-匿名内部类-应用、细节"></a>13  面向对象-匿名内部类-应用、细节</h2><p>通常使用场景之一：</p>
<p>当函数参数是接口类型时，而且接口中的方法不超过三个</p>
<p>可以用匿名内部类作为实际参数进行传递</p>
<p>细节：1.匿名内部类这个子类对象被向上转型了为Object类型，这样就不能再使用子类的特有方法了。</p>
<p>​            2.在静态方法中不能创建匿名内部类。</p>
<h2 id="14-面向对象-对象的初始化过程（总结）"><a href="#14-面向对象-对象的初始化过程（总结）" class="headerlink" title="14 面向对象-对象的初始化过程（总结）"></a>14 面向对象-对象的初始化过程（总结）</h2><p>1.首先产生对象，堆中开辟内存，默认初始化变量。</p>
<p>2.然后先进Zi类的构造函数，根据super();进入Fu类的构造函数，执行语句</p>
<p>3.调用其中的show函数，这个show函数为Zi类中的show函数，因为被覆盖了。</p>
<p>4.开始显示初始化</p>
<p>5.开始构造代码块初始化</p>
<p>6.构造函数具体初始化</p>
<p>7.调用show函数</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象抽象类接口</title>
    <url>/2020/03/21/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="面向对象-抽象类-amp-接口"><a href="#面向对象-抽象类-amp-接口" class="headerlink" title="面向对象-抽象类&amp;接口"></a>面向对象-抽象类&amp;接口</h1><h2 id="1-抽象类概述-amp-特点"><a href="#1-抽象类概述-amp-特点" class="headerlink" title="1 抽象类概述&amp;特点"></a>1 抽象类概述&amp;特点</h2><p>抽象：笼统、模糊</p>
<p>当一个类描述一个事物时，没有足够的信息描述时，就叫抽象类。</p>
<p>比如狗和狼都会吼叫，他们提取出来都是犬科，犬科也有吼叫，但是吼叫内容不一样，所以就是有着相同的函数声明，但内容不同，这样就出现了抽象的概念。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> 吼叫();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 狗 <span class="keyword">extends</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 吼叫()&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 狼 <span class="keyword">extends</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 吼叫()&#123;</span><br><span class="line">        System.out.println(<span class="string">"嗷嗷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>特点：</p>
<p>1.方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰</p>
<p>​    抽象方法必须定义在抽象类中，该类必须也被关键字修饰</p>
<p>2.抽象类不可以被实例化，即不能被new创建对象。因为调用抽象方法没有意义。</p>
<p>3.抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化</p>
<p>​    否则这个子类还是抽象类。</p>
<h2 id="2-面向对象-抽象类-细节"><a href="#2-面向对象-抽象类-细节" class="headerlink" title="2 面向对象-抽象类-细节"></a>2 面向对象-抽象类-细节</h2><p>1)抽象类中有构造函数吗？</p>
<p>有，用于给子类对象进行初始化</p>
<p>2)抽象类可以不定义抽象方法吗？</p>
<p>可以的。但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类</p>
<p>通常这个类中的方法有方法体，但是没有内容</p>
<p>3)抽象关键字不可以和哪些关键字共存？</p>
<p>private 抽象方法需要被覆盖，私有了子类就无法访问就无法覆盖。</p>
<p>static 成员变静态，不需要对象，抽象方法没有方法体，运行没有意义，</p>
<p>final 抽象需要覆盖，而final不让覆盖</p>
<p>4)抽象类和一般类的异同点</p>
<p>相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员</p>
<p>不同点：</p>
<p>1.一般类有足够的信息描述事物，抽象类描述事物的信息有可能不足。</p>
<p>2.一般类中不能定义抽象方法，只能定义非抽象方法，而抽象类中可以定义抽象方法金和非抽象方法。</p>
<p>3.一般类可以被实例化，抽象类不可被实例化</p>
<p>5)抽象类一定是个父类吗？</p>
<p>是的，因为需要子类覆盖其方法后才可以对子类实例化。</p>
<h2 id="3-面向对象-接口-定义interface、实现implements"><a href="#3-面向对象-接口-定义interface、实现implements" class="headerlink" title="3 面向对象-接口-定义interface、实现implements"></a>3 面向对象-接口-定义interface、实现implements</h2><p>当一种抽象类中的<strong>方法都是抽象</strong>的时候，这是可以将该抽象类用另一种形式定义和表示，就是接口，interface</p>
<p>定义接口使用的关键字不是class，是interface,但编译出来的文件后缀名仍是class。</p>
<p>对于接口当中常见的成员，而且这些成员都有固定的修饰符</p>
<p>1.全局常量：public static final</p>
<p>2.抽象方法；public abstract</p>
<p>由此得出结论：<strong>接口中的成员都是公共的权限即权限都是最大的</strong>。</p>
<p>因为接口中的成员修饰符是固定的，所以可以省略前面的修饰符，编译器会自动加上。例如abstract因为接口中的方法必是抽象方法，所有可以省略abstract。</p>
<p>虽说如此，但修饰符还是要带上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">4</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<p><strong>类与类之间是继承关系，类与接口之间是实现关系</strong></p>
<p>接口<strong>不可以实例化</strong></p>
<p>只能由实现了接口的子类并<strong>覆盖了接口中所有的抽象方法</strong>后，该子类才可以实例化</p>
<p>否则这个子类就是一个抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoImp1</span> <span class="keyword">implements</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DemoImp1 d = <span class="keyword">new</span> DemoImp1();</span><br><span class="line">        System.out.println(d.NUM);</span><br><span class="line">        System.out.println(Demo.NUM);</span><br><span class="line">        System.out.println(DemoImp1.NUM);<span class="comment">//这三种调用皆可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-接口-多实现"><a href="#4-面向对象-接口-多实现" class="headerlink" title="4 面向对象-接口-多实现"></a>4 面向对象-接口-多实现</h2><p>在java中不直接支持多继承，因为会出现调用的不确定性</p>
<p>所以java将多继承机制进行改良，在java中变成了多实现</p>
<p>一个类可以实现多接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-面向对象-接口-细节"><a href="#5-面向对象-接口-细节" class="headerlink" title="5 面向对象-接口-细节"></a>5 面向对象-接口-细节</h2><p>一个类继承另一个类的同时，还可以实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Q</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口与接口之间是继承关系，而且接口可以多继承，原理在于是否存在方法体，是否存在不确定性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ZZ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">QQ</span> <span class="keyword">extends</span> <span class="title">AA</span>, <span class="title">ZZ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">QQ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-面向对象-接口-特点"><a href="#6-面向对象-接口-特点" class="headerlink" title="6 面向对象-接口-特点"></a>6 面向对象-接口-特点</h2><p>接口是对外暴露的规则</p>
<p>接口是程序的功能扩展</p>
<p>接口的出现降低耦合性</p>
<p>接口可以用来多实现</p>
<p>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</p>
<p>接口与接口之间可以有继承关系</p>
<h2 id="7-面向对象-接口-接口和抽象类的区别"><a href="#7-面向对象-接口-接口和抽象类的区别" class="headerlink" title="7 面向对象-接口-接口和抽象类的区别"></a>7 面向对象-接口-接口和抽象类的区别</h2><p>抽象类和接口的异同点</p>
<p>相同点：</p>
<p>都是不断向上抽取而来的</p>
<p>不同点：</p>
<p>1.抽象类需要被继承，而且只能单继承</p>
<p>   接口需要被实现，而且可以多实现</p>
<p>2.抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法</p>
<p>   接口中只能定义抽象方法，必须有子类去实现</p>
<p>3.抽象类的继承是is a 关系，所属关系，在定义该体系的基本共性内容</p>
<p>   接口的实现时like a关系，像关系，在定义体系额外功能</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象4</title>
    <url>/2020/03/20/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14/</url>
    <content><![CDATA[<h1 id="面向对象4"><a href="#面向对象4" class="headerlink" title="面向对象4"></a>面向对象4</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h2 id="1-面向对象-继承-概述"><a href="#1-面向对象-继承-概述" class="headerlink" title="1 面向对象-继承-概述"></a>1 面向对象-继承-概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span>/*继承*/ <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">"..."</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        s.name = <span class="string">"aaa"</span>;</span><br><span class="line">        s.age = <span class="number">22</span>;</span><br><span class="line">        s.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：aaa…22</p>
<a id="more"></a>

<p>上述代码中，Person是Student的父类，Student继承了Person中的name和age。</p>
<p>继承的好处</p>
<p>1.提高代码的复用性</p>
<p>2.让类与类之间产生了关系，给第三个特征多态提供了前提。</p>
<h2 id="2-面向对象-继承-单继承与多重继承"><a href="#2-面向对象-继承-单继承与多重继承" class="headerlink" title="2 面向对象-继承-单继承与多重继承"></a>2 面向对象-继承-单继承与多重继承</h2><p>java中支持单继承，不直接支持多继承，但对c++中的多继承机制进行改良</p>
<p>单继承：一个子类只能有一个直接父类</p>
<p>多继承：一个子类可以有多个直接父类（java中不允许，进行改良）。</p>
<p>​               不直接支持，是因为若父类中有相同的成员，会产生调用的不确定性。</p>
<p>​               在java中是通过“多实现”的方式来体现。</p>
<p>java支持多层（多重）继承</p>
<p>即C继承B，B继承A。</p>
<p>就会出现继承体系</p>
<p>当要使用继承体系时</p>
<p>1.查看该体系中的顶层类，了解该体系的基本功能</p>
<p>2.创建体系中的最子类对象，完成功能的使用</p>
<h2 id="3-面向对象-继承-定义继承"><a href="#3-面向对象-继承-定义继承" class="headerlink" title="3 面向对象-继承-定义继承"></a>3 面向对象-继承-定义继承</h2><p>什么时候定义继承</p>
<p>当类与类之间存在着所属关系的时候，就定义继承。</p>
<p>如xxx是yyy中的一种，则xxx extends yyy。</p>
<p>若A类有a方法和b方法，B类有a方法和c方法，即使B类有a方法，但是A类中没有c方法，所有这两个类不能构成继承关系。</p>
<h2 id="4-面向对象-继承-子父类中成员变量的特点"><a href="#4-面向对象-继承-子父类中成员变量的特点" class="headerlink" title="4 面向对象-继承-子父类中成员变量的特点"></a>4 面向对象-继承-子父类中成员变量的特点</h2><p>当本类的成员和局部变量同名用this区分</p>
<p>当子父类中的成员变量同名用<strong>super</strong>区分父类</p>
<p>this和super的用法很相似。</p>
<p>this代表一个本类对象的引用</p>
<p>super代表一个父类空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.num + <span class="string">"..."</span> + <span class="keyword">super</span>.num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若调用show()，结果为4…5。</p>
<h2 id="5-面向对象-继承-子父类中成员变量的内存图解"><a href="#5-面向对象-继承-子父类中成员变量的内存图解" class="headerlink" title="5 面向对象-继承-子父类中成员变量的内存图解"></a>5 面向对象-继承-子父类中成员变量的内存图解</h2><p>主函数先进栈，然后先在方法区加载一个父类空间，其次加载子类空间。之后在堆内存中开辟空间，产生地址，创建对象，<strong>然后在该堆空间中，分别开辟空间存储子类和父类变量</strong>，然后进行初始化。然后将地址给z。然后进行show方法，进栈，将地址赋给this指向堆内存。父类成员变量已经随着子类建立已经存储在子类空间当中。打印super.num时，就直接找到那个空间的父类成员变量。</p>
<p>一般开发时，同名这种情况不多见，面试的时候比较常见。</p>
<p><strong>子类不能直接访问父类当中的私有内容</strong></p>
<h2 id="6-面向对象-继承-子父类中成员函数的特点-覆盖"><a href="#6-面向对象-继承-子父类中成员函数的特点-覆盖" class="headerlink" title="6 面向对象-继承-子父类中成员函数的特点-覆盖"></a>6 面向对象-继承-子父类中成员函数的特点-覆盖</h2><p>当子父类中出现成员函数一模一样的情况，会运行子类的函数</p>
<p>这种现象，称为<strong>覆盖操作</strong>，这是函数在子父类中的特性。</p>
<p>函数两个特性（只有函数有）：</p>
<p>1.重载，同一个类中</p>
<p>2.覆盖，子类中，覆盖也称为重写，覆写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"fu run"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"zi run"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：Zi show run。</p>
<p><strong>覆盖注意事项</strong>：</p>
<p>1.子类方法覆盖父类方法时，子类权限必须大于等于父类的权限，才可以引发覆盖。</p>
<p> 如果父类是权限为private，则就不称之为覆盖，因为父类就不能访问，故称不上覆盖。</p>
<p>2.静态只能覆盖静态，或被静态覆盖。</p>
<h2 id="7-面向对象-继承-子父类中成员函数的特点-覆盖的使用场景"><a href="#7-面向对象-继承-子父类中成员函数的特点-覆盖的使用场景" class="headerlink" title="7 面向对象-继承-子父类中成员函数的特点-覆盖的使用场景"></a>7 面向对象-继承-子父类中成员函数的特点-覆盖的使用场景</h2><p>什么时候使用覆盖操作</p>
<p>当对一个类进行子类的扩展时，子类需要保留父类的功能声明，</p>
<p>但是要定义子类中该功能的特有内容时，就使用覆盖操作完成。</p>
<h2 id="8-面向对象-继承-子父类中的构造函数-子类的实例化过程、细节"><a href="#8-面向对象-继承-子父类中的构造函数-子类的实例化过程、细节" class="headerlink" title="8 面向对象-继承-子父类中的构造函数-子类的实例化过程、细节"></a>8 面向对象-继承-子父类中的构造函数-子类的实例化过程、细节</h2><p>在子类构造对象时，发现访问子类构造函数时，父类也运行了。</p>
<p>原因是：在子类的构造函数中第一行有一个默认的隐式语句。super(){ };这会让父类中构造函数也运行。</p>
<p>super();//调用的就是父类中的空参数的构造函数。如果父类没有空参，则会编译失败，若父类是带参的，即Fu(int x)，那么就写成super(4);类型即可。</p>
<p>子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数。</p>
<p>为什么子类实例化的时候要访问父类中的构造函数？</p>
<p>因为子类继承了父类，获取到了父类中内容（属性），所以在使用父类内容之前，</p>
<p>要先看父类是如何对自己的内容进行初始化的。</p>
<p>所以子类在构造对象时，必须访问父类中的构造函数</p>
<p>为了完成这个必须的动作，就在子类的构造函数中加入了super()；语句。</p>
<p>如果父类没有定义空参数构造函数，那么子类的构造函数必须用super明确调用父类中的一个构造函数。</p>
<p><strong>注意</strong>：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成。</p>
<p>同时子类构造函数中如果使用this调用了本类构造函数时，super就没有了，因为super和this都只能定义在第一行，所以只能有一个。</p>
<p>但是可以保证的是，若使用的子类的构造函数中有this，那么创建对象时会使用子类中其他的构造函数访问父类的构造函数。</p>
<p>Java中有若干对象，他们有个最顶层的类，是Object，创建的任何对象都是Object的子类。class Demo extends Object，一般extends Object不写。</p>
<h2 id="9-面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解"><a href="#9-面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解" class="headerlink" title="9 面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解"></a>9 面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    Fu()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fu show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">8</span>;</span><br><span class="line">    Zi()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"zi show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：zi show…0<br>               zi show…8</p>
<p>先主函数进栈，出现z，要创建对象，加载Zi类，但是Zi类有继承Fu类，所以先加载Fu类，Fu就进内存中的方法区，然后加载Zi类。之后在堆中创建new Zi对象，赋予地址，对变量进行默认初始化，num=0。默认初始化结束后，Zi的构造函数进栈，里面有个super函数，Fu类构造函数进栈，然后运行show()函数，这里注意，这里的函数全写为this.show();所以先从this所指的对象中开始找show();发现在new Zi中有show()函数，所以就调用子类的show()函数。此时Fu类的构造结束，弹栈。然后才将8赋给num值，即显示初始化。之后Zi类构造函数弹栈。然后地址赋给z。</p>
<p><strong>总结</strong></p>
<p>一个对象实例化过程</p>
<p>Person p=new Person();</p>
<p>1.JVM会读取指定的路径下的Person.class 文件，并加载进内存</p>
<p>​    并会先加载Person的父类（如果有直接父类的情况下）</p>
<p>2.在堆内存中开辟空间，分配地址</p>
<p>3.并在对象空间中，对对象中的属性进行默认初始化</p>
<p>4.调用对应的构造函数进行初始化</p>
<p>5.在构造函数中，第一行会先到调用父类中构造函数中进行初始化</p>
<p><strong>6.父类初始化完毕后，再对子类的属性进行显示初始化。//这一块是分水岭。</strong></p>
<p>7.再进行自类构造函数的特定初始化</p>
<p>8.初始化完毕后，将地址值赋给引用变量。</p>
<h2 id="10-面向对象-final关键字"><a href="#10-面向对象-final关键字" class="headerlink" title="10 面向对象-final关键字"></a>10 面向对象-final关键字</h2><p>1.Final可以修饰类，方法，变量</p>
<p>2.Final修饰的类不可以被继承</p>
<p>3.Final修饰的方法不可以被覆盖</p>
<p>4.Final修饰的变量是一个常量。只能被赋值一次</p>
<p>为什么要用final修饰变量</p>
<p>其实在程序中，如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差</p>
<p>所以它该数据起个名称，而且这个变量名称的值不能变化，所以加上final固定。</p>
<p>写法规范：常见所有字母都大写，多个单词中间用下划线“_”连接，MY_NUM。</p>
<p>Final固定的是显示初始化值，不是默认初始化值。</p>
<p>public static为全局的意思</p>
<p>public static final double PI=3.14 全局常量。</p>
<p>5.内部类只能访问被final修饰的局部变量</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象3</title>
    <url>/2020/03/20/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13/</url>
    <content><![CDATA[<h1 id="面向对象3"><a href="#面向对象3" class="headerlink" title="面向对象3"></a>面向对象3</h1><h2 id="1-数组对象建立、数组工具类中静态的使用"><a href="#1-数组对象建立、数组工具类中静态的使用" class="headerlink" title="1 数组对象建立、数组工具类中静态的使用"></a>1 数组对象建立、数组工具类中静态的使用</h2><p>可以建立一个数组对象，将对数组的操作方法定义在类中。用到了面向对象的方法。</p>
<h2 id="2-文档注释"><a href="#2-文档注释" class="headerlink" title="2 文档注释"></a>2 文档注释</h2><p>Javadoc.exe可以提取文档注释，只能解析/** */的内容</p>
<p>提取操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -d. -author -version xxx.java</span><br></pre></td></tr></table></figure>

<p>-d指输出文件的目标目录， . 指在当前目录下， -***，指需要提取的目录。</p>
<p>要将文档用该程序提取注释，则需要将类公有化，否则无法执行</p>
<h2 id="3-面向对象-单例设计-概念-amp-体现"><a href="#3-面向对象-单例设计-概念-amp-体现" class="headerlink" title="3  面向对象-单例设计-概念&amp;体现"></a>3  面向对象-单例设计-概念&amp;体现</h2><p>设计模式：对问题行之有效的解决方式，其实它是一种思想。</p>
<p>1.单例设计模式</p>
<p>解决的问题：可以保证一个类在内存中的对象唯一性。</p>
 <a id="more"></a>

<p>比如对于多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性。</p>
<p>如何保证对象的唯一性：</p>
<p>1.不允许其他程序用new创建该类对象。这样可以避免产生更多对象</p>
<p>2.在该类中创建一个本类实例。</p>
<p>3.对外提供方法让其他程序可以获取该对象。</p>
<p>步骤：</p>
<p>1.私有化该类的构造函数</p>
<p>2.通过new在本类中创建一个本类并私有的对象</p>
<p>3.定义一个公有的方法将创建的对象返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//设置这个函数是为了可控因为可以在里面设置条件</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span>()</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Sinlge ss = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-单例设计-内存图解"><a href="#4-面向对象-单例设计-内存图解" class="headerlink" title="4 面向对象-单例设计-内存图解"></a>4 面向对象-单例设计-内存图解</h2><p>略</p>
<h2 id="5-面向对象-单例设计-饿汉式和懒汉式"><a href="#5-面向对象-单例设计-饿汉式和懒汉式" class="headerlink" title="5 面向对象-单例设计-饿汉式和懒汉式"></a>5 面向对象-单例设计-饿汉式和懒汉式</h2><p>饿汉式：类一加载，对象就已经存在，即上述3中的代码就是饿汉式</p>
<p>懒汉式：类加载进来，没有对象，只有调用了getInstance()方法时，才会创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) s = <span class="keyword">new</span> Single();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正式开发中饿汉式用的多，因为懒汉式后期被另外一种技术比如多线程技术操作时，可能会保证不了唯一性。</p>
<p><strong>面试几乎涉及懒汉式</strong>，里面涉及的知识点比较多。</p>
<p><strong>单例模式作为重点掌握</strong></p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象2</title>
    <url>/2020/03/19/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/</url>
    <content><![CDATA[<h1 id="面向对象2"><a href="#面向对象2" class="headerlink" title="面向对象2"></a>面向对象2</h1><h2 id="1-面向对象-构造函数-概述、默认构造函数"><a href="#1-面向对象-构造函数-概述、默认构造函数" class="headerlink" title="1 面向对象-构造函数-概述、默认构造函数"></a>1 面向对象-构造函数-概述、默认构造函数</h2><p>构造函数：构建创造对象时调用的函数。</p>
<p>作用：可以给对象进行初始化。</p>
<p>特点：</p>
<p>1.函数名与类名相同。</p>
<p>2.不用定义返回值。</p>
<p>3.没有具体的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	Person()&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象都必须要通过构造函数初始化。</p>
<a id="more"></a>

<p><strong>默认构造函数</strong></p>
<p>一个类中如果没有定义过构造函数，那么该类中会有一个默认的空参数构造函数。</p>
<p>如果在类中定义了指定的构造函数，那么类中的默认构造函数就没有了。</p>
<h2 id="2-面向对象-构造函数-构造函数和一般函数的区别"><a href="#2-面向对象-构造函数-构造函数和一般函数的区别" class="headerlink" title="2 面向对象-构造函数-构造函数和一般函数的区别"></a>2 面向对象-构造函数-构造函数和一般函数的区别</h2><p>一般函数和构造函数的区别</p>
<p>构造函数：对象创建时，就会调用与之对应的构造函数，对对象进行初始化</p>
<p>一般函数：对象创建后，需要函数功能时才调用。</p>
<p>构造函数：对象创建时，会调用只调用一次</p>
<p>一般函数：对象创建后，可以被调用多次。</p>
<h2 id="3-面向对象-构造函数-重载"><a href="#3-面向对象-构造函数-重载" class="headerlink" title="3 面向对象-构造函数-重载"></a>3 面向对象-构造函数-重载</h2><p>构造函数重载与一般函数重载相同：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。</p>
<p><strong>注意</strong>：小括号中，参数个数和参数类型相同，但顺序不同也可以重载，因为java是强类型语言，是十分严谨的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    Person(<span class="keyword">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">     Person(String n,<span class="keyword">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">        name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-构造函数-内存图解"><a href="#4-面向对象-构造函数-内存图解" class="headerlink" title="4 面向对象-构造函数-内存图解"></a>4 面向对象-构造函数-内存图解</h2><p>与之前不一样的是，中间多了一步构造函数初始化。图解略</p>
<h2 id="5-面向对象-构造函数-细节"><a href="#5-面向对象-构造函数-细节" class="headerlink" title="5 面向对象-构造函数-细节"></a>5 面向对象-构造函数-细节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.上述二者函数功能一样，但用法不同，所以第二种需要存在。</p>
<p>2.一般函数中不能调用构造函数，构造函数可以调用一般函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.上述这是可以的，虽然构造函数前面不能加返回值，但这图中，它不当作构造函数，当作是一般函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.上述定义类的情况下， 在主函数中用下列语句创建对象</p>
<p>Person p = new Person();</p>
<p>编译是不行的。因为这种情况下，没有默认构造函数即空参构造函数，第二个Person函数是构造函数，故就没有默认构造函数，编译不成功。</p>
<p>5.构造函数中是可以有return的，但不多见。</p>
<h2 id="6-面向对象-this关键字-使用场景-amp-this原理"><a href="#6-面向对象-this关键字-使用场景-amp-this原理" class="headerlink" title="6 面向对象-this关键字-使用场景&amp;this原理"></a>6 面向对象-this关键字-使用场景&amp;this原理</h2><p>场景1：当成员变量和局部变量重名，可以用this关键字区分。</p>
<p>this ：代表对象，代表当前对象</p>
<p>​       this就是所在函数所属对象的引用。</p>
<p>​       <strong>简单说，哪个对象调用了this所在的函数，this就代表哪个对象，即拿到那个对象的地址。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(String n, <span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">		<span class="keyword">this</span>.age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入this关键字后，之前的内存图解重新解释：运行主函数，在栈里面划出内存给主函数，构建一个p对象，堆中也出现一块内存给这个对象，然后给这个空间赋予地址，内存存入两个变量，并对其进行默认初始化。然后调用构造函数，因此在栈中又划出内存给构造函数，然后出现this关键字，将堆中的内存地址与this绑定，这样就知道之后的变量赋值是赋给哪个内存的对应变量。然后将旺财赋给对应内存当中的name，赋值结束弹栈，地址赋给p。运行下一个指令，p.speak()。在栈内存中给出一块内存给speak函数，同样的在此中将调用的对象的相应地址与speak中的this绑定，输出语句，之后弹栈。</p>
<p><strong>这里注意</strong>：其实之前的写这些时都把this省去了，因为成员变量和局部变量没有重复。其实真正的写法是this.name，this.age。</p>
<p>场景2：一个类当中，所有的成员想要运行，就必须有对象调用。</p>
<p>想在构造函数中调用构造函数，也可以使用this，用this代替构造函数名，形式：this(…,…,…) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(String n)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(String n, <span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">this</span>(n);</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：凡是调用构造函数，this只能定义在构造函数的第一行，因为初始化动作要先执行。</p>
<h2 id="7-面向对象-this关键字-应用"><a href="#7-面向对象-this关键字-应用" class="headerlink" title="7 面向对象-this关键字-应用"></a>7 面向对象-this关键字-应用</h2><p>判断是否为同龄人</p>
<p>思路：对象是人，所以函数的参量是人。参量的个数可以是2，但是可以认为比较这个功能可以是人本身具备的，可以理解为一个人用这个功能来与另外一个人进行年龄的比较，只要调用即可，故这个函数的参量个数是一个。在函数里面，p1调用了这个函数，故this就代表着p1，p代表着p2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(<span class="keyword">int</span> a)</span><br><span class="line">        <span class="keyword">this</span>.age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == p.age; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-面向对象-static关键字-数据共享、特点"><a href="#8-面向对象-static关键字-数据共享、特点" class="headerlink" title="8 面向对象-static关键字-数据共享、特点"></a>8 面向对象-static关键字-数据共享、特点</h2><p>static特点</p>
<p>1.static是一个修饰符，用于修饰成员</p>
<p>2.static修饰的成员被所有的对象共享</p>
<p>3.static优先于对象存在。因为static的成员随着类的加载就已经存在了</p>
<p>4.static修饰的成员多了一种调用方式，即可以直接被类名所调用。</p>
<p>调用方式：类名.静态成员</p>
<p>5.static修饰的数据是共享数据，对象中的存储的是特有数据</p>
<h2 id="9-面向对象-static关键字-成员变量和静态变量的区别"><a href="#9-面向对象-static关键字-成员变量和静态变量的区别" class="headerlink" title="9 面向对象-static关键字-成员变量和静态变量的区别"></a>9 面向对象-static关键字-成员变量和静态变量的区别</h2><p>成员变量和静态变量的区别</p>
<p>1.两个变量的生命周期不一样。</p>
<p>成员变量随着对象的创建而存在，随着对象的被回收而释放</p>
<p>静态变量随着类的加载而存在，随着类的消失而消失</p>
<p>2.调用方式不同</p>
<p>成员变量只能被对象调用</p>
<p>静态变量可以被对象调用，还可以被类名调用。一般建议用类名调用。</p>
<p>3.别名不同</p>
<p>成员变量也称为实例变量</p>
<p>静态变量也称为类变量</p>
<p>4.数据的存储位置不同</p>
<p>成员变量数据存储在堆内存的对象中，所有也叫对象的特有数据</p>
<p>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据</p>
<h2 id="10-面向对象-static关键字-注意事项"><a href="#10-面向对象-static关键字-注意事项" class="headerlink" title="10  面向对象-static关键字-注意事项"></a>10  面向对象-static关键字-注意事项</h2><p>1.静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）</p>
<p>2.静态方法中不可以使用this或super等关键字</p>
<p>3.主函数是静态的</p>
<h2 id="11-面向对象-static关键字-main函数解析"><a href="#11-面向对象-static关键字-main函数解析" class="headerlink" title="11  面向对象-static关键字-main函数解析"></a>11  面向对象-static关键字-main函数解析</h2><p>public static void main(String[ ] args)</p>
<p>主函数特殊之处：</p>
<p>1.格式是固定的，上述每个单词都不能换成其他的。</p>
<p>2.被JVM所识别和调用</p>
<p>public：因为权限必须是最大的。</p>
<p>static：虚拟机调用主函数的时候不需要对象，直接用主函数所属类名调用即可。</p>
<p>void：主函数没有具体的返回值。</p>
<p>main：函数名，不是关键字只是一个JVM识别的固定的名字</p>
<p>String[ ] args：这是主函数的参数列表，是一个数组类型的参数，而且元素都是字符串类型。</p>
<p>args可以用其他替代</p>
<h2 id="12-面向对象-static关键字-内存图解"><a href="#12-面向对象-static关键字-内存图解" class="headerlink" title="12 面向对象-static关键字-内存图解"></a>12 面向对象-static关键字-内存图解</h2><p>先划分一片空间出来给栈、堆、方法区等。当StaticDemo2被执行时，类进内存，开辟空间。在非静态区存储StaticDemo2(){ }，静态区存储Static main()。非静态区都用this来调用对象。然后在栈空间开辟一个main函数空间。运行第一句话，Peson类开始加载，它就开始找在classpath下找有没有Person.class文件，找到后加载进内存，静态类进去静态区，其他类进去非静态区。然后在内存中寻找method方法，因为是静态，所以到静态区找。找到后在栈中开辟空间给method。然后开始执行method方法，执行结束后，弹栈。执行第二句话，开始创建对象，在堆中开辟空间，然后这句话的执行与前述相同。执行第三句话，show方法进栈，将地址赋值给this，执行语句，country在静态区找，name和age到对象中找，执行结束弹栈。然后主函数弹栈，之后虚拟机也结束。</p>
<h2 id="13-面向对象-static关键字-什么时候用"><a href="#13-面向对象-static关键字-什么时候用" class="headerlink" title="13  面向对象-static关键字-什么时候用"></a>13  面向对象-static关键字-什么时候用</h2><p>1.静态变量</p>
<p>当分析对象中所具备的成员变量的值都是相同的这时这个成员可以被静态修饰</p>
<p>只要数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。</p>
<p>如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。</p>
<p>2.静态函数</p>
<p>函数是否用静态修饰，就参考一点：该函数功能是否需要访问到对象中的特有数据</p>
<p>简单点说，从源代码看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的。如果不需要，就可以将该功能定义成静态的。</p>
<p>当然，也可以定义成非静态，但是非静态需要被对象调用，而仅创建对象调用非静态的，没有访问特有数据的方法，该对象的创建是没有意义的。</p>
<h2 id="14-面向对象-static关键字-静态代码块"><a href="#14-面向对象-static关键字-静态代码块" class="headerlink" title="14 面向对象-static关键字-静态代码块"></a>14 面向对象-static关键字-静态代码块</h2><p>静态代码块</p>
<p> static{</p>
<p>}</p>
<p>随着类的加载而执行，而且只执行一次。</p>
<p>作用：用于给类进行初始化。如果没有对象，那么就可以用这种方法进行初始化。</p>
<p>在静态代码块中可以对静态变量进行运算等操作。</p>
<p>它也先于主函数执行。</p>
<h2 id="15-面向对象-static关键字-构造代码块"><a href="#15-面向对象-static关键字-构造代码块" class="headerlink" title="15 面向对象-static关键字-构造代码块"></a>15 面向对象-static关键字-构造代码块</h2><p>构造代码块</p>
<p>{</p>
<p>}</p>
<p>特点：可以给所有对象进行初始化。每次创建对象的时候都会提前调用一次构造代码块</p>
<p>构造函数</p>
<p>是给对应的对象进行针对性的初始化。</p>
<p>面试：静态代码块、构造代码块、构造函数操作执行顺序</p>
<p>静态代码块先执行，然后构造代码块执行，最后构造函数执行。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象</title>
    <url>/2020/03/18/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-面向对象-概述"><a href="#1-面向对象-概述" class="headerlink" title="1 面向对象-概述"></a>1 面向对象-概述</h2><p>有两个思想，面向过程和面向对象。</p>
<p>面向过程</p>
<p>举例：大象装进冰箱</p>
<p>打开冰箱</p>
<p>存储大象</p>
<p>关闭冰箱</p>
<p>对于面向过程思想，强调的是过程（动作），比如C语言就是面向过程。</p>
 <a id="more"></a>

<p>面向对象</p>
<p>举例：大象装进冰箱</p>
<p>冰箱打开</p>
<p>冰箱存储</p>
<p>冰箱关闭</p>
<p>只要找到冰箱这个实体就能完成后面的动作。</p>
<p>对于面向对象思想，强调的是对象（实体），比如java、C++、C#就是面向对象。</p>
<p>特点：</p>
<p>1.面向对象就是一种常见的思想，符合人们的思考习惯。</p>
<p>2.面向对象的出现，将复杂的问题简单化。</p>
<p>3.面向对象的出现，让曾经在过程中的执行者，变成了对象中的指挥者。</p>
<h2 id="2-面向对象-举例"><a href="#2-面向对象-举例" class="headerlink" title="2 面向对象-举例"></a>2 面向对象-举例</h2><p>Java中万物皆可作为对象。（这是一种境界，面试的时候不要说）</p>
<p>有对象用对象，没对象造对象，不断的去维护各个对象之间的关系。</p>
<p><strong>使用面向对象的三个特征：封装、继承、多态</strong></p>
<p>例子：人开门</p>
<p>对象：人和门，名词提炼法找对象</p>
<p>动作/功能赋予：开这个是门的功能，哪个对象最清楚动作就赋予给哪个对象</p>
<h2 id="3-类与对象的关系"><a href="#3-类与对象的关系" class="headerlink" title="3 类与对象的关系"></a>3 类与对象的关系</h2><p>类</p>
<p>Java通过类的形式来对现实生活中的事物进行描述。</p>
<p>对于事物描述通常只关注两方面：属性，行为。</p>
<p>只要明确该事物的属性和行为并定义在类中即可</p>
<p>对象</p>
<p>其实就是该类事物实实在在的个体。</p>
<p>类与对象之间的关系</p>
<p>类:事物的描述</p>
<p>对象：类的实例。在java中通过new来创建的</p>
<h3 id="4-类与对象的体现"><a href="#4-类与对象的体现" class="headerlink" title="4 类与对象的体现"></a>4 类与对象的体现</h3><p>描述小汽车</p>
<p>分析：</p>
<p>1.属性</p>
<p>轮胎数</p>
<p>颜色</p>
<p>2.行为</p>
<p>运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Car c = <span class="keyword">new</span> Car();</span><br><span class="line">		c.num = <span class="number">4</span>;</span><br><span class="line">		c.color = <span class="string">"red"</span>;</span><br><span class="line">		c.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义类其实就是在定义类中的成员</p>
<p>成员:成员变量、成员函数。前者对应变量，后者对应行为。</p>
<p>成员变量定义在类中，其作用范围是最大的。</p>
<p>Car类中没有定义主函数，它专门用来描述某一事物，不需要独立运行</p>
<p>如果被用到才需要独立运行。当然，也可以让其独立运行，在类中定义主函数即可。</p>
<p>要使用对象中的内容，可以通过 <strong>对象.成员</strong> 的形式完成调用。</p>
<h2 id="5-面向对象-对象的内存体现"><a href="#5-面向对象-对象的内存体现" class="headerlink" title="5 面向对象-对象的内存体现"></a><strong>5 面向对象-对象的内存体现</strong></h2><p>在主函数中创建car对象内存过程:<br>因为定义的c是局部变量，所以c在栈中会占用内存。然后定义的是对象，故打开堆内存，占用内存并赋予一个地址，在里面定义变量，同时进行默认初始化。接下来给变量赋予数值。找到c，然后根据地址找到堆内存中位置，并赋予数值。<br>一个对象封装着其所对应的数据，比如num、color。</p>
<h2 id="6-面向对象-成员变量和局部变量的区别"><a href="#6-面向对象-成员变量和局部变量的区别" class="headerlink" title="6 面向对象-成员变量和局部变量的区别"></a>6 面向对象-成员变量和局部变量的区别</h2><p>成员变量和局部变量的区别</p>
<p>1.成员变量定义在类中，整个类中都可以访问。</p>
<p>   局部变量定义在函数、语句、局部代码块中，只在所属的区域有效。</p>
<p>2.成员变量存在于堆内存的对象中</p>
<p>   局部变量存在于栈内存的方法中</p>
<p>3.成员变量随着对象的创建而存在，随着对象的消失而消失</p>
<p>   局部变量随着所属区域的执行而存在，随着所属区域的结束而释放</p>
<p>4.成员变量都有默认初始化值</p>
<p>   局部变量没有默认初始化值</p>
<h2 id="7-面向对象-成员变量和局部变量的同名-amp-显示初始化"><a href="#7-面向对象-成员变量和局部变量的同名-amp-显示初始化" class="headerlink" title="7 面向对象-成员变量和局部变量的同名&amp;显示初始化"></a>7 面向对象-成员变量和局部变量的同名&amp;显示初始化</h2><p>如果在类中描述时变量同名，则运行时先在哪个内存中找到这个变量就显示哪个。上述例子就是先打开是栈内存，并找到num。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Car c = <span class="keyword">new</span> Car();</span><br><span class="line">		c.color = <span class="string">"red"</span>;</span><br><span class="line">		c.run();</span><br><span class="line">		System.out.println(c.num + <span class="string">"..."</span> + c.color);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上述打印结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5...red</span><br><span class="line">6...red</span><br></pre></td></tr></table></figure>

<p>显示初始化</p>
<p>可以在类中的描述直接赋值，这与继承有关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-面向对象-类类型参数"><a href="#8-面向对象-类类型参数" class="headerlink" title="8 面向对象-类类型参数"></a>8 面向对象-类类型参数</h2><p> 类类型的变量一定指向对象，要不就是null。</p>
<h2 id="9-面向对象-匿名对象"><a href="#9-面向对象-匿名对象" class="headerlink" title="9 面向对象-匿名对象"></a>9 面向对象-匿名对象</h2><p>匿名对象：</p>
<p>没有名字的对象。</p>
<p>new Car();//匿名对象其实就是定义对象的简写格式。</p>
<p>使用方式：</p>
<p>1.当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。</p>
<p>new Car().run();</p>
<p>2.匿名对象可以作为实际参数进行传递。</p>
<p>show(new Car());</p>
<h2 id="10-基本数据类型和引用数据类型参数传递图解"><a href="#10-基本数据类型和引用数据类型参数传递图解" class="headerlink" title="10 基本数据类型和引用数据类型参数传递图解"></a>10 基本数据类型和引用数据类型参数传递图解</h2><p>基本数据类型参数传递不用涉及到堆，而引用数据类型涉及到堆。</p>
<p>图解略。</p>
<h2 id="11-面向对象-封装-代码实例、思想"><a href="#11-面向对象-封装-代码实例、思想" class="headerlink" title="11 面向对象-封装-代码实例、思想"></a>11 面向对象-封装-代码实例、思想</h2><p>封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
<p>Java中最小的封装体是函数。类，框架等都是封装体。</p>
<p>好处：</p>
<p>将变化隔离</p>
<p>便于使用</p>
<p>提高重用性</p>
<p>提高安全性</p>
<p>封装原则：</p>
<p>将不需要对外提供的内容都隐藏起来</p>
<p>把属性都隐藏，提供公共方法对其访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Person类中的age是私有的，所以在主函数中不能使用直接调用age，只能利用getAge函数来获得。</p>
<p><strong>Private（私有关键字）</strong>:是一个权限修饰符，用于修饰成员。私有的内容只在本类中有效。</p>
<p>常用之一：将成员变量私有化，对外提供对应的set，get。</p>
<p>​                   方法对其进行访问。提高数据访问的安全性。</p>
<p><strong>注意</strong>：私有仅仅是封装的一种体现而已。不私有也能进行封装。</p>
<p>​           私有是封装，但封装不是私有。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-二维数组</title>
    <url>/2020/03/18/JavaSE-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1.定义方式"></a>1.定义方式</h2><p>第一种命名格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[][] arr&#x3D;new int [3][2];</span><br></pre></td></tr></table></figure>

<p>二维数组可以理解为一个大箱子，里面有若干个小箱子。箱子里面又有若干个格子即元素。</p>
<a id="more"></a>

<p>二维数组定义过程如下：</p>
<p>首先在栈内存中开辟临时内存，定义一个arr。arr使得在堆内存中开辟内存来储存arr中的数组（这里数组指的是第一个中括号的数组），并赋予一个地址，进行初始化。因为这时候初始化的东西是引用类型的数据，所以初始化为null。然后继续为数组的第二个中括号开辟内存，也就是底下三个，并赋予各自的地址，初始化，这里初始化的内容是int类型的数，所以为0。然后这三个内存对应的地址填到刚刚的null对应的格子里，这样完成数组定义。</p>
<p>第二种命名格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[] [] arr&#x3D;new int [3][];</span><br></pre></td></tr></table></figure>

<p>这种定义过程与上述类似，只是它是只定义到二维数组，也就是第一个中括号处。如果要进行二维数组中的每一个维数组也就是第二个中括号的定义，则需要再输入定义语句。所以一开始，二维数组里面存的地址为null。</p>
<p>第三种定义方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[][]arr &#x3D;&#123;&#123;2,3,1&#125;,&#123;2,5,2,1&#125;,&#123;5,7&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是直接输入数字。</p>
<p>打印二维数组的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(arr.length);<span class="comment">//打印二维数组的长度，相当于行数</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>].length);<span class="comment">//打印二维数组中角标为0的一维数组的长度，相当于列数</span></span><br></pre></td></tr></table></figure>

<p>二维数组遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = [<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-数组</title>
    <url>/2020/03/17/JavaSE-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>定义：同一种类型数据的集合。其实数组就是一个容器。<br>好处：可以自动给数组中的元素从0开始编号，方便操作这些元素。<br>格式：元素类型[ ] 数组名=new 元素类型[元素个数或数组长度]<br>数组索引从0开始，这里MySQL数据库索引是从1开始。</p>
<a id="more"></a>

<h2 id="2-内存空间的划分、栈内存、堆内存内存的划分"><a href="#2-内存空间的划分、栈内存、堆内存内存的划分" class="headerlink" title="2 内存空间的划分、栈内存、堆内存内存的划分"></a>2 内存空间的划分、栈内存、堆内存内存的划分</h2><p>1.寄存器：cpu处理</p>
<p>2.本地方法区：所在系统相关。</p>
<p>3.方法区：目前涉及不到</p>
<p>4.栈内存：</p>
<p>存储的都是局部变量</p>
<p>而且变量所属的作用域一旦结束，该变量就自动释放。</p>
<p>5.堆内存：</p>
<p>存储的是数组和对象（其实数组也是对象），凡是new建立的都在堆中。</p>
<p>堆里面存的都是实体。实体就是实实在在存储的个体，用于封装一个或多个数据。</p>
<p>只要看到new，就会在堆里面建立新的空间</p>
<p>特点</p>
<p>1.每一个实体都有一个首地址值</p>
<p>2.堆内存中的每一个变量都有默认初始化值，根据类型不同而不同，整数是0，小数是0.0或者0.0f，boolean是false，char是’\u0000’，字符串String类型是null。</p>
<p>3.释放方式为垃圾回收机制。</p>
<h2 id="3-内存图解（略）"><a href="#3-内存图解（略）" class="headerlink" title="3  内存图解（略）"></a>3  内存图解（略）</h2><h2 id="4-数组常见问题"><a href="#4-数组常见问题" class="headerlink" title="4  数组常见问题"></a>4  数组常见问题</h2><p>ArrayIndexOutOfBoundsException</p>
<p>NullPointerException</p>
<h2 id="5-数组其他定义格式"><a href="#5-数组其他定义格式" class="headerlink" title="5  数组其他定义格式"></a>5  数组其他定义格式</h2><p>格式2：元素类型[ ] 数组名=new 元素类型[ ]{元素，元素，…}；</p>
<p>​       int[ ] arr=new int[ ]{23,13,123,21};需要一个容器，存储已知的具体数据。</p>
<p>格式3：元素类型[ ] 数组名={元素，元素，…}；</p>
<p>​       int[ ] arr={12,21,31,12};</p>
<h2 id="6-常见操作-遍历"><a href="#6-常见操作-遍历" class="headerlink" title="6  常见操作-遍历"></a>6  常见操作-遍历</h2><p>对数组操作最基本的动作是存和取。</p>
<p>​       核心思想：对角标的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++)&#123;<span class="comment">//正向遍历</span></span><br><span class="line">    System.out.println(arr[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = arr.length - <span class="number">1</span>; x &gt;= <span class="number">0</span>; x--)&#123;<span class="comment">//反向遍历</span></span><br><span class="line">    System.out.println(arr[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-常见操作-最值"><a href="#7-常见操作-最值" class="headerlink" title="7  常见操作-最值"></a>7  常见操作-最值</h2><p>获取数组中的最大值</p>
<p>​    思路：</p>
<p>​    1.需要进行比较。并定义变量记录每次比较后较大值</p>
<p>​    2.对数组中的元素进行遍历取出，和变量中记录的元素进行比较。</p>
<p>​       如果遍历到的元素大于变量中记录的元素，就用变量记录住该大的值。</p>
<p>​    3.遍历结果，该变量记录就是最大值。</p>
<p>​    定义的函数中，初始化变量可以是数组中的元素，也可以是0.前者就是比较元素，后者是因为数组中存在角标，角标和数组中的数字是一一对应的，所以也可以用0来初始化，不会担心存在负数的情况。</p>
<p>代码略</p>
<h2 id="8-常见操作-选择排序"><a href="#8-常见操作-选择排序" class="headerlink" title="8 常见操作-选择排序"></a>8 常见操作-选择排序</h2><p>方法：第一轮，比较整个数组即N次，将最小的数放置在第一个位置。第二轮比较N-2次，将第二小的数放置在第二个位置，这样比较N轮完成排序。时间复杂度：O(N2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = arr[i];</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; arr[j])&#123;</span><br><span class="line">                num = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-常见操作-冒泡排序"><a href="#9-常见操作-冒泡排序" class="headerlink" title="9  常见操作-冒泡排序"></a>9  常见操作-冒泡排序</h2><p>方法：先将数组中第一个数和第二数比较，较大的在后面，接着第二个和第三个排序，较大的排在第三个，后面依次类推，直到最后一个，这样最后一个数就是最大的。紧接着用同样的方法将第二大的数排在倒数第二个位置。时间复杂度：O(N2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-查找、折半查找（略）"><a href="#10-查找、折半查找（略）" class="headerlink" title="10 查找、折半查找（略）"></a>10 查找、折半查找（略）</h2><h2 id="11进制转换、查表法"><a href="#11进制转换、查表法" class="headerlink" title="11进制转换、查表法"></a>11进制转换、查表法</h2><p>在计算机中完成10进制到16进制的转换，具体步骤如下：<br>在计算机中，表现形式为二进制，然后开始四个四个与1111进行“与”计算，因为“与”计算可以提取想要的位数。当最底的4位提取完毕后，进行下一步，就将其移4位，进行下一个4位数的提取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0000-0000 0000-0000 0000-0000 0011-1100  60</span><br><span class="line">&amp;0000-0000 0000-0000 0000-0000 0000-1111</span><br><span class="line">-----------------------------------------</span><br><span class="line"> 0000-0000 0000-0000 0000-0000 0000-1100  12即C</span><br><span class="line"> &gt;&gt;&gt;  0000-0000 0000-0000 0000-0000 0011-1100  60&gt;&gt;&gt;4</span><br><span class="line">&amp;0000-0000 0000-0000 0000-0000 0000-1111</span><br><span class="line">-----------------------------------------</span><br><span class="line"> 0000-0000 0000-0000 0000-0000 0000-0011  3</span><br><span class="line"> 最后得到3C</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> pos = arr.length;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num &amp; <span class="number">15</span>;</span><br><span class="line">        arr[--pos] = chs[temp];</span><br><span class="line">        num = num &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; arr.length; i++)&#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化成其他进制类似。</p>
<p>除了自己写之外，在Java中有对应的内置函数来实现，如Integer.toBinaryString(int num);</p>
<p>什么时候使用数组</p>
<p>​    如果数据出现了对应关系，而且对应关系的一方是有序的数字编号。并作为角标使用</p>
<p>​    这时就必须要想到数组的使用</p>
<p>​    就可以将这些数据存储在数组中</p>
<p>​    根据运算的结果作为角标直接去查数组中对应的元素即可。</p>
<p>​    这种方式：<strong>称为查表法</strong></p>
<p>该过程用到了一些思想，值得去回味。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-流程控制语句</title>
    <url>/2020/03/14/JavaSE-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>1.程序流程控制-语句if<br>程序流程控制有四种结构：顺序结构、判断结构、选择结构、循环结构。<br>判断结构-if语句<br>三种格式<br>第一种<br>if(条件表达式)<br>{<br>    执行语句;<br>    }</p>
<a id="more"></a>
<p><strong>注意</strong>：if语句要明确控制范围，用大括号来控制，但当if语句中控制语句是单条语句时大括号可以省略。如果if语句没写大括号，就只能控制离它最近的单条语句。</p>
<p>这里单条语句不是指单行语句。如下图中，红色方框可以看成一个单条语句，所以外面的两个红圈圈起来的大括号可以省略。</p>
<p>第二种<br>if(条件表达式)<br>{<br>    执行语句;<br>}else{<br>    执行语句;<br>}</p>
<p>注意：三运运算符就是if else 语句简写格式。简写格式是运算符，必须要有运算结果，否则不能运行。简写格式当ifesle运算后有一个具体的结果时，可以简化成三元运算符。<br>第三种<br>if(条件表达式)<br>{<br>    执行语句;<br>}else if(条件表达式){<br>    执行语句;<br>}<br>…<br>else{<br>    执行语句;<br>}<br>这里再来一个括号省略的例子</p>
<p>2.局部代码块<br>任何在大括号之间的叫做代码块，加了if，就是if代码块，还有主函数代码块，类代码块如：</p>
<p>如果前面什么也没有，就叫局部代码块。</p>
<p>局部代码块可以定义局部变量的生命周期，可以有效腾出内存空间。</p>
<p>3.语句-switch<br>选择结构-switch<br>switch(表达式)<br>{<br>    case 取值1:<br>    break;<br>    case 取值2:<br>    执行语句;<br>    break;<br>    …<br>    default:默认<br>    执行语句;<br>    break;<br>}<br><strong>Switch语句只支持byte、short、int、char四种类型值</strong>。<br>备选答案是无序的，不是某个选择一定要放在第几个，但是执行是有顺序的。必须先执行case再执行default。<br>Switch结束方式有两种，一种是break结束，一种是执行到大括号结束，所以在最后的选择中，break是可以省略的。</p>
<p>若是这种情况，default和case4没有break，运行过程是先case4、case1、case3判断，然后不属于就来到default，判断对了之后，由于没有break，就继续执行可执行的语句。因为case是执行过，不会再执行，所以就直接执行System.out.printIn，直到遇到break，所以最后结果是：</p>
<p>3.switch与if的区别<br>If：<br>1.对具体的值进行判断<br>2.对区间进行判断<br>3.对运算结果是boolean类型的表达式进行判断</p>
<p>Switch:<br>1.对具体的值进行判断<br>2.值的个数通常的是固定的<br>对于几个固定的值判断建议使用switch语句，因为switch语句会将具体的答案都加载进内存，效率相对高一些。</p>
<p>4.while、do while语句<br>循环结构-while、do while、for<br>While语句<br>while(条件表达式)<br>{<br>    执行语句;<br>}</p>
<p>Do while<br>do<br>{<br>    执行语句;<br>}<br>while(条件表达式);</p>
<p>do while语句特点：无论条件是否满足，循环体至少执行一次。</p>
<p>5.while练习-计数器思想<br>需求：求1~100中6的倍数有几个</p>
<p>6.for语句<br>for(初始化表达式;循环条件表达式;循环后的操作表达式)<br>{<br>    执行语句;(循环体)<br>}</p>
<p>其中需要明白for循环基本运行过程。</p>
<p>有时候也会有上述形式，需要注意不要固化思维。</p>
<p>7.for和while的区别<br>1.for和while可以互换。<br>2.格式上的不同，在使用上有点小区别。<br>如果需要通过变量来对循环进行控制，该变量只作为循环增量的存在，区别就体现出来。<br>即在for括号里面进行的初始化表达式只在for循环中使用，一旦for循环结束，这个量就从内存中移除。</p>
<p>有时候会用到无限循环，所以给出两者无限循环的最简单的表达式</p>
<p>for的三个表达式都可以不写。头尾两个不写就是没有，中间的不写就是默认为true。<br>使用循环结构的场景：<br>当对某些代码执行很多次时，使用循环结构完成。<br>当对一个条件进行一次判断时，可以使用if语句。<br>当对一个条件进行多次判断时，可以使用while语句。<br>注意：1.在使用循环时，一定要明确哪些语句要参与循环，哪些不需要。<br>    2.循环通常情况下需要定义条件和控制次数。</p>
<p>8.for循环嵌套练习</p>
<p>9.语句-break&amp;continue<br>break:跳出<br>break作用范围：要么是switch语句，要么是循环语句。<br>注意：当break语句单独存在时，下面不要定义其他语句，因为执行不到。<br>如：</p>
<p>这种情况并不是break控制if语句，因为break只能控制switch和循环。这里它只是作为if的一个执行，当循环到x=1时，就执行break。</p>
<p>break跳出所在的当前循环<br>如果出现了循环嵌套，break想要跳出指定的循环，可以通过标号来完成。</p>
<p>Continue:<br>continue:结束本次循环，继续下次循环<br>作用范围：循环结构。<br>如果continue单独存在时，下面不要有任何语句，因为执行不到。</p>
<p>这种情况与break类似，同样执行不到下面语句。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-运算</title>
    <url>/2020/03/14/JavaSE-%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>基本的运算，运算两端必须是同一类型数值。<br>1.类型提升和强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">x = x + b;</span><br></pre></td></tr></table></figure>

<p>如果两端是数值型，不是同一类型也可以计算。因为计算时会把不同类型转换成相同类型进行计算，以占用内存比较大的为主。占用内存较小的会进行自动类型提升，如从一个字节提升为四个字节，这个过程是自动进行，最后得结果类型与内存占用较大的一致。如上述情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">b = b + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>这种情况进行编译时会报错，说是缺少精度。因为4是默认为int型，在计算完b=b+4时，b的类型变为int型，而不是byte，所以会报错。如果非要是byte型，则进行强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">b = (<span class="keyword">byte</span>)(b + <span class="number">125</span>);</span><br></pre></td></tr></table></figure>

<p>上面b的结果是-126。它会将高位的字节略去不要，留下低位字节。如果计算完的数在高位字节中有占用，则计算出来的结果不会有高位字节，结果会出现错误。所以强制类型转换会有风险。</p>
<a id="more"></a>
<p>2.字符类型运算过程<br>(‘a’ + 1)<br>对于括号里面的运算，是可以进行编译的，且得出来的结果是98。这里要首先知道存在一个二进制的生活中文字的对应关系表，也就是编码表，简称ASCII。这个表里面只有英文字母，数字和一些符号与二进制的对应关系。其中对应的二进制就是01100001，十进制中也就是97。在上述的计算中，其过程是首先将a转化为编码表里对应的二进制数（占两个字节）然后1是默认为int类型，占4个字节，将a进行类型升级，二者再相加，得到结果98。若想得到字符，则在前面加char，进行强制转换。<br>(char)(‘a’ + 1)<br>A对应65，a对应97,0对应48。<br>中文和二进制也有一一对应的关系，其形成的表叫做GB2312。后期扩展成GBK，之后又扩展成GB18030。<br>存在一个Unicode码表，含有国际上各个文字的码表。基本上都是有国际标准码表来完成。</p>
<p>3.类型运算细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">7</span>;</span><br><span class="line">b = b1 + b2;</span><br></pre></td></tr></table></figure>

<p>这种情况下，编译器会报错，说是缺少精度，应该转成int类型，请问原因（<strong>面试题</strong>）<br>在一开始中，byte b=4，系统检测4，发现int型的4是可以用byte表示，于是默认将int型的4强制转换成byte型。但是在上述代码中b=b1+b2，b1和b2都是变量，就算前面赋值，系统也是检测是变量，变量的话就不知道值是什么，如果还是强行转换成byte类型的话，是有可能装不下的，所以要转换成int类型。<br>如果int运算中也超了，编译是可以的，但是结果是，本来int最多是32位，超出的话会到33位及以上，这是系统就会把33位及以上的位数舍弃，只剩下32位，所以只显示32位的结果。</p>
<p>4.算术运算符和赋值运算符<br>算术运算符有<br> ‘+’- * /    java是强位型语言，其中两个整数除法运算会自动转换，舍弃小数点后的数字。<br>%（取余，模运算）  模运算，5%2是1,-5%2是-1,5%-2是1，所以模运算最后结果的符号看被模数，被模数是负，结果就是负。<br>+（连接） 任何数据用+与字符串相加，都是相连接。</p>
<p>++（自增，在原有数据基础上+1，再赋值给原有数据）<br>a=3；b=a++；这时的运算过程是a要自增，在自增之前，若参与了其他运算，先进行了a自己值的保留值的动作，再自增，再将保留值进行运算。<br>int i=3;i=i++;这时i的值是3。<br>–同上<br>赋值运算符 =、+=、-=、/=、*=、%=<br>int a=4;a+=2;该意思为左边等于左右两边的和即a=4+2=6<br>+=也是赋值运算符，也有做转换动作，底层会自动做强转。</p>
<p>5.比较运算符&amp;逻辑运算符<br>比较运算符<br>比较运算符运算完必定有结果，它的运算结果要么是true，要么是false。<br>比较运算符有：==、!=、&lt;、&gt;、&lt;=、&gt;=、instanceof(检查是否是类的对象，”hello” instanceof String   true)</p>
<p>逻辑运算符<br>逻辑运算符用于连接两个boolean类型的表达式<br>例：<br>&amp;与</p>
<p>|或</p>
<p>^异或<br>和或有些不同，两边都是true或false结果的话，结果是false，即两边比较结果都是一样的话是false，不同则是true。</p>
<p>！非<br>判断事物的另一面<br>!true=false; !false=true; !!true=true<br>&amp;&amp;双与<br>运算结果和单与相同，过程不同，双与只要符号左边一旦为假，则不再执行右边的运算，运算为假。单与则是无论左边的运算结果是什么，右边都参与运算。（<strong>面试会涉及</strong>）<br>||双或<br>运算结果和单或相同，过程不同，双或只要符号左边一旦为真，则不再执行右边的运算，运算为真。单或则是无论左边的运算结果是什么，右边都参与运算。</p>
<p>6.位运算符<br>位运算符有：&lt;&lt;左移，&gt;&gt;右移，&gt;&gt;&gt;无符号右移，&amp;与运算，!或运算，^异或运算，~反码<br>位运算是直接对二进制进行运算<br>这里注意<br>与运算符可以保留想要的后几位数</p>
<p>或运算符可以保留有效位即1</p>
<p>异或运算符中，一个数异或同一个数两次，结果还是这个数，可以用来加密。</p>
<p>7.移位运算符<br>左移&lt;&lt;：<br>如3&lt;&lt;2，将3左移两位，先把3表示成二进制形式，然后左移两位，结果是12。同理3&lt;&lt;3，3左移三位，结果是24，可以发现左移几位就是该数据乘以2的几次方。左移可以完成2的次幂运算。<br>右移&gt;&gt;：<br><strong>注意</strong>：右移后高位出现的空位，原来高位是什么就用什么补这个空位。如负数前面是1则就用1来补充。然后右移几位，其实就是该数据除以2的几次幂。<br>无符号右移&gt;&gt;&gt;：<br>数据进行右移时，高位出现的空位，无论原高位是什么，空位都用0补。</p>
<p>8.位运算符练习<br>1.最有效的方式算出2乘以8等于几？<br>想要运算高效，一般选用位运算。直接对二进制位上的数据进行操作。<br>所以这道题我们观察到8是2的三次方，可以直接使用左移位运算，即2&lt;&lt;3，这样运算的效率更高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>2.对两个整数变量进行互换（不需要第三方变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c = a; a = b; b = c;</span><br></pre></td></tr></table></figure>

<p>这种用了第三方变量，一般在开发时都是使用这种方法，因为能够提高阅读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>


<p>但开发时不用，因为阅读性低</p>
<p>9.三元运算符<br>三个元素参与运算的符号。无论表达形式什么样，都是运算符。只要是运算符，肯定就有结果<br>格式<br>(条件表达式) ? 表达式1 : 表达式2；<br>条件为true 结果是表达式1；条件为false结果是表达式2；<br>例：获取两个整数中较大的整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>,y = <span class="number">4</span>, z;</span><br><span class="line">z = (x &gt; y) ? x : y;</span><br></pre></td></tr></table></figure>


<p>获取三个整数中较大的整数</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-函数</title>
    <url>/2020/03/13/JavaSE-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>1 函数-定义<br>定义：定义在类中的具有特定功能的一段独立小程序。函数也称方法。</p>
<p>2 函数-格式<br>定义函数的格式：<br>    修饰符 返回值类型 函数名（参数类型 形式参数1，参数类型 形式参数2，…）<br>    {<br>        执行语句；<br>        return 返回值；<br>    }</p>
<a id="more"></a>
<p>函数名若是用到多个单词，则第一个单词首字母小写，后面的单词首字母大写。<br>形式参数也可以没有。<br>Return除了返回值的作用还有结束函数的作用。</p>
<p>3 函数-细节-void<br>特殊情况：<br>    功能没有具体的返回值。<br>    这时return的后面直接用分号结束。<br>    返回值类型怎么体现？因为没有具体值，所以不可以写具体的数据类型。<br>    在JAVA中，只能用一个关键字来表示这种情况。关键字是：void<br>    总结：没有具体返回值时，返回值类型用void来表示<br>注意：如果返回值类型是void，那么函数中的return语句可以省略不写。</p>
<p>4、5 函数-细节-错误格式、定义思想错误<br>函数的特点：<br>定义函数可以将功能代码进行封装<br>便于对该功能进行复用<br>函数只有被调用才会被执行<br>函数的出现提高了代码的复用性<br><strong>注意</strong>：<br>(1)函数中只能调用函数，不可以在函数内部定义函数。如下述代码是不行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	myPrint();	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)定义函数时，函数的结果应该返回给调用者，交由调用者处理。<br>如果想要在System.out.println(函数)中有结果，则函数不能是void类型，因为void类型没有返回值，没有输出结果。</p>
<p>6、7 、8函数-两个明确、练习<br>通过两个明确来完成<br>    明确1：这个功能的结果是什么？<br>    是和。是功能的结果，所以该功能的返回值类型是int。<br>    其实就是在明确函数的返回类型。<br>    明确2：这个功能实现过程中是否需要未知内容参与运算？<br>    有，加数和被加数。这就是函数的参数列表（参数的个数、参数类型）<br>    其实就是在明确参数列表<br><strong>注意</strong>：返回值类型和参数类型没有直接关系。</p>
<p>9 函数-内存加载过程<br>Java虚拟机先运行main函数，当遇到新函数或方法时，调用其，开始占用内存空间。等函数或方法调用结束，就不再占用内存，继续main函数，知道main函数执行完毕，也移出内存。<br>在这里提到栈的概念<br>特点：先进后出，先进来的放在栈底。</p>
<p>10 函数-重载<br>概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。<br>特点：与返回值类型无关，只看参数列表。如下述代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java是严谨性语言，如果出现的调用的不确定性，会编译失败。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-语言基础</title>
    <url>/2020/03/13/JavaSE-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>任何高级语言的基础组成<br>关键字、运算符、标识符、语句、注释、函数、常量与变量、数组</p>
<p>01 关键字</p>
<p>被赋予特殊java含义的单词<br>用于定义数据类型的关键字<br>class、interface、byte、short、int、long、float、double、char、boolean、void<br>用于定义数据类型值的关键字<br>true、false、null<br>用于定义流程控制的关键字<br>if、else、swich、case、default、while、do、for、break、continue、return<br>一般情况下，关键字全部是小写</p>
<a id="more"></a>
<p>02 标识符<br>在程序中自定义的一些名称。<br>由26个英文字母大小写，数字：0-9，符号：_$组成<br>定义符合标识符规则：<br>1.数字不可以开头<br>2.不可以使用关键字<br>Java中严格区分大小写。凡是名称都可以算是标识符，比如main函数中的main。</p>
<p>03 注释<br>用于注解说明程序中的文字。<br>单行注释：//说明文字。<br>多行注释：/*<br>          说明<br>          文字。<br>          <em>/<br>文档注释：java特有注释<br>/**<br>文档注释。<br><em>/<br>文档注释可以被javadoc提取，将文字和代码生成一个网页，形成程序说明书。<br>单行注释里面可以嵌套单行注释，即//asd//asd<br>单行注释里面可以嵌套多行注释，即//asd/</em>asd</em>/asd<br>多行注释里面可以嵌套单行注释，即/<em>asd//asd <em>/<br>多行注释里面可以嵌套多行注释，即/</em>asd/*asd</em>/，这里注意后面只有一个*/。<br>注释文字在编译时不编译进去。</p>
<p>04 注释的应用<br>工作或者面试时写代码，一定要添加注释。<br>以后一开始写程序时先写多行注释。</p>
<p>05 常量<br>表示不能改变的数值<br>分类：</p>
<ol>
<li>整数常量。所有整数 如2</li>
<li>小数常量。所有小数 如1.2</li>
<li>布尔（boolean）型常量。较为特殊，只有两个数值：true false</li>
<li>字符常量。将一个数字字母或者符号用单引号(‘’)标识 如‘2’‘a’</li>
<li>字符串常量。将一个或者过个字符用双引号(“”)标识 如“212”“asd”</li>
<li>null常量（空常量）。只有一种数值就是null。</li>
</ol>
<p>06 进制的由来<br>对于整数有四种表现形式<br>二进制：0.1，满2进1<br>八进制：0-7，满8进1，用0开头表示<br>十进制：0-9，满10进1<br>十六进制：0-9，A-F，满16进1.用0x开头表示</p>
<p>将八个二进制位成一个数据存储最小单元，称之为byte字节<br>每一个二进制位叫做bit位<br>1k=1024字节；<br>由于这样8个表示太麻烦，于是让三个bit位为一组，为八进制，四个为一组为16进制</p>
<p>07 进制转换<br>由于这样8个表示太麻烦，于是让三个bit位为一组，为八进制，四个为一组为16进制<br>这也是二进制转换成八进制和十六进制的比较快速的转换方法，例如<br>二进制10101110<br>转换成八进制，先以三个为一组，个数不够前面加0。再分别算出每组二进制对应的十进制，然后便得出八进制，如<br>010-101-110<br> 2   5   6即八进制表示就是0256<br>转换成十六进制<br>1010-1110<br> 10   14  即十六进制表示就是0xAE<br>结论：<br>八进制数，其实就是二进制位，3个二进制位为一个八进制<br>十六进制，其实就是二进制位，4个二进制位为一个十六进制</p>
<p>十进制转化成二进制<br>用2除取余数的方法，再从下往上看。</p>
<p>08 负数的进制<br>负数的二进制就是这个数的正数的二进制取反，加1<br>如-6<br>0000-0110 取反 1111-1001 加1即+0000-0001<br>等于1111-1010<br><strong>凡是负数，其二进制的最高位是1</strong></p>
<p>09 变量的介绍<br>概念：变量是内存中的一个存储区域，用来存储不确定的数据。当数据不确定时就要使用变量。<br>      该区域有自己的名称（变量名）和类型（数据类型），不同类型的数据不能放在同一区域<br>      该区域的数据可以在同一类型范围内不断变化<br>目的：用来不断地存放同一类型的常量，并可以重复使用。<br><strong>注意</strong>：变量的作用范围<br>      初始化值<br>定义变量的格式：<br>数据类型 变量名=初始化值<br>注：格式是固定的，记住格式，以不变应万变<br>Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。<br>数据类型分为基本数据类型和引用数据类型<br>基本数据类型分为数值型、字符型和布尔型<br>数值型有整数类型（byte,short,int,long）<br>Byte：字节，内存中占一个八位，-27到27-1，即-128至127<br>Short：短整型，内存从占两个字节即16个比特位，-215到215-1<br>Int：内存占4个字节，-2^31到2^31-1<br>Long：长整型，内存占8个字节<br>一般情况下，整数默认为int类型。<br>浮点类型（float,double）<br>Float：单精度，由4个字节表示<br>Double：双精度，由8个字节表示<br>一般情况下，小数默认为double类型。<br>字符型（char）：取值范围0到65535，即两个字节。‘12’不能存放，但是一个中文比如你好的你，可以存放。<br>布尔型（boolean）：<br>以上8个都是关键字。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的一些基本操作</title>
    <url>/2020/03/06/hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="创建新文章并部署到远端"><a href="#创建新文章并部署到远端" class="headerlink" title="创建新文章并部署到远端"></a>创建新文章并部署到远端</h2><p>1.执行 hexo new[layout] 文章名 即可<br>layout为布局，Hexo有三种默认布局：post、page和draft，默认为post，可以在_config.yml中的default_layout 参数来指定默认布局</p>
<p>2.文章写完后保存文件，执行 hexo generate 或 hexo g 生成静态文件</p>
<p>3.执行 hexo deploy 将文件部署到远端</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/03/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这是我的第一个技术博客<br>希望能坚持下去，见证接下来的变化！</p>
<a id="more"></a>
<h2 id="639"><a href="#639" class="headerlink" title="639"></a>639</h2><p>639天下第一，不接受反驳</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
