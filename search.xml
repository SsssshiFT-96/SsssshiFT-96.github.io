<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL基础-常见函数</title>
    <url>/2020/04/08/MySQL%E5%9F%BA%E7%A1%80-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h1><p>常见函数介绍</p>
<p>概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</p>
<p>好处：</p>
<p>1.隐藏了实现细节</p>
<p>2.提高代码的重用性</p>
<p>调用：select 函数名(实参列表) 【from 表】;</p>
<p>特点：</p>
<p>1.叫什么（函数名）</p>
<p>2.干什么（函数功能）</p>
<p>分类：</p>
<p>1.单行函数</p>
<p>如concat、length、ifnull等</p>
<p>2.分组函数</p>
<p>功能：做统计使用，又称为统计函数、聚合函数、组函数。</p>
<a id="more"></a>

<h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><p><strong>单行函数分类</strong></p>
<p>字符函数、数学函数、日期函数、其他函数、流程控制函数</p>
<p><strong>字符函数</strong></p>
<p>1.length 获取参数值的<strong>字节个数</strong>,<strong>utf8中汉字字节问3个</strong>。</p>
<p>SELECT LENGTH(‘john’);</p>
<p>SELECT LENGTH(‘张三丰hahaha’);</p>
<p>2.concat 拼接字符串</p>
<p>SELECT CONCAT(last_name,’,’,first_name) AS 姓名 FROM employees;</p>
<p>3.upper, lower</p>
<p>SELECT UPPER(‘john’);</p>
<p>SELECT LOWER(‘jONn’);</p>
<p>#示例：将姓变大写，名变小写，然后拼接</p>
<p>SELECT CONCAT(UPPER(last_name),LOWER(first_name)) AS 姓名<br>FROM employees;</p>
<p>4.substr, substring </p>
<p><strong>注意：SQL中索引从1开始</strong></p>
<p>截取从指定索引处后面所有字符</p>
<p>SELECT SUBSTR(‘李莫愁爱上了陆展元’,7) output;</p>
<p>截取从指定索引处指定字符长度的字符</p>
<p>SELECT SUBSTR(‘李莫愁爱上了陆展元’,1,3) output;</p>
<p>5.instr 返回子串第一次出现的索引，如果找不到返回0</p>
<p>SELECT INSTR(‘杨不悔爱上了殷六侠’,’殷六侠’);</p>
<p>6.trim 去前后的指定字符。不说明则是去空格</p>
<p>SELECT TRIM(‘   张翠山 ‘) output;</p>
<p>SELECT TRIM(‘a’ FROM ‘aaaaa张aaa翠山aaaa’);</p>
<p>7.lpad 用指定的字符实现左填充指定长度，若字符长度超过指定，则只显示指定长度</p>
<p>SELECT LPAD(‘殷素素’,10,’*’) output;</p>
<p>8.rpad 用指定的字符实现右填充指定长度，若字符长度超过指定，则只显示指定长度</p>
<p>SELECT RPAD(‘殷素素’,10,’as’) output;</p>
<p>9.replace 替换</p>
<p>SELECT REPLACE(‘张无忌爱上了周芷若’,’周芷若’,’赵敏’) output;</p>
<p><strong>数学函数</strong></p>
<p>1.round 四舍五入</p>
<p>#没有第二个参数默认取整</p>
<p>SELECT ROUND(1.65);</p>
<p>#有第二个参数，其表示保留小数点后的位数</p>
<p>SELECT ROUND(1.677,2);</p>
<p>2.ceil 向上取整,返回&gt;=该参数的最小整数</p>
<p>SELECT CEIL(1.02);</p>
<p>3.floor 向下取整，返回&lt;=该参数的最大整数</p>
<p>SELECT FLOOR(-9.55);</p>
<p>4.truncate 截断,第二个参数表示保留小数点后的位数</p>
<p>SELECT TRUNCATE(1.65,1);</p>
<p>5.mod 取余</p>
<p>#模运算的运算过程为 <strong>mod(a,b) = a - (a/b)*b</strong> java中也一样。其中a/b取整的。</p>
<p>SELECT MOD(10,3);</p>
<p><strong>日期函数</strong></p>
<p>1.now 返回当前系统日期+时间</p>
<p>SELECT NOW();</p>
<p>2.curdate 返回当前系统时期，不包含时间</p>
<p>SELECT CURDATE();</p>
<p>3.curtime 返回当前时间，不包含日期</p>
<p>SELECT CURTIME();</p>
<p>4.可以获取指定的部分，年、月、日、小时、分钟、秒</p>
<p>SELECT YEAR(NOW()) 年;</p>
<p>SELECT YEAR(‘1998-1-1’) 年;</p>
<p>SELECT YEAR(hiredate) 年 FROM employees;</p>
<p>SELECT MONTH(NOW()) 月;</p>
<p>SELECT MONTHNAME(NOW()) 月;</p>
<p>5.str_to_date 将字符通过指定的格式转换成日期</p>
<p>SELECT STR_TO_DATE(‘1998-3-2’,’%Y-%c-%d’) output;</p>
<p>查询入职日期为1992-4-3的员工日期</p>
<p>SELECT *<br>FROM employees<br>WHERE hiredate = STR_TO_DATE(‘4-3 1992’,’%c-%d %Y’);</p>
<p>6.date_format 将日期转换成字符</p>
<p>SELECT DATE_FORMAT(NOW(),’%y年%m月%d日’) output;</p>
<p>查询有奖金的员工名和入职日期(以xx月/xx日 xx年 形式表示)</p>
<p>SELECT last_name, DATE_FORMAT(hiredate,’%m月/%d日 %y年’)<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p>
<p>其他函数</p>
<p>SELECT VERSION();查看版本</p>
<p>SELECT DATABASE();查看当前数据库</p>
<p>SELECT USER();查看当前用户</p>
<p><strong>流程控制函数</strong></p>
<p><strong>if函数</strong></p>
<p>if函数： if else的效果 第一个参数为判断的式子，第二个参数为结果为true时返回的值，第三个参数为结果为false是返回的值。类似java中的三元运算符。</p>
<p>SELECT IF(10&gt;5,’大’,’小’);</p>
<p>SELECT last_name,commission_pct,IF(commission_pct IS NULL,’没奖金’,’有奖金’)</p>
<p>FROM employees;</p>
<p><strong>case函数</strong></p>
<p><strong>case函数的使用一</strong>：类似java中switch case 的效果</p>
<p>java</p>
<p>switch(变量或表达式){</p>
<p>​    case 常量1; 语句1; break;</p>
<p>​    …</p>
<p>​    default: 语句n; break;</p>
<p>​    }</p>
<p><strong>mysql中</strong></p>
<p>case 要判断的字段或表达式</p>
<p>when 常量1 then 要显示的值1 或 语句1;(若是语句要加分号，若不是则不加)</p>
<p>…</p>
<p>else 要显示的值n 或者 语句n;</p>
<p>end</p>
<p><strong>case函数的使用二</strong>：类似于java中的多重if</p>
<p>java：</p>
<p>if(条件1){</p>
<p>​    语句1;</p>
<p>}else if{条件2){</p>
<p>​    语句2;</p>
<p>}</p>
<p>…</p>
<p>else{</p>
<p>​    语句n;</p>
<p>}</p>
<p><strong>mysql中</strong>：</p>
<p>case</p>
<p>when 条件1 then 要显示的值1 或 语句1;</p>
<p>when 条件2 then 要显示的值2 或 语句2;</p>
<p>…</p>
<p>else 要显示的值n 或 语句n;</p>
<p>end</p>
<p><strong>常见函数总结</strong></p>
<p>常见函数：</p>
<p>字符函数：length concat substr instr trim upper lower lpad rpad replace</p>
<p>数学函数：round ceil floor truncate mod</p>
<p>日期函数：now curdate curtime year month monthname day hour minute second str_to_date date_format</p>
<p>其他函数：version database user</p>
<p>控制函数：if case</p>
<h2 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a><strong>分组函数</strong></h2><p>功能：用作统计使用，又称为聚合函数或统计函数或组函数</p>
<p>分类：</p>
<p>sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数</p>
<p>简单使用</p>
<p>select sum(salary), round(avg(salary), 2), max(salary), min(salary), count(salary)<br>from employees;</p>
<p><strong>分组函数的使用特点</strong></p>
<p>1.sum、avg一般用于处理数值型</p>
<p> max、min、count可以处理任何类型</p>
<p>2.以上分组函数都忽略NULL值。</p>
<p>3.可以和distinct搭配实现去重的运算</p>
<p>4.count函数的单独介绍</p>
<p><strong>一般使用count(*)用做统计行数</strong></p>
<p>分组函数和distinct搭配使用</p>
<p>SELECT SUM(DISTINCT salary), SUM(salary) FROM employees;</p>
<p>SELECT COUNT(DISTINCT salary) FROM employees;</p>
<p><strong>count函数的具体介绍</strong></p>
<p>count函数可以使用以下形式</p>
<p>SELECT COUNT(salary) FROM employees; 选定某列进行计数</p>
<p>SELECT COUNT(*) FROM employees; 将表所有列都包含，只要某列某行不为null就可以计数。此方法一般用来计算总行数较多</p>
<p>SELECT COUNT(1) FROM employees; 也是计算总数。括号内可以是任意常数，相当于在整个表中添加了一列，里面列值均为该常数，一般都设置为1。然后进行计数。</p>
<p>效率：</p>
<p>MYISAM存储引擎下，COUNT(*)的效率高</p>
<p>INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些。</p>
<p><strong>分组函数使用的其他注意事项</strong></p>
<p>和分组函数一同查询的字段要求是group by 后的字段。</p>
<p>下述语法是行不通的</p>
<p>select count(salary), employee_id from employees;</p>
]]></content>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础-条件查询&amp;排序查询</title>
    <url>/2020/04/08/MySQL%E5%9F%BA%E7%A1%80-%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="条件查询-amp-排序查询"><a href="#条件查询-amp-排序查询" class="headerlink" title="条件查询&amp;排序查询"></a>条件查询&amp;排序查询</h1><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>语法：</p>
<p>​    select</p>
<p>​       查询列表</p>
<p>​    from</p>
<p>​       表名</p>
<p>​    where</p>
<p>​       筛选条件;</p>
<p>执行顺序：表名、筛选条件、查询列表</p>
<a id="more"></a>

<p>分类：</p>
<p>1.按条件表达式筛选</p>
<p>条件运算符：&gt;、&lt;、=、!=、&lt;&gt;(不等于)、&gt;=、&lt;=</p>
<p>2.按逻辑表达式筛选</p>
<p>逻辑运算符： &amp;&amp;、||、！</p>
<p>​                        and、or、not</p>
<p>&amp;&amp;和and：两个条件为true，结果为true，反之为false</p>
<p>||或or：只要有条件为true，结果为true，反之为false</p>
<p>!或not：如果连续的条件本身为false，结果为true，反之为false</p>
<p>3.模糊查询</p>
<p>like、between and、in、is null</p>
<p>运用</p>
<p>select * from employees where salary &gt; 12000;</p>
<p>select last_name, department_id from employees  where department_id &lt;&gt; 90;</p>
<p>select last_name, department_id from employees<br>where salary &gt;= 10000 and salary &lt;=120000;</p>
<p>select * from employees<br>where not(salary &gt;= 10000 and salary &lt;=120000) or department_id &gt; 90;</p>
<p><strong>like关键字</strong></p>
<p>表示查询包含某个字符的筛选</p>
<p>特点：</p>
<p>1.一般和通配符搭配使用</p>
<p>通配符：</p>
<p>% 可以表示任意多个字符，包含0个字符</p>
<p>_ 可以表示任意单个字符</p>
<p>select * from employees where last_name like “%a%”;</p>
<p>select last_name from employees where last_name like “__n_1%”;</p>
<p>select last_name from employees where last_name like “__\_1%”;</p>
<p>第三句中除了可以使用\表示转义，也可以自定义转义字符，使用<strong>关键字ESCAPE</strong></p>
<p>select last_name from employees where last_name like “__#_1%”  escape ‘#’;</p>
<p><strong>between and关键字</strong></p>
<p>XXX between <strong>* and *</strong> 等价于 XXX &gt;= <strong>* and XXX &lt;= *</strong> 。</p>
<p>1.使用between and可以提高语句的简洁度</p>
<p>2.包含临界值</p>
<p>3.两个临界值调换顺序结果不同</p>
<p><strong>in关键字</strong></p>
<p>用于判断某字段的值是否属于in后面括号中的某一项</p>
<p>特点：</p>
<p>1.使用in提高语句简洁度</p>
<p>2.in列表的值类型必须一致或兼容</p>
<p>3.不支持通配符</p>
<p><strong>is null关键字</strong></p>
<p>=和&lt;&gt;不能用于判断null值</p>
<p>is null 或 is not null 可以判断null值</p>
<p><strong>安全等于</strong></p>
<p>安全等于 &lt;=&gt; 可以判断是否等于某数值，可以判断是否等于null</p>
<p>select * from employees where commission_pct &lt;=&gt; null;</p>
<p>is null 与&lt;=&gt;比较</p>
<p>is null：仅仅可以判断null值，可读性较高，建议使用</p>
<p>&lt;=&gt;：既可以判断null值，又可以判断普通的数值，可读性较低</p>
<h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><p>语法：说明【】里的内容可写可不写</p>
<p>select 查询列表</p>
<p>from 表</p>
<p>【where 筛选条件】</p>
<p>order by 排序列表 【asc(升序) | desc(降序)】</p>
<p>特点：</p>
<p>1.asc代表升序，desc代表的是降序。如果不写，默认升序。</p>
<p>select * from employees oder by salary desc;</p>
<p>select *, length(last_name)  from employees oder by length(last_name) asc;</p>
<p>排序查询总结</p>
<p>特点：</p>
<p>1.asc代表升序，desc代表的是降序。如果不写，默认升序。</p>
<p>2.order by 子句中可以支持单个字段、多个字段、表达式、函数、别名</p>
<p>3.order by 子句一般是放在查询语句的最后，但limit子句除外。</p>
<p>4.执行顺序：表、筛选条件、列表、排序。</p>
]]></content>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础-基础查询</title>
    <url>/2020/04/07/MySQL%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h1><p>介绍</p>
<p>语法：</p>
<p>select 查询列表 from 表名;</p>
<p>类似于：System.out.println(打印东西);</p>
<p>特点：</p>
<p>1.查询列表可以是：表中的字段、常量值、表达式、函数。</p>
<p>2.查询结果是虚拟的表格。</p>
<a id="more"></a>

<p><strong>查询表中的字段</strong></p>
<p>1.查询表中的单个字段</p>
<p>select last_name from employees;</p>
<p>2.查询表中的多个字段</p>
<p>select last_name, salary, email from employees;</p>
<p>3.查询表中的所有字段</p>
<p>select * from employees;</p>
<p><strong>查询常量、表达式、函数</strong></p>
<p>4.查询过常量值</p>
<p>select 100;</p>
<p>select ‘john’;</p>
<p><strong>注意</strong>：MySQL中字符和字符串均用单引号。</p>
<p>5.查询表达式</p>
<p>select 100*90;</p>
<p>结果：9000</p>
<p>6.查询函数</p>
<p>select version();</p>
<p><strong>起别名</strong></p>
<p>好处</p>
<p>1.便于理解</p>
<p>2.如果要查询的字段有重名的情况，使用别名可以区分开来</p>
<p>方式一：使用as</p>
<p>select 100%98 as 结果;</p>
<p>select last_name as 姓, first_name as 名 from employees;</p>
<p>方式二：使用空格</p>
<p>select last_name 姓, first_name 名 from employees;</p>
<p>当别名中，有字段和关键字重复如out，则用双引号。单引号也行，但推荐使用双引号</p>
<p>如查询salary，显示结果为out put</p>
<p>select salary as “out put” from employees;</p>
<p><strong>去重</strong></p>
<p>使用关键词<strong>distinct</strong></p>
<p>select distinct department_id from employees;</p>
<p> <strong>+号的作用</strong></p>
<p>java中的+号</p>
<p>1.运算法，两个操作数都为数值型</p>
<p>2.连接符，只要有一个操作数为字符串</p>
<p>mysql中的+号</p>
<p>只有一个功能：运算符</p>
<p>select 100+90; 两个操作数都为数值型，则做加法运算<br>结果：190</p>
<p>select ‘123’+90; 其中一方为字符型，试图转换成数值型，如果转换成功，则继续做加法运算<br>结果：213</p>
<p>select ‘john’+90; 如果转换失败，则将字符型数值转换成0。<br>结果：90</p>
<p>select null+10; 只要其中一方为null，则结果肯定为null。<br>结果：null</p>
<p><strong>使用concat实现连接</strong></p>
<p>select concat(‘a’,’b’) as 结果;<br>结果：ab</p>
<p>案例：查询员工名和姓连接成一个字段，并显示为 姓名</p>
<p>SELECT<br>     CONCAT(last_name,first_name) AS 姓名<br>FROM<br>     employees;</p>
<p><strong>注意：null值与任何数据拼接都会null</strong></p>
<p>案例：显示出表 employees 的全部列，各个列之间用逗号连接，列头显示成 OUT_PUT</p>
<p>select<br>    concat(employee_id, ‘,’ , last_name, ‘,’ , first_name, ‘,’ , salary, ‘,’ commision_pct)<br>as<br>    “out put”<br>from<br>    employees;</p>
<p>这样子的结果均为null，因为commsion_pct中，有null的值。</p>
<p>所以这里使用IFNULL(expr1,expr2)函数，expr1是指定列，expr2是若列值为null，则换成指定的值，若不是则按原数值输出</p>
<p>select IFNULL(commision_pct, 0) from employees;</p>
<p>所以上语句应改为</p>
<p>select<br>    concat(employee_id, ‘,’ , last_name, ‘,’ , first_name, ‘,’ , salary, ‘,’ IFNULL(commision_pct, 0))<br>as<br>    “out put”<br>from<br>    employees;</p>
]]></content>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础-引入</title>
    <url>/2020/04/07/MySQL%E5%9F%BA%E7%A1%80-%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><strong>数据库的好处</strong></p>
<p>实现数据持久化</p>
<p>使用完整的管理系统统一管理，易于查询。</p>
<p><strong>数据库概念</strong></p>
<p>DB：数据库（Database）:存储数据的仓库。它保存了一系列有组织的数据。</p>
<p>DBMS：数据库管理系统（Database Management System）数据库是通过DBMS创建和操作的容器。</p>
<p>常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等。</p>
<p>SQL：结构化查询语言（Structure Query Language）专门用来与DBMS通信的语言。</p>
<p>SQL特点：</p>
<p>1.不是某个特定数据库供应商专有的语言，几乎所有DBMS都支持SQL。</p>
<p>2.简单易学。</p>
<p>3.虽然简单，但是实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</p>
<a id="more"></a>

<p><strong>数据库存储数据</strong></p>
<p>1.将数据放到<strong>表</strong>中，表再放到库中。</p>
<p>2.一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性</p>
<p>3.表具有一些特性，这些特性定义了数据在表中如何存储，类似Java中类的设计</p>
<p>4.<strong>表由列组成，我们也称为字段</strong>。所有表都是由一个或多个列组成的，每一列类似java中的属性</p>
<p>5.<strong>表中的数据是按行存储的</strong>，每一行类似于java中的对象。</p>
<p><strong>MySQL软件</strong></p>
<p>软件优点</p>
<p>1.成本的：开放源代码，一般可以免费试用</p>
<p>2.性能高：执行很快</p>
<p>3.简单：很容易安装和使用</p>
<p>DBMS分为两类：</p>
<p>基于共享文件系统的DBMS（Access）</p>
<p>基于客户机——服务器（C/S）的DBMS（MySQL、Oracle、SqlServer）</p>
<p><strong>MySQL常见命令、查看数据库版本、总结常见命令</strong></p>
<p>1.查看当前所有的数据库</p>
<p>show databases;</p>
<p>2.打开指定数据库</p>
<p>use 库名;</p>
<p>3.查看当前库的所有表</p>
<p>show tables;</p>
<p>4.查看其他库的所有表</p>
<p>show tables from 其他库;</p>
<p>5.创建表</p>
<p>create table 表名(</p>
<p>​        列名 列类型；</p>
<p>​        列名 列类型；</p>
<p>​        …</p>
<p>)；</p>
<p>6.查看表结构</p>
<p>desc 表名</p>
<p>7.查看服务器版本</p>
<p>方式一：登录mysql服务端</p>
<p>select version();</p>
<p>方式二：没有登录到mysql服务端</p>
<p>直接使用命令行</p>
<p>mysql –version</p>
<p>或</p>
<p>mysql –V</p>
<p><strong>注意：在数据库中输入命令，输完最好要以分号结尾。</strong></p>
<p><strong>MySQL语法规范、图形化界面</strong></p>
<p>1.不区分大小写，但建议关键字大写，表名、列名小写</p>
<p>2.每条命令最好用分号结尾</p>
<p>3.每条命令根据需要，可以进行缩进或换行</p>
<p>4.注释</p>
<p>​    单行注释：#注释文字</p>
<p>​    单行注释：– 注释文字</p>
<p>​    多行注释：/* 注释文字 */</p>
<p><strong>myemployees库的四张表介绍</strong></p>
<p>DQL: Data Query Language 数据查询语言，涉及到关键字select</p>
<p>DML: Data Manipulation Language 数据操作语言，涉及到增删改</p>
<p>DDL: Data Define Language 数据定义语言，关于库和表的定义</p>
<p>TCL: Transaction Control Language 事物控制语言</p>
]]></content>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计网-应用层</title>
    <url>/2020/04/04/%E8%AE%A1%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层的具体内容就是规定应用进程在通信时所遵循的协议。</p>
<p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。</p>
<p>应用层的许多协议都是基于客户服务器方式。客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。 </p>
<a id="more"></a>

<h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a><strong>域名系统DNS</strong></h2><p><strong>DNS协议</strong></p>
<p>域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。<strong>它作为将域名和IP地址相互映射的一个分布式数据库</strong>，能够使人更方便地访问互联网。DNS使用TCP和UDP<strong>端口53</strong>。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。<strong>DNS协议</strong>是用来将域名转换为IP地址（也可以将IP地址转换为相应的域名地址）</p>
<p><strong>DNS协议的名字空间</strong></p>
<p>采用层次树状结构的命名方法</p>
<p>任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即<strong>域名</strong>。</p>
<p>“域”是名字空间中一个可被管理的划分。域还可划分为子域。而子域还可继续划分为子域的子域，这样就形成了顶级域、二级域、三级域，等等。</p>
<p>域名的结构由标号序列组成，各标号之间用点隔开：</p>
<p>… <strong>.</strong> 三级域名 <strong>.</strong> 二级域名 <strong>.</strong> 顶级域名</p>
<p>因特网域名空间的结构，实际上<strong>是倒过来的树</strong>，在最上面的是根，但没有对应的名字。根下面一级的节点就是顶级域名。顶级域名可往下划分子域，即二级域名。再往下就是三级域名、四级域名等等。一旦某个单位拥有了一个域名，它就可以自己决定是否要进一步划分其下属的子域，不必由上级机构批准。<strong>域名树的树叶就是单台计算机的名字，它就不能再继续往下划分子域了</strong>。</p>
<p><strong>域名解析</strong></p>
<p>一、主机向本地域名服务器的查询一般都是采用<strong>递归查询。</strong>递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。<br>二、本地域名服务器向根域名服务器的查询的<strong>迭代查询</strong>。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</p>
<p><strong>逆向解析</strong></p>
<p>DNS服务器里面有两个区域，即“正向查找区域”和“反向查找区域”，正向查找区域就是通常所说的域名解析，反向查找区域即是<br><strong>IP反向解析</strong>，<strong>它得到作用是通过查找IP地址的PTR记录来得到该IP地址指向的域名</strong>。要成功得到域名就必须有该IP地址的PTR记录。PTR及记录是邮件交换记录的一种，邮件交换记录中有A记录和PTR记录，A记录解析名字到地址，PTR记录解析地址到名字。<br>反向域名解析系统（Reverse DNS）的功能确保适当的邮件交换记录是生效的。反向域名解析与通常的正向域名解析下相反，提供IP地址到域名的对应。IP反向解析主要应用到邮件服务器中来阻拦垃圾邮件。</p>
<p>多数垃圾邮件发送者使用动态分配或者没有注册域名的IP地址来发送垃圾邮件，以避免追踪，使用域名反向解析后，就可以大大降低垃圾邮件的数量。比如用<a href="mailto:xxx@name.com">xxx@name.com</a>这个邮箱给<a href="mailto:kasum@lwork.com">kasum@lwork.com</a>发一封信，lwork邮件服务器接到这封信会查看这封信的信头文件，这封信的信头文件会显示这封信是由哪个IP地址发出来的。然后根据这个IP地址进行反向解析，如果反向解析到这个IP对应的域名是name.com就接收这封邮件，如果反向解析这个IP没有对应到name.com，那么就拒绝这封邮件。由于在域名系统中，一个IP地址可以对应多个域名，因此从IP出发去找域名，理论上应该遍历整个域名树，但是这在internet上是不现实的。为了完成逆向域名解析，系统提供一个特别域，该特别域称为逆向解析域in-addr.arpa.这样欲解析的IP地址就会被表达城一种像域名一样的可显示串形式，后缀以逆向解析域域名“in-addr.arpa”结尾。</p>
<p><strong>DNS缓存</strong></p>
<p>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。</p>
<p>可大大减轻根域名服务器的负荷，使因特网上的 DNS 查询请求和回答报文的数量大为减少。</p>
<p>为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（例如，每个项目只存放两天）。</p>
<p>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。</p>
<h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><p><strong>文件传送协议 FTP (File Transfer Protocol)</strong> 是因特网上使用得最广泛的文件传送协议。</p>
<p>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</p>
<p>FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p>
<p><strong>FTP 特点</strong></p>
<p>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。</p>
<p>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</p>
<p>FTP 使用<strong>客户服务器方式</strong>。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</p>
<p><strong>两个连接</strong></p>
<p><strong>控制连接</strong>在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。</p>
<p>实际用于传输文件的是<strong>“数据连接”</strong>。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。</p>
<p>数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p>
<p><strong>两个不用的端口号</strong></p>
<p>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的<strong>熟知端口(21)</strong>，同时还要<strong>告诉服务器进程自己的另一个端口号码，用于建立数据传送连接</strong>。接着，服务器进程用自己传送数据的熟知端口(20)与客户进程所提供的端口号码建立数据传送连接。<strong>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱</strong>。</p>
<p>使用两个不同端口号的<strong>好处</strong>是使协议更加简单和更容易实现和在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。</p>
<p><strong>两种工作模式：PASV+PORT</strong></p>
<p>在<strong>主动模式</strong>下，FTP客户端随机开启一个大于1024的端口N向服务器的21号端口发起连接，然后开放N+1号端口进行监听，并向服务器发出PORT N+1命令。服务器接收到命令后，会用其本地的FTP数据端口（通常是20）来连接客户端指定的端口N+1，进行数据传输。</p>
<p>在<strong>被动模式</strong>下，FTP库户端随机开启一个大于1024的端口N向服务器的21号端口发起连接，同时会开启N+1号端口。然后向服务器发送PASV命令，通知服务器自己处于被动模式。服务器收到命令后，会开放一个大于1024的端口P进行监听，然后用PORT P命令通知客户端，自己的数据端口是P。客户端收到命令后，会通过N+1号端口连接服务器的端口P，然后在两个端口之间进行数据传输。</p>
<p>​    <strong>两者不同不同之处</strong>：不同之处是由于PORT（主动）这个方式需要在接上TCP 21端口后，服务器通过自己的TCP 20来发出数据。并且需要建立一个新的连接来传送档案。而PORT的命令包含一些客户端没用的资料，所以有了PASV的出现。而PASV模式拥有PORT模式的优点，并去掉一些PORT的缺点。PASV运行方式就是当服务器接收到客户端连接请求时，就会自动从端口1024到5000中随机选择一个和客户端建立连接传递数据。由于被动且自动建立连接，容易受到攻击，所以安全性差。</p>
<p>总的来说，主动模式的FTP是指服务器主动连接客户端数据端口，被动模式下的FTP是指服务器被动地等待客户端连接自己的数据端口。</p>
<p><strong>FTP断点续传</strong></p>
<p><strong>FTP（文件传输协议的简称）（File Transfer Protocol、 FTP）客户端软件断点续传</strong>指的是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度。</p>
<p>对于ftp的断点续传上传的功能实现，FTP协议中提供了一条APPE的控制命令用来追加文件，我们所实现的断点续传的命令就是围绕着这个命令进行的。<br>1、 在正常上传的过程中，记录下已经发送的文件的长度<br>2、 当网络发送异常时，记录当前发送文件长度，并关闭当前ftp连接，结束ftp的发送过程<br>3、 当网络正常后，重新开始建立ftp的连接，此时由上传文件改为APPE命令，并在数据连接上发送剩余的数据到ftp服务器。</p>
<p><strong>匿名FTP</strong></p>
<p>背景</p>
<p>使用FTP时必须首先登录，在远程主机上获得相应的权限以后，方可上传或下载文件。也就是说，要想同哪一台计算机传送文件，就必须具有哪一台计算机的适当授权。换言之，除非有用户ID和口令，否则便无法传送文件。这种情况违背了Internet的开放性，Internet上的FTP主机何止千万，不可能要求每个用户在每一台主机上都拥有帐号。<strong>匿名FTP就是为解决这个问题而产生的。</strong></p>
<p><strong>anonymous FTP（匿名FTP</strong>）</p>
<p>即匿名文件传输协议。用于对远程计算机的连接，这些计算机是作为匿名或客户用户进行连接的，以将公共文件传输到用户的本地计算机。</p>
<p><strong>特性</strong></p>
<p>匿名FTP是这样一种机制：用户可通过它连接到远程主机上，并从其下载文件，而无需成为其注册用户。系统管理员建立了一个特殊的用户ID，名为anonymous， Internet上的任何人在任何地方都可使用该用户ID。</p>
<p>通过FTP程序连接匿名FTP主机的方式同连接普通FTP主机的方式差不多，只是在要求提供用户标识ID时必须输入anonymous，该用户ID的口令可以是任意的字符串。习惯上，用自己的E-mail地址作为口令，使系统维护程序能够记录下来谁在存取这些文件</p>
<p>匿名FTP服务的<strong>实质</strong>是：提供服务的机构在它的FTP服务器上建立一个公开账户（一般为anonymous），并赋予该账户访问公共目录的权限。用户想要登录到这些FTP服务器时，无需事先申请用户账户，可以用“anonymous”作为用户名，用自己的E-mail地址或姓名作为用户密码，便可登录，获取FTP服务。</p>
<p><strong>匿名FTP服务的优点是：</strong></p>
<p>第一，匿名FTP运用很广，没有什么指定的要求。所以，每一个人都可以在匿名FTP主机上访问文件。“big deal”是指世界上大量运用的匿名FTP，即上千的匿名主机和无数的文件都可以被免费拷贝。在Internet上，大量信息和大量计算机程序都是可获得的，人们可以利用计算机设备和磁盘空间来获得对自己有用的文件。匿名FTP提供进入最大信息库的通路，并且这个库总是不断壮大，它不关闭，并且无所不包，还可以免费访问。</p>
<p>第二，在Internet上，匿名FTP是软件分发的主要方式。在Internet上保存所有已提供所用标准协议的有用程序。许多程序通过匿名FTP分布，每一个人都可以建立一个Internet主机。</p>
<p>FTP之所有非常重要的最后一个原因是：匿名FTP被用来归档和传播技术信息，从而定义了Internet自己(实现资源共享）。</p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h2><p>为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。</p>
<p>从层次的角度看，HTTP 是面向事务的(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</p>
<p><strong>HTTP协议报文格式</strong></p>
<p>HTTP 有两类报文：</p>
<p><strong>请求报文</strong>——从客户向服务器发送请求报文。</p>
<p><strong>响应报文</strong>——从服务器到客户的回答。</p>
<p>由于 HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</p>
<p>HTTP请求报文和响应报文都是由三个部分组成。可以看出，这两种报文格式的区别就是开始行不同。</p>
<p>开始行：用于区分请求报文还是响应报文。开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表回车和换行</p>
<p>首部行：用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有”回车“和”换行“。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</p>
<p>实体主体：在请求报文中一般都不用这个字段，而在相应报文中也可能没有这个字段。</p>
<p>请求报文中的请求行：</p>
<p>请求行只有三个内容，即<strong>方法，请求资源的URL，以及HTTP的版本</strong>。<strong>“方法”</strong>是面向对象技术中使用的专门名词。所谓“方法”就是对所请求的对象进行的<strong>操作</strong>，因此<strong>这些方法实际上也就是一些命令</strong>。因此，请求报文的类型是由它所采用的方法决定的。。</p>
<p>响应报文的第一行就是状态行，包括三项内容，即<strong>HTTP版本、状态码、以及解释状态码的简单短语</strong>。</p>
<p><strong>状态码(Status-Code)都是三位数字，分为5大类共33种</strong></p>
<p>1xx 表示通知信息的，如请求收到了或正在进行处理。</p>
<p>2xx 表示成功，如接受或知道了。</p>
<p>3xx 表示重定向，表示要完成请求还必须采取进一步的行动。</p>
<p>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</p>
<p>5xx 表示服务器的差错，如服务器失效无法完成请求。</p>
<h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p><strong>HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道</strong>，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面</p>
<p><strong>HTTPS加密请求（一次握手）过程</strong></p>
<ul>
<li>首先，客户端发起握手请求，以明文传输请求信息，包含版本信息，加密-套件候选列表，压缩算法候选列表，随机数，扩展字段等信息(<code>这个没什么好说的，就是用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。</code>)</li>
<li>服务端的配置，采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。<code>这套证书其实就是一对公钥和私钥。</code>如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li>
<li>服务端返回协商的信息结果，包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S 以及证书。(<code>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</code>)</li>
<li>客户端验证证书的合法性，包括可信性，是否吊销，过期时间和域名。(<code>这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个随机值。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</code>)</li>
<li>客户端使用公匙对对称密匙加密，发送给服务端。(<code>这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</code>)</li>
<li>服务器用私钥解密，拿到对称加密的密匙。(<code>服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</code>)</li>
<li>传输加密后的信息，这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。</li>
<li>客户端解密信息，客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li>
</ul>
<p><strong>摘要算法</strong></p>
<p><strong>消息摘要算法分为三类：</strong></p>
<p>MD(Message Digest)：消息摘要</p>
<p>SHA(Secure Hash Algorithm)：安全散列</p>
<p>MAC(Message Authentication Code)：消息认证码</p>
<p><strong>数字证书</strong>可以理解为网络上使用的电子身份证，上面记录了某个主体的信息（比如某网站），通过CA机构数字签名的手段进行了认证。同时，数字证书上记录着一份公钥，这份公钥对于的私钥只有证书的持有着拥有。<br>1、证书上的数字签名证明了证书的真实性。<br>2、持有证书上公钥对于的私钥，则实际持有了该证书，可以解密该证书加密的内容。</p>
<p>数字签名是怎么回事，真实性又是怎么保证的呢：<br>我们从非对称加密中可以发现，私钥的拥有者是唯一的。那么用私钥加密的内容，可以认为只有拥有者可以提供。假设我们知道一个公钥，用它解密出来的内容则一定是私钥的拥有者所加密的，也就是说，这个内容一定是私钥拥有者产生的。那么只要能证明公钥的持有者，就可以证明一封数字内容的持有者了。<br>“用私钥签名，用公钥认证”。这就满足了一个“签名”被签署和被认证的基本逻辑。<br>那么是不是要对证书上所有的内容全部用私钥加密来达到签名的效果呢。实际这么做的话，加密成本就太高了。<br>我们的数字签名实际也不是这么做的，我们需要对需要被签名的内容进行精简，并对精简后的内容进行私钥加密就可以形成签名了，这个精简的过程我们称为“摘要”。这里的这个摘要需要满足以下原则:只要被摘要的内容不一样，则摘要一定不一样。这样一来，证书的内容只需要明文保存，同时进行摘要后用私钥加密形成签名。当我们需要验证证书是，用同样的摘要算法进行摘要，并对签名进行解密，两者一对比，如果一样，说明证书的内容没被改动过。<br><strong>这个摘要并加密的过程，就是数字签名</strong>。这里我们用到了摘要算法，被摘要出来的内容具有固定的长度。</p>
<p>掌握DNS协议，掌握DNS协议的名字空间、DNS指针查询（反向查找或逆向解析）基本原理、DNS缓存</p>
<p>掌握FTP协议、两条连接：控制连接+数据连接、为何需要控制流和数据流</p>
<p>两种工作模式：PASV+PORT，各种FTP指令和响应码</p>
<p>FTP断点续传、匿名FTP</p>
<p>掌握HTTP协议：1.报文格式：请求报文、响应报文、请求头各种字段、响应头各种字段 2.Http状态码</p>
<p>掌握HTTPS协议：1.https的详细握手过程 2.摘要算法、数字签名、数字证书的原理和过程</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网-传输层</title>
    <url>/2020/04/04/%E8%AE%A1%E7%BD%91-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><strong>UDP（User Datagram Protocol）协议</strong></p>
<p>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。 </p>
<p>UDP 传送的<strong>数据单位协议是 UDP 报文或用户数据报</strong>。 </p>
<p>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。</p>
<p>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。</p>
<p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p>
<a id="more"></a>

<p><strong>UDP的主要特点</strong></p>
<p>1.UDP 是无连接的，即发送数据之前不需要建立连接。</p>
<p>2.UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</p>
<p>3.UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。</p>
<p>4.UDP 支持一对一、一对多、多对一和多对多的交互通信。</p>
<p>5.UDP 的首部开销小，只有 8 个字节。</p>
<p>6.UDP是面向报文的。</p>
<p>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
<p>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</p>
<p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</p>
<p>应用程序必须选择合适大小的报文。</p>
<p><strong>UDP首部格式</strong></p>
<p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段只有8个字节，由四个字段组成。每个‘字段的长度都是两个字节。各字段如下：</p>
<p>1.源端口：源端口号。在需要对方回信时选用。不需要时可用全0。</p>
<p>2.目的端口：目的端口号。这在终点交付报文必须要使用到</p>
<p>3.长度：UDP用户数据报的长度，其最小值是8（仅有首部）。</p>
<p>4.检验和：检验UDP用户数据在传输中是否有错。有错就丢弃。</p>
<p>UDP用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在UDP用户数据报之前<strong>增加12个字节地伪首部</strong>。在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起，得到一个临时的UDP用户数据报。伪首部仅仅是为了计算检验和，既不向下传送也不向上递交。上上图中给出了伪首部个字段的内容</p>
<p><strong>传输控制协议 TCP(Transmission Control Protocol)协议</strong></p>
<p>TCP 传送的<strong>数据单位协议是 TCP 报文段(segment)</strong></p>
<p>TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。 </p>
<p>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。</p>
<p><strong>TCP主要特点</strong></p>
<p>(1) TCP 是<strong>面向连接的运输层协议</strong>。应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，释放连接。</p>
<p>(2) 每一条 TCP 连接<strong>只能有两个端点(endpoint)</strong>，每一条 TCP 连接只能是点对点的（一对一）。 </p>
<p>(3) TCP 提供<strong>可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。</p>
<p>(4) TCP 提供<strong>全双工通信</strong>。</p>
<p>(5) <strong>面向字节流</strong>。TCP中的<strong>流是指流入到进程或从进程流出的字节序列</strong>。<strong>面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流</strong>。TCP不知道所传送字节流的含义，不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有大小对应关系。</p>
<p><strong>TCP的连接</strong></p>
<p>TCP 把连接作为最基本的抽象。每一条 TCP 连接有两个端点。TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。<strong>TCP 连接的端点叫做套接字(socket)或插口。端口号拼接到(contatenated with) IP 地址即构成了套接字。</strong>  </p>
<p><strong>TCP通过哪些方式保证可靠性</strong></p>
<p>1） 应用数据被分割成 TCP 认为最适合发送的数据块。</p>
<p>2） 确认机制，发送报文后，等待确认。</p>
<p>3） 重发机制，没有收到确认，将重发数据段。</p>
<p>4） 保持它首部和数据的校验和。确认数据的准确性。</p>
<p>5） 排序，丢弃重复的，流量控制。</p>
<p><strong>TCP</strong> <strong>可靠通信的具体实现</strong></p>
<p>TCP 连接的每一端都必须设有两个窗口——一个<strong>发送窗口</strong>和一个<strong>接收窗口</strong>。 TCP 的可靠传输机制用<strong>字节的序号进行控制</strong>。TCP 所有的确认都是<strong>基于序号而不是基于报文段</strong>。 TCP 两端的<strong>四个窗口经常处于动态变化</strong>之中。TCP连接的<strong>往返时间 RTT 也不是固定不变</strong>的。需要使用<strong>特定的算法估算较为合理的重传时间</strong>。</p>
<p><strong>TCP 报文段的首部格式</strong></p>
<p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而<strong>TCP的全部都体现在它首部中各字段的作用</strong>。</p>
<p>TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项（n为整数）。因此TCP首部的最小长度是20字节。<strong>首部固定部分各字段的意义如下</strong>：</p>
<p>(1) <strong>源端口和目的端口字段</strong>——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 </p>
<p>(2) <strong>序号字段</strong>——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。这个字段的名称也叫<strong>报文段序号</strong>。</p>
<p>(3) <strong>确认号字段</strong>——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。应当记住：若确认号=N，则表明到序号N-1为止的所有数据都已正确收到。</p>
<p>(5) <strong>数据偏移（即首部长度）</strong>——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</p>
<p>(6) <strong>保留字段</strong>——占 6 位，保留为今后使用，但目前应置为 0。</p>
<p>(7) <strong>紧急 URG(URGent)</strong> —— 当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</p>
<p>(8) <strong>确认 ACK(ACKnowlegment)</strong> —— 只有当 ACK=1 时确认号字段才有效。当 ACK=0 时，确认号无效。</p>
<p>(9) <strong>推送 PSH (PuSH)</strong> —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </p>
<p>(10) <strong>复位 RST (ReSeT)</strong> —— 当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</p>
<p>(11) <strong>同步 SYN(SYNchronization)</strong> —— 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段，对方若同意建立连接，则应在响应的报文段中是SYN=1和ACK=1。因此同步 SYN = 1 表示这是一个连接请求或连接接受报文。</p>
<p>(12) <strong>终止 FIN (FINis)</strong> —— 用来释放一个连接。FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</p>
<p>(13) <strong>窗口字段</strong> —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之窗口值作为接收方让发送方设置其发送窗口的依据。总之，<strong>窗口字段明确指出了现在允许对方发送的数据量。窗口值是经常在动态变化着。</strong></p>
<p>(14) <strong>检验和</strong> —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p>
<p>(15) <strong>紧急指针字段</strong> —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 </p>
<p>(16) <strong>选项字段</strong> —— 长度可变。TCP 最初只规定了一种选项，即<strong>最大报文段长度 MSS(Maximum Segment Size)</strong>。<strong>MSS是是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。</strong>MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。MSS应尽可能大些，只要在IP层传输时不需要再分片就行。</p>
<p><strong>其他选项</strong></p>
<p><strong>窗口扩大选项</strong> ——占 3 字节，其中有一个字节表示<strong>移位值 S</strong>。新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，移位值允许使用的最大值是14，相当于把窗口值向左移动 S 位后获得实际的窗口大小。</p>
<p><strong>时间戳选项</strong>——占10 字节，其中<strong>最主要的字段时间戳值字段</strong>（4 字节）和<strong>时间戳回送回答字段</strong>（4 字节）。时间戳选项有以下两个功能：</p>
<p><strong>选择确认选项</strong>——在后面的 5.6.3 节介绍。</p>
<p>(17) <strong>填充字段</strong> —— 这是为了使整个首部长度是 4 字节的整数倍。</p>
<p>TCP流量控制机制：滑动窗口、慢启动、拥塞避免、快速重传、快速恢复</p>
<p><strong>滑动窗口</strong></p>
<p><strong>慢启动</strong></p>
<p>（1）慢开始不是指 cwnd 的增长速度慢（指数增长），而是指 TCP 开始发送设置 cwnd=1。</p>
<p>（2）思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。</p>
<p>（3）为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ssthresh 状态变量）</p>
<p>当 cnwd＜ssthresh，使用慢开始算法</p>
<p>当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</p>
<p>当 cnwd＞ssthresh，使用拥塞避免算法</p>
<p><strong>拥塞避免</strong> </p>
<p>（1）拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律长，使网络比较不容易出现拥塞。</p>
<p>（2）思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控制窗口加一。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始算法。</p>
<p><strong>快速重传</strong></p>
<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。</p>
<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。</p>
<p>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。</p>
<p><strong>快速恢复</strong></p>
<p>(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。</p>
<p>(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p><strong>TCP超时重传机制：各种定时器</strong> </p>
<p>超时重传是TCP协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p>
<p>TCP连接控制：三次握手（为什么）、四次挥手（为什么）、同时打开、同时关闭、半关闭</p>
<p><strong>三次握手建立 TCP 连接</strong></p>
<p>1.A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</p>
<p>2.B 的 TCP 收到连接请求报文段后，如同意，则发回确认。</p>
<p>B 在确认报文段中应使SYN=1，使 ACK=1，其确认号ack=x+1，自己选择的序号seq = y。</p>
<p>3.A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y+1。</p>
<p>A 的 TCP 通知上层应用进程，连接已经建立。  </p>
<p>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</p>
<p><strong>四次挥手释放TCP连接</strong></p>
<p>1.A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</p>
<p>2.B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于<strong>半关闭</strong>状态。B 若发送数据，A 仍要接收。</p>
<p>3.若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 </p>
<p>4.A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 </p>
<p>TCP 连接必须经过时间 2MSL 后才真正释放掉。</p>
<p><strong>A 必须等待 2MSL 的时间原因</strong></p>
<p>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</p>
<p>第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<p><strong>同时打开</strong></p>
<p>同时打开连接是指通信的双方在接收到对方的SYN包之前，都进行了主动打开的操作并发出了自己的SYN包。</p>
<p><strong>同时关闭</strong></p>
<p>同时关闭相对于我们讲过的四次握手过程基本类似，注意两者状态转换的区别，同时关闭是由ESTABLISHED-&gt;FIN_WAIT_1-&gt;CLOSING-&gt;TIME_WAIT-&gt;CLOSED。</p>
<p><strong>半打开</strong></p>
<p>从协议定义的角度来说，TCP的半开连接是指TCP连接的一端异常崩溃，或者在未通知对端的情况下关闭连接，这种情况下不可以正常收发数据，否则会产生RST(后面内容我们在介绍RST)。</p>
<p><strong>半关闭</strong></p>
<p>TCP的半关连接是指TCP连接只有一方发送了FIN，另一方没有发出FIN包，仍然可以在一个方向上正常发送数据。</p>
<p><strong>为什么要 3 次握手，4 次挥手</strong> </p>
<p>3 次握手：防止已过期的连接请求报文突然又传送到服务器，因而产生错误</p>
<p>4 次挥手：确保数据能够完成传输，但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的</p>
<p><strong>TCP和UDP为什么存在伪包头</strong></p>
<p>UDP(TCP)检验和：是根据 UDP(TCP)数据报和伪报头计算得到的差错检测值。伪报头包含源和目的 IP 地址，以及来自 IP 数据报报头的协议值。IP 数据报在网络中传送时包含 UDP 数据报。</p>
<p>伪报头并不会在网络中传送，校验和中所包含的伪报头内容可以避免目的端错误地接收错误路由的数据报。校验和值的计算方法和 IP 报头检验和的计算方法类似</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网-网络层</title>
    <url>/2020/04/03/%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a><strong>IP数据报的格式</strong></h2><p><strong>一个 IP 数据报由首部和数据两部分组成。</strong></p>
<p>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</p>
<p>在首部的固定部分的后面是一些可选字段，其长度是可变的。</p>
<p>ip首部格式</p>
<p> 版本    首部长度    区分服务    总长度</p>
<p>​                    标        识                标志    片偏移</p>
<p>生存时间                    协议         首部检验和</p>
<p>​                                源地址</p>
<p>​                                目的地址</p>
<p>​            可选字段（长度可变）            填充</p>
<p>前五行为固定部分，最后一行为可变部分</p>
<a id="more"></a>

<p>(1) <strong>版本</strong> 占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 (即 IPv4)</p>
<p>(2) <strong>首部长度</strong> 占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)因此 IP 的首部长度的最大值是 60 字节。</p>
<p>(3) <strong>区分服务</strong> 占 8 位，用来获得更好的服务。在旧标准中叫做<strong>服务类型</strong>，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。<strong>在一般的情况下都不使用这个字段</strong>。</p>
<p>(4) <strong>总长度</strong> 占 16 位，指首部和数据之和的长度，<strong>单位为字节</strong>，因此数据报的最大长度为 65535 字节。总长度必须不超过<strong>最大传送单元 MTU(Maximum Transfer Unit)</strong>。IP协议规定，在因特网中所有的主机和路由器，必须能够接受长度不超过576字节的数据报。当主机需要发送长度超过576字节的数据报时，应当先了解一下，目的主机是否能够接受。否则就要进行分片。</p>
<p>(5) <strong>标识(identification)</strong>  占 16 位，它是一个计数器，用来产生数据报的标识</p>
<p>(6) <strong>标志(flag)</strong> 占 3 位，目前只有前两位有意义。</p>
<p>标志字段的最低位是 MF (More Fragment)。MF =1 表示后面“还有分片”。MF =0 表示最后一个分片。</p>
<p>标志字段中间的一位是 DF (Don’t Fragment)。只有当 DF =0 时才允许分片。</p>
<p>(7) <strong>片偏移</strong> 占13 位，指出：较长的分组在分片后，某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。具体例子见书P142</p>
<p>(8) <strong>生存时间</strong> 占8位，记为 TTL (Time To Live)，数据报在网络中可通过的路由器数的最大值。</p>
<p>(9) <strong>协议</strong> 占8位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给哪个处理过程</p>
<p>(10) <strong>首部检验和</strong> 占16位，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法</p>
<p>(11) <strong>源地址</strong> 占32位</p>
<p>(12) <strong>目的地址</strong> 占32位</p>
<p><strong>IP</strong> <strong>数据报首部的可变部分</strong></p>
<p>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。</p>
<p>选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。</p>
<p>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。</p>
<p>实际上这些选项很少被使用。</p>
<p><strong>IP分片</strong></p>
<p><strong>当发送的IP数据包的大小超过了MTU时</strong>，IP层就需要对数据进行分片，否则数据将无法发送成功。</p>
<p>IP分片发生在IP层，不仅源端主机会进行分片，中间的路由器也有可能分片，因为不同的网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU要小，路由器就可能对IP数据报再次进行分片。而分片数据的重组只会发生在目的端的IP层。</p>
<p>在IP首部有4个字节是用于分片的。前16位是IP数据报的标识，同一个数据报的各个分片的标识是一样的，目的端会根据这个标识来判断IP分片是否属于同一个IP数据报。中间3位是标志位，其中有1位用来表示是否有更多的分片，如果是最后一个分片，该标志位为0，否则为1。后面13位表示分片在原始数据的偏移，这里的原始数据是IP层收到的传输的TCP或UDP数据，不包含IP首部。</p>
<p>需要注意的，在分片的数据中，传输层的首部只会出现在第一个分片中。因为传输层的数据格式对IP层是透明的，传输层的首部只有在传输层才会有它的作用，IP层不知道也不需要保证在每个分片中都有传输层首部。所以，在网络上传输的数据包是有可能没有传输层首部的。</p>
<p><strong>避免ip分片</strong></p>
<p>在网络编程中，我们要避免出现IP分片，那么为什么要避免呢？原因是IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。</p>
<p><strong>如何避免</strong></p>
<p>对于UDP包，我们需要在应用层去限制每个包的大小，一般不要超过1472字节，即以太网MTU（1500）—UDP首部（8）—IP首部（20）。</p>
<p>对于TCP数据，应用层就不需要考虑这个问题了，因为传输层已经帮我们做了。在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment Size，最大报文段长度），MSS一般是MTU—IP首部（20）—TCP首部（20），每次发送的TCP数据都不会超过双方MSS的最小值，所以就保证了IP数据报不会超过MTU，避免了IP分片。</p>
<p><strong>分片顺序</strong></p>
<p>有标识字段可以确定分片属于哪一个报文，13位的片偏移可以确定分片的顺序。</p>
<p><strong>接收端如何确定分片均到达</strong></p>
<p>1）如果收到的包IP头中Fragmentation Flags为0且有UDP字段，则未分片<br>2）如果收到的包IP头中Fragmentation Flags为1且有UDP字段，则为第一片<br>3）如果收到的包IP头中Fragmentation Flags为1且无UDP字段，则为中间片<br>4）如果如果收到的包IP头中Fragmentation Flags为0且无UDP字段，则为最后一片</p>
<p><strong>IP选路</strong></p>
<p>IP选路，即IP寻路，就是根据路由表中的记录，来决定当前数据报是直接交付（目的地址属于当前局域网）还是发往下一跳路由（隶属于不同的局域网）。</p>
<p><strong>搜索匹配路由表步骤</strong></p>
<p>1.搜索匹配的主机地址；<br>2.搜索匹配网络地址；<br>3.搜索默认表项（一般0.0.0.0）<br>IP层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。 这区别于选路策略，它只是一组决定把哪些路由放入路由表的规则。</p>
<p><strong>简单路由表</strong></p>
<p>在计算机网络中，<strong>路由表或称路由择域信息库（RIB）</strong>是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的路由度量值）。路由表中含有网络周边的拓扑信息。路由表建立的主要目标是为了实现路由协议和静态路由选择。</p>
<p>在现代路由器构造中，路由表不直接参与数据包的传输，而是用于生成一个小型指向表，这个指向表仅仅包含由路由算法选择的数据包传输优先路径，这个表格通常为了优化硬件存储和查找而被压缩或提前编译</p>
<p>路由表项</p>
<p>路由表中的表项内容包括：</p>
<ul>
<li>destination：目的地址，用来标识IP包的目的地址或者目的网络。</li>
<li>mask：网络掩码，与目的地址一起标识目的主机或者路由器所在的网段的地址。</li>
<li>pre：标识路由加入IP路由表的优先级。可能到达一个目的地有多条路由，但是优先级的存在让他们先选择优先级高的路由进行利用。</li>
<li>cost：路由开销，当到达一个目的地的多个路由优先级相同时，路由开销最小的将成为最优路由。</li>
<li>interface：输出接口，说明IP包将从该路由器哪个接口转发。</li>
<li>nexthop：下一跳IP地址，说明IP包所经过的下一个路由器。</li>
</ul>
<p><strong>网际控制报文协议ICMP</strong></p>
<p>为了提高 IP 数据报交付成功的机会，在网际层使用了<strong>网际控制报文协议 ICMP (Internet Control Message Protocol)</strong>。</p>
<p>ICMP是为了解决两大问题：</p>
<p>1.反馈分组传送和到达中出现的各种错误</p>
<p>2.查询主机或路由器信息</p>
<p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。</p>
<p>ICMP 不是高层协议，而是 IP 层的协议。</p>
<p>ICMP 报文不直接传递给下层（数据链路层）而是作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。  </p>
<p><strong>ICMP协议报文格式</strong></p>
<p>类型                    代码                    检验和</p>
<p>（这四个字节取决于ICMP报文的类型）</p>
<p>ICMP的数据部分（长度取决于类型）</p>
<p>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。</p>
<p><strong>ICMP报文的种类</strong></p>
<p>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文和 ICMP 询问报文</strong>。 </p>
<p><strong>ICMP差错报文共有5种</strong></p>
<p><strong>终点不可达</strong>：当路由器或主机不能交付数据报时就向源点发送终点不可达报文</p>
<p><strong>源点抑制</strong>：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</p>
<p><strong>时间超过</strong>：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文</p>
<p><strong>参数问题</strong>：当路由器或目的主机收到数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文</p>
<p><strong>改变路由（重定向）</strong>：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）</p>
<p><strong>ICMP</strong> <strong>差错报告报文的数据字段的内容</strong></p>
<p>把收到的需要进行差错报告的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文数据字段。再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。</p>
<p><strong>不应发送 ICMP 差错报告报文的几种情况</strong></p>
<p>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</p>
<p>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</p>
<p>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</p>
<p>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</p>
<p><strong>ICMP</strong> <strong>询问报文有两种</strong></p>
<p><strong>回送请求和回答报文</strong> ICMP回送请求报文是有主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</p>
<p><strong>时间戳请求和回答报文</strong> ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用来进行时钟同步和测量时间。</p>
<p><strong>下面的几种 ICMP 报文不再使用</strong></p>
<p>信息请求与回答报文、掩码地址请求和回答报文、路由器询问和通告报文</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网-数据链路层</title>
    <url>/2020/04/02/%E8%AE%A1%E7%BD%91-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>按照CodeSheep讲的重点编写</p>
<h2 id="以太网帧的格式"><a href="#以太网帧的格式" class="headerlink" title="以太网帧的格式"></a>以太网帧的格式</h2><p><strong>封装成帧</strong>(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成一个帧。确定帧的界限。</p>
<p>首部和尾部的一个<strong>重要作用</strong>就是进行帧定界。</p>
<p>常用的以太网MAC帧格式有两种标准 ：<br>DIX Ethernet V2 标准<br>IEEE 的 802.3 标准</p>
<a id="more"></a>

<p>最常用的 MAC 帧是以太网 V2 的格式。</p>
<p>目的地址字段：6字节</p>
<p>源地址字段：6字节</p>
<p>类型字段：2字节。类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。</p>
<p>数据字段：45-1500字节。数据字段的正式名称是 MAC 客户数据字段<br>最小长度 64 字节 - 18 字节的首部和尾部 = 数据字段的最小长度  </p>
<p>FCS字段：4字节。当传输媒体的误码率为 1<em>10-8 时，MAC 子层可使未检测到的差错小于 1\</em>10-14。</p>
<p>FCS为帧检验序列，n在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。</p>
<p>当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。</p>
<p>在帧的前面插入的 8 字节中的第一个字段共 7 个字节，是前同步码，用来迅速实现 MAC 帧比特同步。第二个字段是帧开始定界符，表示后面的信息就是MAC 帧。</p>
<p>为了达到比特同步，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节</p>
<h2 id="MTU的概念"><a href="#MTU的概念" class="headerlink" title="MTU的概念"></a>MTU的概念</h2><p>MTU（Maximum Transmission Unit）最大传输单元。是一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。</p>
<p>1) 数据链路层的<strong>最小MTU 为 64 字节</strong>。对于 IEEE802.3，两个站点的最远距离不超过 2500m，由 4 个中继器连接而成，其冲突窗口为 51.2us(2 倍电缆传播延迟加上 4 个中继器的双向延迟).对于 10Mbps 的 IEEE802.3 来说，这个时间等于发送 64 字节，即 512 位的时间，64 字节就是由此而来的。如果一个站点已经传输了 512bit，就认为它已经占用了这个信道。</p>
<p>2) 数据链路层的<strong>最大 MTU 为 1500 字节</strong>，即数据字段的最大长度</p>
<h2 id="ARP协议、RARP协议"><a href="#ARP协议、RARP协议" class="headerlink" title="ARP协议、RARP协议"></a>ARP协议、RARP协议</h2><p><strong>ARP(Address Resolution Protocol)为地址解析协议</strong>，用来从网络层使用的IP地址解析出在数据链路层使用的硬件地址。</p>
<p><strong>地址解析协议ARP解决问题的方法</strong>是在主机ARP高速缓存中应存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或者超时删除）。每一个主机都设有一个 <strong>ARP 高速缓存(ARP cache)</strong>，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。这些都是该主机目前知道的一些地址。</p>
<p><strong>ARP高速缓存的作用</strong>：</p>
<p>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。ARP把保存在高速缓存中的每一个映射地址项目都设置生存时间。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目生存时间是很重要的。</p>
<p><strong>应当注意的问题</strong></p>
<p>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。<br>从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。<br>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。</p>
<p><strong>四种使用ARP的典型情况</strong></p>
<p>(1)  发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</p>
<p>(2)  发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</p>
<p>(3)  发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</p>
<p>(4)  发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。</p>
<p><strong>点对点链路不使用ARP</strong></p>
<p><strong>ARP协议的弱点</strong>：</p>
<p>1）缓存：主机的地址映射是基于高速缓存的，动态更新的。地址刷新是有时间限制的。 可以通过下次更新之前修改计算机上的地址缓存，造成拒绝服务攻击或者 ARP 欺骗。</p>
<p>2）广播: 攻击者可以伪装 ARP 应答。</p>
<p>3）ARP 应答没有认证，都是合法的。可以在不接受到请求的时候就发出应答包。</p>
<p><strong>ARP代理的概念和应用场景</strong></p>
<p>若 ARP 请求是从一个网络的主机发送给另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程叫做 ARP 代理。ARP 代理路由器响应 ARP 请求的 MAC 地址为路由器的 MAC 地址而非 ARP 请求的主机的 MAC 地址。</p>
<p>ARP 代理的应用环境：两个物理网络之间的路由是使用相同的网络号，两个路由器设置成 ARP 代理，实现相互隐瞒物理网络</p>
<p><strong>免费ARP</strong></p>
<p>指主机发送 ARP 查找自己的 IP 地址，即数据链路层 SIP=DIP</p>
<p>作用有两个：</p>
<p>1）一个主机使用免费 ARP 确定是有存在有其他主机设置了相同的 IP 地址</p>
<p>2）如果发送免费 ARP 的主机改变了 MAC 地址，可以通过发送免费 ARP 的方式告知其他主机端更新 ARP 表</p>
<p><strong>RARP协议</strong></p>
<p><strong>反向地址转换协议（RARP：Reverse Address Resolution Protocol）</strong> 反向地址转换协议（RARP）允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 <strong>IP 地址</strong>。网络管理员在局域网网关路由器里创建一个表以映射物理地址（MAC）和与其对应的 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向路由器上的 RARP 服务器请求相应的 IP 地址。假设在路由表中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。 RARP 可以使用于以太网、光纤分布式数据接口及令牌环 LAN</p>
<p><strong>工作原理</strong>：</p>
<p>1.发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p>
<p>2.本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p>
<p>3.如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p>
<p>4.如果不存在，RARP服务器对此不做任何的响应；</p>
<p>5.源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。 [1]</p>
<p><strong>工作过程</strong>：</p>
<p>1、网络上的每台设备都会有一个独一的硬件地址，通常是由设备厂商分配的MAC地址。PC1从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该PC的IP地址。</p>
<p>2、RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给PC1。</p>
<p>3、PC1收到RARP回应后，就使用得到的IP地址进行通讯。</p>
<p><strong>网卡的MAC地址和IP地址互查机制</strong></p>
<p>ARP协议用于将IP地址转为MAC地址<br>RARP协议用于将MAC地址转为IP地址</p>
<p><strong>ARP查询原理</strong></p>
<p>每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。</p>
<p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址。</p>
<p>如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。</p>
<p>此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。</p>
<p>如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中。</p>
<p>如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。</p>
<p>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。</p>
<p>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<p><strong>ARP报文格式</strong></p>
<p>ARP报文分为ARP请求和ARP应答报文两种，报文格式可以统一如下：</p>
<table>
<thead>
<tr>
<th>硬件类型</th>
<th>上层协议类型</th>
<th>MAC地址长度</th>
<th>IP地址长度</th>
<th>操作类型</th>
<th>源MAC地址</th>
<th>源IP地址</th>
<th>目的MAC地址</th>
<th>目的IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>4</td>
</tr>
</tbody></table>
<p>前五个为ARP报头。</p>
<ul>
<li>硬件类型：占两字节，表示ARP报文可以在哪种类型的网络上传输，值为1时表示为以太网地址。</li>
<li>上层协议类型：占两字节，表示硬件地址要映射的协议地址类型，映射IP地址时的值为0x0800。</li>
<li>MAC地址长度：占一字节，标识MAC地址长度，以字节为单位，此处为6。</li>
<li>IP协议地址长度：占一字节，标识IP得知长度，以字节为单位，此处为4。</li>
<li>操作类型：占2字节，指定本次ARP报文类型。1标识ARP请求报文，2标识ARP应答报文。</li>
<li>源MAC地址：占6字节，标识发送设备的硬件地址。</li>
<li>源IP地址：占4字节，标识发送方设备的IP地址。</li>
<li>目的MAC地址：占6字节，表示接收方设备的硬件地址，在请求报文中该字段值全为0，即00-00-00-00-00-00，表示任意地址，因为现在不知道这个MAC地址。</li>
<li>目的IP地址：占4字节，表示接受方的IP地址。</li>
</ul>
<p>ARP报文不是直接在网络层上发送的，它还是需要向下传输到数据链路层，所以当ARP报文传输到数据链路层之后，需要再次进行封装。以以太网为例，ARP报文传输到以太网数据链路层后会形成<strong>ARP帧</strong>。ARP帧如下所示，它就是在ARP报文前面加了一个以太网帧头。</p>
<table>
<thead>
<tr>
<th>目的MAC地址</th>
<th>源MAC地址</th>
<th>帧类型</th>
<th>硬件类型</th>
<th>上层协议类型</th>
<th>MAC地址长度</th>
<th>IP地址长度</th>
<th>操作类型</th>
<th>源MAC地址</th>
<th>源IP地址</th>
<th>目的MAC地址</th>
<th>目的IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>6</td>
<td>6</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>4</td>
<td>6</td>
<td>4</td>
</tr>
</tbody></table>
<p><strong>以太网帧头的三个字段说明</strong></p>
<ul>
<li>目的MAC地址：占6字节，如果是ARP请求帧，因为它是一个广播帧，所以要填上广播MAC地址（FF-FF-FF-FF-FF-FF），其目标主机是网络上的所有主机。</li>
<li>源MAC地址：占6字节，这是发送ARP帧的节点MAC地址。</li>
<li>帧类型：占两字节，这里用来标识帧封装的上层协议，因为本帧的数据部分是ARP报文，所以直接用ARP的协议号0x0806表示就可以了。</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网-TCP/IP协议</title>
    <url>/2020/04/01/%E8%AE%A1%E7%BD%91-TCP%20IP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="计网-TCP-IP协议"><a href="#计网-TCP-IP协议" class="headerlink" title="计网-TCP/IP协议"></a>计网-TCP/IP协议</h1><p>基础知识：</p>
<p>因特网的核心部分</p>
<p>因特网的核心部分是由许多网络和把它们互连起来的路由器组成，而主机处在因特网的边缘部分。</p>
<p><strong>主机</strong>的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。</p>
<p><strong>路由器</strong>：在网络核心部分起特殊作用</p>
<p><strong>路由器</strong>是实现<strong>分组交换(packet switching)</strong>的关键构件，其<strong>任务</strong>是转发收到的分组，这是网络核心部分最重要的功能。 </p>
<a id="more"></a>

<p>分组交换的<strong>主要特点</strong> ：</p>
<p>在发送端，先把较长的报文划分成较短的、固定长度的数据段。 </p>
<p>每一个数据段前面添加上首部构成<strong>分组</strong>。</p>
<p>接收端收到分组后剥去首部还原成报文。</p>
<p>最后，在接收端把收到的数据恢复成为原来的报文。</p>
<p><strong>分组交换的传输单元</strong>：分组交换网以<strong>“分组”</strong>作为数据传输单元。依次把各分组发送到接收端。</p>
<p><strong>分组首部的重要性</strong>：</p>
<p>每一个分组的首部都含有地址等控制信息。</p>
<p>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。</p>
<p>用这样的存储转发方式，最后分组就能到达最终目的地。</p>
<p>在路由器中的输入和输出端口之间没有直接连线。</p>
<p><strong>路由器处理分组的过程</strong>是：</p>
<p>把收到的分组先放入缓存（暂时存储）；</p>
<p>查找转发表，找出到某个目的地址应从哪个端口转发；</p>
<p>把分组送到适当的端口转发出去。 </p>
<p>分组交换的<strong>优点</strong></p>
<p><strong>高效</strong>  动态分配传输带宽，对通信链路是逐段占用。 </p>
<p><strong>灵活</strong>  以分组为传送单位和查找路由。</p>
<p><strong>迅速</strong>  不必先建立连接就能向其他主机发送分组。</p>
<p><strong>可靠</strong>  保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性</p>
<p>分组交换带来的<strong>问题</strong></p>
<p>分组在各结点存储转发时需要排队，这就会造成一定的<strong>时延</strong>。 </p>
<p>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的<strong>开销</strong>。 </p>
<h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><p>计算机网络的体系结构(architecture)是计算机网络的各层及其协议的集合。</p>
<p>体系结构就是这个计算机网络及其部件所应完成的功能的精确定义。</p>
<p>实现(implementation)是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。</p>
<p>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。 </p>
<p>分层的<strong>好处</strong></p>
<p>各层之间是独立的、灵活性好、结构上可分割开、易于实现和维护、能促进标准化工作。 </p>
<p><strong>TCP/IP协议体系认识</strong></p>
<p><strong>OSI（Open System Interconnection)有七层体系结构</strong>，概念清楚，理论也比较完善，但是它既复杂又不实用。</p>
<p><strong>OSI七层结构</strong>：</p>
<p><strong>1层物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。</p>
<p><strong>2层数据链路层</strong>：主要将从物理层接收的数据进行MAC地址（网卡地址）的封装与解封装。常把这一层叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。</p>
<p><strong>3层网络层</strong>：主要将从下层接收的数据进行IP地址的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。</p>
<p><strong>4层传输层</strong>：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性大，数据量大的数据），UDP（用户数据包协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层数据接收的数据进行分段和传输，到达目的地址后在进行重组。常常把这一层数据叫做段。</p>
<p><strong>5层会话层</strong>：通过传输层（端口号：传输段与接收端）建立数据传输的通路。主要在你的系统之间发起会话或者接收会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</p>
<p><strong>6层表示层</strong>：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够识别的东西，如图片、声音等）。</p>
<p><strong>7层应用层</strong>：主要是一些终端的应用，比如说FTD（各种文件下载）、WEB（IE浏览）、QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西，就是终端应用）。</p>
<p><strong>TCP/IP是四层的体系结构</strong>：应用层、运输层、网际层、网络接口层。但最下面的网络接口层并没有具体内容。</p>
<p><strong>第一层:网络接口层</strong></p>
<p>包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</p>
<p><strong>第二层:网际层</strong></p>
<p>对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p>
<p><strong>第三层:传输层</strong></p>
<p>对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</p>
<p><strong>第四层:应用层</strong></p>
<p>对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。</p>
<p>原文链接：<a href="https://blog.csdn.net/qq_41923622/java/article/details/85805003" target="_blank" rel="noopener">https://blog.csdn.net/qq_41923622/java/article/details/85805003</a></p>
<p>因此采取折中的办法：<strong>综合 OSI 和 TCP/IP 的优点</strong>，采用一种只有<strong>五层协议</strong>的体系结构 。</p>
<p>即应用层、运输层、网际层、数据链路层、物理层。其中应用层对应OSI的应用层、表示层和会话层</p>
<p><strong>实体</strong>：表示任何可发送或接收信息的硬件或软件进程。 </p>
<p><strong>协议</strong>：控制两个对等实体进行通信的规则的集合。 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务。 </p>
<p>本层的服务用户只能看见服务而无法看见下面的协议。</p>
<p>下面的协议对上面的服务用户是透明的。 </p>
<p><strong>协议是“水平的”</strong>，即协议是控制对等实体之间通信的规则。</p>
<p><strong>服务是“垂直的”</strong>，即服务是由下层向上层通过层间接口提供的。</p>
<p>同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)。 </p>
<p><strong>路由器在转发分组时最高只用到网络层而没有使用运输层和应用层。</strong> </p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-正则表达式</title>
    <url>/2020/03/31/JavaSE-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>正则表达式</p>
<p>正则表达式用于操作<strong>字符串</strong>数据</p>
<p> 通过一些特定的<strong>符号</strong>来体现</p>
<p> 所以我们为了掌握正则表达式，必须要学习一些<strong>符号</strong>。</p>
<p> 虽然<strong>简化</strong>了，但是<strong>阅读性变差</strong>了。</p>
<p>举例</p>
<p>需求：定义一个功能对qq号进行校验</p>
<p>要求：长度5-15位，只能是数字，0不能开头</p>
<a id="more"></a>

<p>举例</p>
<p>需求：定义一个功能对qq号进行校验</p>
<p>要求：长度5-15位，只能是数字，0不能开头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String qq = <span class="string">"215212489"</span>;</span><br><span class="line">String regex = <span class="string">"[1-9][0-9]&#123;4,14&#125;"</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = qq.matches(regex);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>

<h2 id="2-常见的规则"><a href="#2-常见的规则" class="headerlink" title="2 常见的规则"></a>2 常见的规则</h2><p>字符：</p>
<p>​           x 字符 x。举例：’a’表示字符a</p>
<p>​           \ 反斜线字符。</p>
<p>​           \n 新行（换行）符 (‘\u000A’) </p>
<p>​           \r 回车符 (‘\u000D’)</p>
<p>​       字符类：</p>
<p>​           [abc] a、b 或 c（简单类） </p>
<p>​           [^abc] 任何字符，除了 a、b 或 c</p>
<p>​           [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内 </p>
<p>​           [0-9] 0到9的字符都包括</p>
<p>​       预定义字符类：</p>
<p>​           . 任何字符。.本身用 .表示</p>
<p>​           \d 数字：[0-9]</p>
<p>​           \w 单词字符：[a-zA-Z_0-9]</p>
<p>​              在正则表达式里面组成单词的东西必须有这些东西组成</p>
<p>​       边界匹配器：</p>
<p>​           ^ 行的开头 </p>
<p>​           $ 行的结尾 </p>
<p>​           \b 单词边界</p>
<p>​              就是不是单词字符的地方。</p>
<p>​              举例：hello world?haha;xixi </p>
<p>​       数量词： </p>
<p>​           X? X，一次或一次也没有</p>
<p>​           X* X，零次或多次</p>
<p>​           X+ X，一次或多次</p>
<p>​           X{n} X，恰好 n 次 </p>
<p>​           X{n,} X，至少 n 次 </p>
<p>​           X{n,m} X，至少 n 次，但是不超过 m 次</p>
<h2 id="3-常见的功能-匹配"><a href="#3-常见的功能-匹配" class="headerlink" title="3 常见的功能-匹配"></a><strong>3 常见的功能-匹配</strong></h2><p>匹配</p>
<p>其实就是String类中的matches方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配手机号码是否正确</span></span><br><span class="line">String tel = <span class="string">"15800001111"</span>;</span><br><span class="line">String regex = <span class="string">"1[358][0-9]&#123;9&#125;"</span>;</span><br><span class="line">String regex2 = <span class="string">"1[358]\\d&#123;9&#125;"</span>;<span class="comment">//这两个意思一样</span></span><br></pre></td></tr></table></figure>

<p>第二种写法中用两个\，是因为\在字符串当中自动对后面字母进行转义，所以要再加一个\使得字母前的\为一般的\。</p>
<h2 id="4-常见的功能-切割"><a href="#4-常见的功能-切割" class="headerlink" title="4 常见的功能-切割"></a><strong>4 常见的功能-切割</strong></h2><p>切割</p>
<p>其实就是String类中的split方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"zhangsan    xiaoqiang   zhaoliu"</span>;</span><br><span class="line">String str3 = <span class="string">"zhangsan.xiaoqiang.zhaoliu"</span>;</span><br><span class="line">String str3 = <span class="string">"zhangsantttxiaoqiangmmmmzhaoliu"</span>;</span><br><span class="line">String[] names = str.split(<span class="string">" +"</span>);<span class="comment">//表示至少一个空格</span></span><br><span class="line">String[] names2 = str.split(<span class="string">"\\."</span>);<span class="comment">//单个.表示任意字符，所以需要转义</span></span><br><span class="line">String[] names3 = str.split(<span class="string">"(.)\\1+"</span>);<span class="comment">//正则规则中用于封装的形式是小括号。为了能使用没有名字但有编号，称之为组。"(.)\\1+"表示在使用第一组的内容，且后面的内用都与第一个内容相同</span></span><br></pre></td></tr></table></figure>

<p>组：捕获组可以通过从左到右计算其开括号来编号。例如在表达式中((A)(B(C))存在四个组</p>
<ol>
<li>((A)(B(C)) 2.\A 3. (B(C)) 4. (C)</li>
</ol>
<p>组零始终代表整个表达式</p>
<h2 id="5-常见的功能-替换"><a href="#5-常见的功能-替换" class="headerlink" title="5 常见的功能-替换"></a><strong>5 常见的功能-替换</strong></h2><p>替换</p>
<p>其实就是String类中的replaceAll方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">"zhangsantttxiaoqiangmmmmmmzhaoliu"</span>;</span><br><span class="line">String str1=str.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"#"</span>);</span><br><span class="line">String str2=str.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"$1"</span>);<span class="comment">//美元符号可以对前一个正则表达式中规则进行获取</span></span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br><span class="line">String tel=<span class="string">"15832132122"</span>;</span><br><span class="line">tel=tel.replaceAll(<span class="string">"(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)"</span>, <span class="string">"$1****$2"</span>);</span><br><span class="line">System.out.println(tel);</span><br><span class="line">结果：zhangsan#xiaoqiang#zhaoliu</span><br><span class="line">	 zhangsantxiaoqiangmzhaoliu</span><br><span class="line">	 <span class="number">158</span>****<span class="number">2122</span></span><br></pre></td></tr></table></figure>

<h2 id="6-常见的功能-获取"><a href="#6-常见的功能-获取" class="headerlink" title="6 常见的功能-获取"></a><strong>6 常见的功能-获取</strong></h2><p>这里要用到一个类：Pattern</p>
<p>​     此类为正则表达式的编译表示形式</p>
<p>​     指定为字符串的正则表达式必须首先被编译为此类的实例。然后，可将得到的模式用于创建Matcher对象，依照正则表达式，该对象可以与任意字符序列匹配。执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式</p>
<p>​     调用顺序</p>
<p>​     将正则规则进行对象的封装</p>
<p>​     Pattern p=Pattern.compile(“a*b”);</p>
<p>​     通过正则对象的matcher方法和字符串关联，获取要对字符串操作的匹配器对象Matcher</p>
<p>​     Matcher m=p.matcher(“aaaaa”);</p>
<p>​     通过Matcher匹配器对象的方法对字符串进行操作</p>
<p>​     boolean b=m.matched();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"da jia hao,ming tian bu fang jia!"</span>;</span><br><span class="line">String regex = <span class="string">"\\b[a-z]&#123;3&#125;\\b"</span>;<span class="comment">//\\b表示单词边界</span></span><br><span class="line"><span class="comment">//1.将正则封装成对象</span></span><br><span class="line">Pattern p = Pattern.compile(regex);</span><br><span class="line"><span class="comment">//2.通过正则对象获取匹配器对象</span></span><br><span class="line">Matcher m = p.matcher(str);</span><br><span class="line"><span class="comment">//3.使用Matcher对象的方法对字符串操作</span></span><br><span class="line"><span class="comment">//既然要获取三个字符组成的单词，就查找：boolean find();</span></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">    System.out.println(m.group());<span class="comment">//获取匹配的子序列</span></span><br><span class="line">    System.out.println(m.start() + <span class="string">":"</span> + m.end());<span class="comment">//拿到字母在之前字符串中的位置</span></span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">    jia</span><br><span class="line">    <span class="number">3</span>:<span class="number">6</span></span><br><span class="line">    hao</span><br><span class="line">    <span class="number">7</span>:<span class="number">10</span></span><br><span class="line">    jia</span><br><span class="line">    <span class="number">29</span>:<span class="number">32</span></span><br></pre></td></tr></table></figure>















]]></content>
      <tags>
        <tag>JaveSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-</title>
    <url>/2020/03/30/JavaSE-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><h2 id="1-概述-amp-应用场景"><a href="#1-概述-amp-应用场景" class="headerlink" title="1 概述&amp;应用场景"></a><strong>1 概述&amp;应用场景</strong></h2><p>Java反射机制是在运行状态中，对于任意一个类（class文件），都能够知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用它的任意一个方法和属性；</p>
<p>这种动态获取的信息以及动态调用对象的方法的功能称为<strong>java语言的反射机制。</strong></p>
<a id="more"></a>

<p>动态获取类中信息，就是java反射</p>
<p>可以理解为对类的解剖。</p>
<p>提高了程序的扩展性</p>
<p>可以直接面对配置文件即可开发</p>
<p>应用场景：当有一个写好的应用程序，想要往里面传入新对象并使用其方法功能时，以前在知道程序源码时可以直接在new一个对象。但现在不知道其源码时，就使用到了反射方法，让类继承程序的接口，相当于可以直接给程序一个类，让其找到对应的配置文件。<strong>反射方法可以使程序对指定名称的字节码文件进行加载并获取其中内容并调用。</strong></p>
<p>Tomcat提供了处理请求和应答方式，因为具体的处理动作不同，所以对外提供了接口，有开发者来实现具体请求和应答处理。这个接口为Servlet。</p>
<p><strong>反射机制要素</strong>：接口、配置文件</p>
<h2 id="2-细节-amp-class对象"><a href="#2-细节-amp-class对象" class="headerlink" title="2 细节&amp;class对象"></a><strong>2 细节&amp;class对象</strong></h2><p>如何可以得到一个类的字节码文件内的信息？</p>
<p>每个字节码文件都是属于Class对象。该对象内有提供获取字节码文件中的内容（名称、字段、构造函数、一般函数）。改就就可以获取字节码文件中的所有内容。所以反射是依靠该类完成。</p>
<p>想要对一个类文件进行解剖，只要获取该类的字节码文件对象即可，</p>
<h2 id="3-获取class对象的三种方式"><a href="#3-获取class对象的三种方式" class="headerlink" title="3 获取class对象的三种方式"></a><strong>3 获取class对象的三种方式</strong></h2><p>获取字节码对象的方式：</p>
<p>1.Object类中的getClass()方法</p>
<p>想要用这种方式，必须要明确具体的类，并创建对象。</p>
<p>麻烦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz = p.getClass();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Perosn();</span><br><span class="line">Class clazz1 = p1.getClass();</span><br></pre></td></tr></table></figure>

<p>2.任何数据类型都具备一个静态的属性，class来获取其对应的class对象。</p>
<p> 相对简单，但是还是要明确用到类中的静态成员</p>
<p> 还是不够扩展</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class clazz1 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>3.只要通过给定的类的字符串名称就可以获取该类，更为扩展</p>
<p> 可以使用Class类中的方法完成。</p>
<p> 该方法为forName(String className);返回与带有给定字符串名的类或接口相关联的class对象。参数要带上包名。</p>
<p> 这种方式只要有名称即可，更为方便，扩展性更强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = <span class="string">"cn.it.cast.bean.Person"</span>;</span><br><span class="line">Class clazz = Class.forName(className);</span><br></pre></td></tr></table></figure>

<h2 id="4-获取Class中的构造函数"><a href="#4-获取Class中的构造函数" class="headerlink" title="4 获取Class中的构造函数"></a><strong>4 获取Class中的构造函数</strong></h2><p>早期：new的时候，先根据被new的名称找寻该类的字节码文件，并加载进内存，并创建该字节码文件对象，并接着创建该字节码文件的对应的Person对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cn.it.cast.bean.Person p = <span class="keyword">new</span> cn.it.cast.bean.Person();</span><br></pre></td></tr></table></figure>

<p>现在：找寻该名称类文件，并加载内存，并产生Class对象。使用<strong>newInstance();</strong>创建此class对象所表示类的一个新实例。如同用一个带有空参数列表的new表达式实例化该类。如果该类尚未初始化，则初始化该类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = <span class="string">"cn.it.cast.bean.Person"</span>;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Object obj = clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>第一种方法需要自己手动new一个，而第二种方法可以封装成方法，只要给一个类的名字的窗口，在这个窗口输入类的名字，程序就能自动帮new一个对象。</p>
<p>当要获取指定名称对应类中的所体现的对象时，而该对象初始化不使用空参数构造该怎么办呢？</p>
<p>早期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cn.it.cast.bean.Person p = <span class="keyword">new</span> cn.it.cast.bean.Person(<span class="string">"aaa"</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>现在：</p>
<p>既然是通过指定的构造函数进行对象的初始化，所以应该先获取到该构造函数。通过字节码文件对象即可完成</p>
<p>该方法是：<br>getConstructors();返回一个包含某些构造函数对象的数组，这些对象反映此Class对象所表示的类的<strong>所有公共</strong>构造方法</p>
<p>getConstructors(paramTpyes);返回一个Constructor对象，它反映此Class对象所表示的类的<strong>指定公共</strong>构造方法。</p>
<p>getDeclaredConstructors()；返回一个包含某些构造函数对象的数组，这些对象反映此Class对象所表示的类的<strong>所有</strong>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = <span class="string">"cn.it.cast.bean.Person"</span>;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Constructor constructor = clazz.getConstructors(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"aaa"</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-获取Class中的字段"><a href="#5-获取Class中的字段" class="headerlink" title="5 获取Class中的字段"></a><strong>5 获取Class中的字段</strong></h2><p>获取字节码文件中的字段</p>
<p> getField();返回一个Field对象，反映此Class对象所表示的类或接口的<strong>指定公共</strong>成员字段</p>
<p> getFields();返回一个Field对象数组，反映此Class对象所表示的类或接口的<strong>所有可访问公共</strong>成员字段</p>
<p> getDeclaredField();返回一个Field对象，反映此Class对象所表示的类或接口的<strong>指定字段</strong></p>
<p> getDeclaredFields();返回一个Field对象数组，反映此Class对象所表示的类或接口的<strong>所有字段</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"cn.it.cast.bean.Person"</span>);</span><br><span class="line">Field field = <span class="keyword">null</span>;</span><br><span class="line">field = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">//对私有字段的访问取消权限检查。暴力访问</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);<span class="comment">//原先是没有权限访问私有字段</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">field.set(obj,<span class="number">55</span>);<span class="comment">//对字段设置值</span></span><br><span class="line">Object o = field.get(obj);<span class="comment">//操作字段就需要有对象，没有对象操作字段是没有意义的。</span></span><br><span class="line">System.out.println(o);</span><br><span class="line">结果：<span class="number">55</span>;</span><br></pre></td></tr></table></figure>



<h2 id="6-获取Class中的方法"><a href="#6-获取Class中的方法" class="headerlink" title="6 获取Class中的方法"></a><strong>6 获取Class中的方法</strong></h2><p>获取指定class中的函数   </p>
<p> getMethod();返回一个Method对象，反映此Class对象所表示的类或接口的指定<strong>公共方法</strong></p>
<p> getMethods();返回一个Field对象数组，反映此Class对象所表示的类或接口的<strong>所有可访问公共方法</strong></p>
<p> getDeclaredMethod();返回一个Field对象，反映此Class对象所表示的类或接口的<strong>指定方法</strong></p>
<p> getDeclaredMethods();返回一个Field对象数组，反映此Class对象所表示的类或接口的<strong>所有方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"cn.it.cast.bean.Person"</span>);</span><br><span class="line">Method[] methods = clazz.getMethods();<span class="comment">//获取的都是公有方法</span></span><br><span class="line">Method[] methods2 = clazz.getDeclaredMethods();<span class="comment">//获取本类中所有方法，包含私有。</span></span><br></pre></td></tr></table></figure>

<p>空参方法获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"cn.it.cast.bean.Person"</span>);</span><br><span class="line">Method method = clazz.getMethod(<span class="string">"show"</span>, <span class="keyword">null</span>);<span class="comment">//获取空参数一般方法</span></span><br><span class="line">Constructor constructor = <span class="class"><span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">String</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"aaa"</span>, <span class="number">5</span>);</span><br><span class="line">method.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>非空参方法获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"cn.it.cast.bean.Person"</span>);</span><br><span class="line">Method method = clazz.getMethod(<span class="string">"paraMethod"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Object obj = clazz.newInstance(<span class="string">"aaa"</span>, <span class="number">5</span>);</span><br><span class="line">method.invoke(obj, <span class="string">"aaa"</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

























]]></content>
      <tags>
        <tag>JaveSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-网络编程</title>
    <url>/2020/03/29/JavaSE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="1-网络模型概述"><a href="#1-网络模型概述" class="headerlink" title="1 网络模型概述"></a><strong>1 网络模型概述</strong></h2><p>网络编程（具体内容看计算机网络）</p>
<p>OSI（Open System Interconncetion开放系统互连）参考模型</p>
<p>TCP/IP参考模型</p>
<p>OSI七层协议模型</p>
<a id="more"></a>

<p>1层物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。</p>
<p>2层数据链路层：主要将从物理层接收的数据进行MAC地址（网卡地址）的封装与解封装。常把这一层叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。</p>
<p>3层网络层：主要将从下层接收的数据进行IP地址的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。</p>
<p>4层传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性大，数据量大的数据），UDP（用户数据包协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层数据接收的数据进行分段和传输，到达目的地址后在进行重组。常常把这一层数据叫做段。</p>
<p>5层会话层：通过传输层（端口号：传输段与接收端）建立数据传输的通路。主要在你的系统之间发起会话或者接收会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</p>
<p>6层表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够识别的东西，如图片、声音等）。</p>
<p>7层应用层：主要是一些终端的应用，比如说FTD（各种文件下载）、WEB（IE浏览）、QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西，就是终端应用）。</p>
<p>TCP/IP模型将上述7层简化成4层。</p>
<p>应用层、传输层、网际层、主机至网络层</p>
<h2 id="2-网络要素-IP地址"><a href="#2-网络要素-IP地址" class="headerlink" title="2 网络要素-IP地址"></a><strong>2 网络要素-IP地址</strong></h2><p>网络通讯要素：IP地址、端口号、传输协议</p>
<p>IP地址：InetAddress</p>
<p>网络中设备的标识</p>
<p>不易记忆，可用主机名</p>
<p>本地回环地址：127.0.0.1 用来测试网卡，只能访问本地 主机名：localhost</p>
<h2 id="3-网络要素-端口"><a href="#3-网络要素-端口" class="headerlink" title="3 网络要素-端口"></a><strong>3 网络要素-端口</strong></h2><p>端口号：用于标识进程的逻辑地址，不同进程的标识</p>
<p>有效端口：0<del>65535，其中0</del>1024系统使用或保留端口（尽量不要用，系统本身会使用很多这部分的端口，不要与系统冲突）。</p>
<p>比如QQ，若要向另一个主机传送信息，则会识别端口，可以得到是QQ传输的信息</p>
<p>防火墙的原理就是禁用了相关的端口导致信息传递接收失败</p>
<h2 id="4-网络要素-传输协议"><a href="#4-网络要素-传输协议" class="headerlink" title="4 网络要素-传输协议"></a><strong>4 网络要素-传输协议</strong></h2><p>传输协议：通讯的规则</p>
<p>常见协议：TCP,UDP</p>
<p>UDP</p>
<p>将数据及源和目的封装成数据包中，将数据包扔出，不需要建立连接，即对方不在也可以发出数据</p>
<p>每个数据包的大小在限制在64k内，但可以进行大数据量传输</p>
<p>因无连接，是不可靠协议</p>
<p>不需要建立连接，速度快</p>
<p>比如qq发信息，视频通话，对讲机</p>
<p>TCP</p>
<p>建立连接，形成传输数据的通道，即必须对方在才能发出数据，通过三次握手来判断对方是否在线。</p>
<p>在连接中进行大数据量传输</p>
<p>通过三次握手完成连接，是可靠协议</p>
<p>必须建立连接，效率会稍低</p>
<p>比如打电话。</p>
<h2 id="5-IP对象-InetAddress"><a href="#5-IP对象-InetAddress" class="headerlink" title="5  IP对象-InetAddress"></a><strong>5  IP对象-InetAddress</strong></h2><p>InetAddress:此类表示互联网协议地址，处于网际层。</p>
<p>无构造函数，所以存在一个方法能够返回该对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取本地主机ip地址对象</span></span><br><span class="line">InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">ip.getHostAddress();<span class="comment">//获得本地ip地址</span></span><br><span class="line">ip.getHostName();<span class="comment">//获取本地主机名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其他主机ip地址对象</span></span><br><span class="line">ip = InetAddress.getByName(<span class="string">"主机名或ip地址"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="6-域名解析"><a href="#6-域名解析" class="headerlink" title="6 域名解析"></a><strong>6 域名解析</strong></h2><p>域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址。<strong>域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成</strong></p>
<p>例如：<a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></p>
<p>www为主机名字、sina为域名名称、com为商业化组织代号、cn代表所属国家。</p>
<p>回车时，该网址就是指向指定的ip地址，但并不是直接转向。在中间存在一个主机存放一些列表，里面有ip地址与名称的对应。这个主机叫做域名解析服务器，这个过程叫域名解析。所以过程就是输入网址后，先通过DNS找到对应的ip地址，再转到该ip地址对应的网页。DNS可以用国内的，国外的，不同运营商的。</p>
<p>提高解析速度可以使用本地解析。在本机里面有一张域名解析列表</p>
<p>在C:\Windows\System\drivers\etc\hosts中</p>
<p>里面可以指定ip地址对应的主机。</p>
<p>该方法可以屏蔽一些网站，只要在自己匹配域名地址和ip地址就行</p>
<p><strong>这也说明在解析当中，先进行本地解析</strong>。</p>
<h2 id="7-UDP协议-发送端"><a href="#7-UDP协议-发送端" class="headerlink" title="7 UDP协议-发送端"></a><strong>7 UDP协议-发送端</strong></h2><p>Socket:为网络服务提供的一种机制。</p>
<p>通信两端都有Socket，网络通信其实就是Socket间的通信，数据在两个Socket间通过IO传输。</p>
<p>UDP传输</p>
<p>DatagramSocket：用来发送和接收数据报包的<strong>套接字</strong>，是包投递服务的发送或接收点。</p>
<p>DatagramPacket：表示数据报包，用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。不对包投递做出保证。其方法中凡是带有地址参数的均是投递用的方法。</p>
<p>创建UDP传输的发送端</p>
<p>思路：</p>
<p>1.建立UDP的Socket服务。</p>
<p>2.将要发送的数据封装到包中。</p>
<p>3.通过UDP的Socket服务将数据包发送出去。</p>
<p>4.关闭Socket服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">String str = <span class="string">"udp传输演示0"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buf = str.getBytes();</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getByName(<span class="string">"ip地址"</span>), <span class="number">10000</span>);<span class="comment">//参数分别是：数组、数组长度、地址名称、端口名</span></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">ds.send(dp);</span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure>

<h2 id="8-UDP协议-接收端"><a href="#8-UDP协议-接收端" class="headerlink" title="8  UDP协议-接收端"></a><strong>8  UDP协议-接收端</strong></h2><p>建立UDP接收端的思路</p>
<p>思路：</p>
<p>1.建立UDP Socket服务,因为是要接收数据，必须要明确一个端口号</p>
<p>2.创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据</p>
<p>3.使用Socket服务的receive方法将接收的数据存储到数据包中。</p>
<p>4.通过数据包的方法解析数据包中的数据。</p>
<p>5.关闭数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10000</span>);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">ds.recieve(dp);</span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line">String ip = dp.getAddress().getHostAddress();</span><br><span class="line"><span class="keyword">int</span> port = dp.getPort();</span><br><span class="line">String text = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</span><br><span class="line">System.out.println(ip + <span class="string">":"</span> + port + text);</span><br></pre></td></tr></table></figure>

<h2 id="9-UDP协议-聊天程序"><a href="#9-UDP协议-聊天程序" class="headerlink" title="9  UDP协议-聊天程序"></a><strong>9  UDP协议-聊天程序</strong></h2><p>这要用到多线程，一个用来发送一个用来接收。</p>
<p>若想要群发，就将发送地址改写为192.168.1.255。0是网络位，不能用。1-254是有效ip地址。255是广播地址，即若将地址写为255，则能发送到该广播地址所有网段存活的机器上。</p>
<h2 id="10-TCP协议-客户端"><a href="#10-TCP协议-客户端" class="headerlink" title="10  TCP协议-客户端"></a><strong>10  TCP协议-客户端</strong></h2><p>TCP传输分为两个端点，分别是客户端和服务端</p>
<p><strong>需要用到Socket和ServerSocket对象</strong>。</p>
<p>客户端发数据到服务端</p>
<p> 即TCP传输：客户端建立的过程。</p>
<p> 1.创建tcp客户端socket服务。使用的是Socket对象</p>
<p>   建议该对象一创建就明确目的地，要连接的主机</p>
<p> 2.如果连接建立成功，说明数据传输通道已建立。</p>
<p>   该通道就是Socket流，其是底层建立好的。既然是流，说明这里既有输入又有输出</p>
<p>   想要输入或者输出流对象，可以找Socket对象来获取。</p>
<p>   可以通过getOutputStream()和getInputStream()来获取两个字节源</p>
<p> 3.使用输出流，将数据写出。</p>
<p> 4.关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"ip地址"</span>, <span class="number">10002</span><span class="comment">/*端口号*/</span>);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">out.write(<span class="string">"tcp演示"</span>.getBytes());</span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line">sockcet.close();</span><br></pre></td></tr></table></figure>

<p><strong>11 TCP协议-服务端</strong></p>
<p>服务端接收客户端发来的数据并打印在控制台上</p>
<p> 建立tcp服务端的思路：</p>
<p> 1.创建服务端socket服务。通过ServerSocket对象</p>
<p> 2.服务端必须对外提供一个端口，否则客户端无法连接</p>
<p> 3.获取连接过来的客户端对象。这样就能实现服务端对指定客户端的数据传输</p>
<p> 4.通过客户端对象获取socket流读取客户端发来的数据，并打印在控制台上。</p>
<p> 5.关闭资源。关客户端，关服务端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10002</span>);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">Socket s = ss.accept();<span class="comment">//该方法可以获取客户端对象</span></span><br><span class="line">String ip = s.getInetAddress().getHostAddress();</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">InputStream in = s.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">String text = <span class="keyword">new</span> String(buf, <span class="number">0</span> ,len);</span><br><span class="line">System.out.println(text);</span><br><span class="line">s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure>

<p>获取客户端对象是阻塞式。</p>
<p>注意：要先开服务端。</p>
<h2 id="12-TCP协议-服务端和客户端交互"><a href="#12-TCP协议-服务端和客户端交互" class="headerlink" title="12 TCP协议-服务端和客户端交互"></a><strong>12 TCP协议-服务端和客户端交互</strong></h2><p>如果服务端发出数据，客户端来接收，同样也是使用socket流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用客户端socket对象输出流给客户端返回数据</span></span><br><span class="line">OutputStream out = s.getOutputStream();</span><br><span class="line">out.write(<span class="string">"收到"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取服务端返回的数据，使用socket读取流</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br></pre></td></tr></table></figure>

<h2 id="13-TCP协议-练习-服务端多线程技术"><a href="#13-TCP协议-练习-服务端多线程技术" class="headerlink" title="13 TCP协议-练习-服务端多线程技术"></a><strong>13 TCP协议-练习-服务端多线程技术</strong></h2><p>上述程序存在一个问题，因为一直是一个线程运作，所以当有人占用服务端时，其他人就必须排队，所以要使用多线程。当有人要使用服务器时，服务端接收到客户端后，产生新的线程对象，用来运行该客户端发来的数据或任务。主线程重新回到等待接收客户端状态。也就是<strong>服务器原理</strong>。</p>
<h2 id="14-常见客户端和服务端"><a href="#14-常见客户端和服务端" class="headerlink" title="14 常见客户端和服务端"></a><strong>14 常见客户端和服务端</strong></h2><p>最常见的客户端：</p>
<p>​    浏览器：IE</p>
<p>最常见的服务端：</p>
<p>​    服务器：Tomcat</p>
<p>Interface Servlet是接口，写在服务器上面的程序，功能都要实现这一接口才能使用</p>
<p>其余部分详见视频或自查资料。</p>
<h2 id="15-了解客户端和服务器端原理"><a href="#15-了解客户端和服务器端原理" class="headerlink" title="15 了解客户端和服务器端原理"></a><strong>15 了解客户端和服务器端原理</strong></h2><p>为了了解其原理：</p>
<p>1.</p>
<p>自定义服务器</p>
<p>使用已有的客户端IE，了解一下客户端给服务端发送了什么请求</p>
<p>编写程序</p>
<p>然后打开浏览器，在网页输入ip地址＋端口</p>
<p>将接收到的信息复制粘贴过来</p>
<p>GET / HTTP/1.1  <strong>请求行</strong>，遵从了http协议而来：请求方式/请求的资源路径/http协议版本</p>
<p><strong>请求消息头</strong> 属性名：属性值（即支持的东西，比如支持html格式的text文件）</p>
<p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p>
<p>Accept-Language: zh-CN</p>
<p>Upgrade-Insecure-Requests: 1</p>
<p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.18362</p>
<p>Accept-Encoding: gzip, deflate 支持的压缩方式（网页压缩方式）</p>
<p>Host: 192.168.1.105:9099</p>
<p>Connection: Keep-Alive</p>
<p>//<strong>空行</strong></p>
<p>//<strong>请求体</strong>：指定的自定义信息。请求体和请求头之间要有空行。</p>
<h2 id="16-URL-amp-URLConnection"><a href="#16-URL-amp-URLConnection" class="headerlink" title="16 URL&amp;URLConnection"></a><strong>16 URL&amp;URLConnection</strong></h2><p>从服务器端回来的数据需要解析，java中的URL对象提供了方法。</p>
<p><strong>URL代表一个统一资源定位符</strong>，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更复杂对象的引用，例如对数据库或搜索引擎的查询。</p>
<p><a href="http://192.168.1.105:9099/" target="_blank" rel="noopener">http://192.168.1.105:9099/</a> 这一个就是URL</p>
<p>URI是统一资源标识符。</p>
<p>笼统地说每个URL都是URI，但不一定每个URI都是URL。因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。</p>
<p>使用URL的方法可以得到该定位符里具体的信息</p>
<p>代码演示略</p>
<p>使用URL中的openStream()方法可以打开此URL的连接并返回一个用于从该连接读入的InputStream，再读取流中内容就可以得到服务器传来的信息。</p>
<p>代码演示略</p>
<p>openStream（）方法的原理是URL使用openConnection方法得到一个<strong>URLConnection</strong>对象，即获取url对象的url连接器对象，将连接封装成了对象：java中内置的可以解析的具体协议的对象+socket。</p>
<p>然后再使用连接器对象中getInputStream方法可以得到相同的结果。</p>
<p>代码演示略</p>
<h2 id="17-常见网络架构"><a href="#17-常见网络架构" class="headerlink" title="17 常见网络架构"></a>17 常见网络架构</h2><p>网络结构：</p>
<p>1.C/S client/server</p>
<p>​    特点：</p>
<p>​       该结构的软件，客户端和服务端都需要编写。</p>
<p>​       开发成本较高，维护较为麻烦</p>
<p>​    好处：</p>
<p>​       客户端在本地可以分担一部分运算。</p>
<p>2.B/S browser/server</p>
<p>​    特点：</p>
<p>​       该结构的软件，只开发服务器，不开发客户端，因为客户端直接由浏览器取代</p>
<p>​       开发成本相对低，维护更为简单。</p>
<p>​    缺点：所有运算都要在服务器端完成</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-IO流3</title>
    <url>/2020/03/28/JavaSE-IO%E6%B5%813/</url>
    <content><![CDATA[<h1 id="IO流3"><a href="#IO流3" class="headerlink" title="IO流3"></a>IO流3</h1><h2 id="打印流-PrintStream"><a href="#打印流-PrintStream" class="headerlink" title="打印流-PrintStream"></a><strong>打印流-PrintStream</strong></h2><p>PrintWriter与PrintStream：可以直接操作输入流和文件</p>
<p>PrintStream：为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。它还提供其他两项功能。与其他输出流不同</p>
<p>永远不会抛出IOException</p>
<p>它打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类。</p>
<a id="more"></a>

<p>PrintStream:</p>
<p>1.提供了打印方法可以对多种数据类型值进行打印。并保持数据的表示形式</p>
<p>2.它不抛IOException</p>
<p>构造函数接收三种类型的值</p>
<p>1.字符串路径</p>
<p>2.File对象</p>
<p>3.字节输出流</p>
<p>write():只写入数据的最低8位。</p>
<p>print():将输入的数据变成字符串保持原样将数据打印到目的地</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream out = <span class="keyword">new</span> PrintStream(<span class="string">"print.txt"</span>);</span><br><span class="line">out.write(<span class="number">97</span>);<span class="comment">//只写最低8位</span></span><br><span class="line">out.write(<span class="number">609</span>);</span><br><span class="line">out.print(<span class="number">97</span>);<span class="comment">//将97先变成字符串保持原样将数据打印到目的地</span></span><br></pre></td></tr></table></figure>

<p>PrintWriter:字符打印流</p>
<p>   构造函数参数：</p>
<p>   1.字符串路径</p>
<p>   2.File对象</p>
<p>   3.字节输出流</p>
<p>   4.字符输出流</p>
<h2 id="序列流-SequenceInputStream"><a href="#序列流-SequenceInputStream" class="headerlink" title="序列流-SequenceInputStream"></a><strong>序列流-SequenceInputStream</strong></h2><p>SequenceInputStream：表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，一次类推，直到到达包含最后一个输入流的文件末尾为止。</p>
<p>需求：将1.txt 2.txt 3.txt文件中的数据合并到一个文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;FileInputStream&gt; v = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">v.add(<span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> FileInputStream(<span class="string">"2.txt"</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> FileInputStream(<span class="string">"3.txt"</span>));</span><br><span class="line">Enumeration&lt;FileInputStream&gt; en = v.elements();</span><br><span class="line">SequenceInputStream sis = <span class="keyword">new</span> SequenceInputStream(en);</span><br><span class="line">FileOutoutStream fos = <span class="keyword">new</span> FileOutoutStream(<span class="string">"4.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = sis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    fos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">sis.close();</span><br></pre></td></tr></table></figure>

<h2 id="序列流-SequenceInputStream-枚举和迭代"><a href="#序列流-SequenceInputStream-枚举和迭代" class="headerlink" title="序列流-SequenceInputStream-枚举和迭代"></a><strong>序列流-SequenceInputStream-枚举和迭代</strong></h2><p>Vector过时了，ArrayList是常用的集合对象，但是ArrayList没有枚举的方法。通过寻找工具类发现一个方法可以给一个List返回一个枚举类对象，故用这个方法也可实现上述功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取枚举类对象的代码为</span></span><br><span class="line">Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(a);</span><br></pre></td></tr></table></figure>

<h2 id="文件切割"><a href="#文件切割" class="headerlink" title="文件切割"></a><strong>文件切割</strong></h2><p>将文件切成每份大小最高为固定值的碎片文件。</p>
<p>固定一个final常量定义文件大小。然后每次读出该大小数据再通过输出流存到硬盘</p>
<h2 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a><strong>文件合并</strong></h2><p>序列流中演示过</p>
<h2 id="文件切割合并-配置文件"><a href="#文件切割合并-配置文件" class="headerlink" title="文件切割合并+配置文件"></a><strong>文件切割合并+配置文件</strong></h2><p>实际切割或合并时，是不知道碎片个数以及文件类型，所以在切割时需要将这些信息存储起来。</p>
<h2 id="ObjectOutputStream-对象的序列化"><a href="#ObjectOutputStream-对象的序列化" class="headerlink" title="ObjectOutputStream-对象的序列化"></a><strong>ObjectOutputStream-对象的序列化</strong></h2><p>ObjectOutputStream：将Java对象的基本数据类型和图形写入OutputStream，可以使用ObjectInputStream读取（重构）对象，通过在流中使用文件可以实现对象的持久存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"obj.object"</span>));</span><br><span class="line">oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"aaa"</span>,<span class="number">30</span>));</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：对象序列化中，被序列化的对象必须实现Serializable接口。</p>
<h2 id="ObjectInputStream-对象的反序列化"><a href="#ObjectInputStream-对象的反序列化" class="headerlink" title="ObjectInputStream-对象的反序列化"></a><strong>ObjectInputStream-对象的反序列化</strong></h2><p>ObjectInputStream对以前使用ObjectOutputStream写入的基本数据和对象进行反序列化。只能读取oos写入的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"obj.object"</span>));</span><br><span class="line">Person p = (Person)oos.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure>

<p>这里会抛出的类不存在异常。因为对象的创立需要有其类文件的存在，如果只有object文件，那么是创立不了的。</p>
<h2 id="序列化接口-Serializable"><a href="#序列化接口-Serializable" class="headerlink" title="序列化接口-Serializable"></a><strong>序列化接口-Serializable</strong></h2><p>类通过实现Serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或者字段，仅用于标识可序列化的语义。</p>
<p>Serializable：用于给序列化的类加入ID号，用于判断类和对象是否是同一个版本。版本号不一致会发生无效类异常。可序列化类可以通过声明名为“serialVersionUID”字段（该字段必须是静态的static，最终的final的long型字段）显式声明自己的serialVersionUID。</p>
<p>ANY-ACCESS-MODIFIE static final long serialVersionUID=42l；</p>
<p>如果可序列化类未显式声明，则序列化运行时会基于该类从各个方面进行计算默认ID值，所以建议自己显式声明。</p>
<h2 id="关键字-transient"><a href="#关键字-transient" class="headerlink" title="关键字-transient"></a><strong>关键字-transient</strong></h2><p>writeObject将指定的对象写入ObjectOutputStream。对象的类，类的签名以及类及其所有超类型的<strong>非瞬态和非静态</strong>字段的值都将被写入。静态和瞬态的不会被写入。</p>
<p>静态的数据在方法区内，公用的，不会随内存中的对象写入硬盘上。</p>
<p><strong>transient：非静态（不是公用的）数据不想被序列化即不想将数据存到硬盘上可以使用这个关键字修饰。</strong></p>
<h2 id="RandomAccessFile-写入"><a href="#RandomAccessFile-写入" class="headerlink" title="RandomAccessFile-写入"></a><strong>RandomAccessFile-写入</strong></h2><p>随机访问文件，自身具备读写功能</p>
<p>RandomAccessFile</p>
<p>   不是IO体系中的子类</p>
<p>   特点：</p>
<p>   1.该对象既能读取又能写入。</p>
<p>   2.该对象内部维护了一个byte数组，并通过指针可以操作数组中的元素。</p>
<p>   3.可以通过<strong>getFilePointer</strong>方法获取指针的位置，和通过<strong>seek</strong>方法设置指针的位置。</p>
<p>   4.其实该对象就是将字节输入流和输出流进行了封装。</p>
<p>   5.该对象的<strong>源或者目的只能是文件</strong>。通过构造函数就可以看出</p>
<p>   构造函数RandomAccessFile(File file,String mode)</p>
<p>   mode：参数指定用以打开文件的访问模式。只允许一下四个值</p>
<p>   r：以只读方式打开，调用结果对象的任何write方法都将导致抛出IOException</p>
<p>   rw：打开以便读取和写入。如果文件不存在则创建。</p>
<p>   rws：打开以便读取和写入，对于”rw”,还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备</p>
<p>   rwd：打开以便读取和写入，对于”rw”,还要求对文件的内容的每个更新都同步写入到底层存储设备</p>
<p><strong>演示写入</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"aaa.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">raf.write(<span class="string">"asdf"</span>.getBytes());</span><br><span class="line">raf.write(<span class="number">609</span>);<span class="comment">//只写了最低的字节</span></span><br><span class="line">raf.writeInt(<span class="number">609</span>);<span class="comment">//按四个字节写入该文件，先写高字节</span></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure>

<h2 id="RandomAccessFile-读取-amp-随机读取"><a href="#RandomAccessFile-读取-amp-随机读取" class="headerlink" title="RandomAccessFile-读取&amp;随机读取"></a><strong>RandomAccessFile-读取&amp;随机读取</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"aaa.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">raf.read(buf);</span><br><span class="line">String name = <span class="keyword">new</span> String(buf);</span><br><span class="line"><span class="keyword">int</span> age = raf.readInt();<span class="comment">//一下读4个字节并转化成32位的整数</span></span><br><span class="line"></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure>

<p>若要指定任意位置读取，即随机读取，则先清楚byte数组中存储的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以通过seek()设置指针的位置。</span></span><br><span class="line">raf.seek(<span class="number">1</span>*<span class="number">8</span>);<span class="comment">//1指针隔8个位置，即指针跳过8个位置</span></span><br><span class="line"><span class="comment">//可以用getFilePointer();来确定现在指针的位置</span></span><br><span class="line"><span class="keyword">int</span> pos = raf.getFilePointer();</span><br></pre></td></tr></table></figure>

<h2 id="RandomAccessFile-随机写入-amp-细节"><a href="#RandomAccessFile-随机写入-amp-细节" class="headerlink" title="RandomAccessFile-随机写入&amp;细节"></a><strong>RandomAccessFile-随机写入&amp;细节</strong></h2><p>若在同指针位置写入数据，则会覆盖之前的数据，也就是该类可以进行修改。</p>
<p>该方法可以告诉线程从哪个位置开始往文本中写入数据，意味着，可以多个线程同时向文本中写入数据。所以多线程写入的时候会使用到该对象。</p>
<h2 id="PipedStream管道流"><a href="#PipedStream管道流" class="headerlink" title="PipedStream管道流"></a>PipedStream管道流</h2><p>管道输入流应该连接到管道输出流。管道输入流提供要写入管道输出流的所有数据字节。通常，数据由某个线程从PipedInputStream对象读取，并由其他线程将其写入到相应的PipedOutStream。<strong>不建议对这两个对象尝试使用单个线程。因为这样可能死锁线程。</strong></p>
<p>这是结合多线程的流</p>
<h2 id="操作基本数据类型的流对象-DataStream"><a href="#操作基本数据类型的流对象-DataStream" class="headerlink" title="操作基本数据类型的流对象-DataStream"></a><strong>操作基本数据类型的流对象-DataStream</strong></h2><p><strong>DataOutputStream</strong>：数据输出流允许应用程序以适当方式将基本Java数据类型写入输出流中，然后应用程序可以使用数据输入流将数据读入。以前的流写入int’数据只能写后8位，而用这个流则不存这个问题。</p>
<h2 id="操作数组的流"><a href="#操作数组的流" class="headerlink" title="操作数组的流"></a><strong>操作数组的流</strong></h2><p>ByteArrayOutputStream：此类实现了一个输出流，其中的数据被写入一个byte数组即目的是内存。缓冲区会随着数据的不断写入而自动增长。可使用toByteArray()和toString()获取数据。</p>
<p>关闭这个流无效，重点在于它是否有调用系统底层资源。这个对象本身操作的是内存，没有调用底层资源，只是在内存当中操作数据，此类中的方法在关闭后仍可被调用，而不会产生任何IO异常。</p>
<p>ByteArrayInputStream：包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪read方法要提供的下一个字节。同样关闭这个流无效。</p>
<p>它new对象时必须要有源，即内存的数组。</p>
<h2 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a><strong>编码表</strong></h2><p>计算机只能识别二进制数据，早起由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应形成一张表，这就是编码表。</p>
<p>常见的码表：</p>
<p>ASCII：美国标准信息交换码。用一个字节的7位可以表示。</p>
<p>ISO8859-1：拉丁码表，欧洲码表。用一个字节的8位表示。</p>
<p>GB2312：中国的中文编码表。</p>
<p>GBK：中国的中文编码表升级，融合了更多的中文文字字符号。</p>
<p>Unicode：国际标准码，融合了多种文字。所有文字都用两个字节来表示，Java语言使用的就是unicode</p>
<p>UTF-8：最多用三个字节表示一个字符。</p>
<h2 id="简单编码解码"><a href="#简单编码解码" class="headerlink" title="简单编码解码"></a><strong>简单编码解码</strong></h2><p>字符串–&gt;字节数组：编码</p>
<p>字节数组–&gt;字符串：解码</p>
<p>你好：GBK：-60 -29 -70 -61</p>
<p>你好：UTF-8：-28 -67 -96 -27 -91 -67</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编码</span></span><br><span class="line">String str = <span class="string">"你好"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buf1 = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(buf1, <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure>



<h2 id="编码解码问题"><a href="#编码解码问题" class="headerlink" title="编码解码问题"></a><strong>编码解码问题</strong></h2><p>如果你编错了，解不出来</p>
<p>如果编对了，解错了，有可能有解。</p>
<p>比如在Tomcat服务器上，如果传进来“你好”字符串，在其服务器上是用iso8859-1来解码，这是解不出来的，然后需要我们自行的重新用iso8859-1编码得到源字节，然后用指定编码表比如gbk解码，得到正确的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"你好"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buf1 = str.getBytes(<span class="string">"gbk"</span>);</span><br><span class="line">String s1 = <span class="keyword">new</span> String(buf1,<span class="string">"iso8859-1"</span>);<span class="comment">//这时是解不出来的。</span></span><br><span class="line"><span class="comment">//由于系统是默认用iso8859-1来解码，所以得手动重新用iso8859-1编码得到源字节，然后用指定编码表比如gbk解码，得到正确的结果</span></span><br><span class="line"><span class="keyword">byte</span>[] buf2 = s1.getBytes(<span class="string">"iso8859-1"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(buf2,<span class="string">"gbk"</span>);</span><br></pre></td></tr></table></figure>

<p>上述情况也有可能最后解不出来，比如用UTF-8。再输入你好时，相应的字节UTF-8识别不出来就会都用？代替，？在UTF-8中的对应的编码是-17 -65 -67，这就将之前的信息修改了，所以最后还原不出来。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-Properties</title>
    <url>/2020/03/28/JavaSE-Properties/</url>
    <content><![CDATA[<h1 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h1><h2 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1 基本功能"></a>1 基本功能</h2><p>Properties类继承HashTable，表示了一个<strong>持久</strong>的属性集。<strong>其可以保存在流中或从流中加载</strong>。属性列表中每一个键及其对应值都是一个字符串。</p>
<p>特点：</p>
<p>1.该集合中的键和值都是字符串类型</p>
<p>2.集合中的数据可以保存到流中或者从流中获取数据。</p>
<p>通常该集合用于操作以键值对形式存在的配置文件。</p>
<a id="more"></a>

<p>存取功能</p>
<p>取出所有元素的特有功能：Set&lt;String&gt;  stringPropertyNames();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//存储元素</span></span><br><span class="line">prop.setProperty(<span class="string">"aaa"</span>,<span class="string">"111"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"bbb"</span>,<span class="string">"222"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ccc"</span>,<span class="string">"333"</span>);</span><br><span class="line"><span class="comment">//修改元素</span></span><br><span class="line">prop.setProperty(<span class="string">"bbb"</span>,<span class="string">"444"</span>);</span><br><span class="line"><span class="comment">//取出元素</span></span><br><span class="line">Set&lt;String&gt; names = prop.stringPropertyNames();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">    String value = prop.getProperty(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>list方法</strong></p>
<p>list(PrintStream out)：将属性列表输出到指定的输出流。此方法对调试很有用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">prop.setProperty(<span class="string">"aaa"</span>,<span class="string">"111"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"bbb"</span>,<span class="string">"222"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ccc"</span>,<span class="string">"333"</span>);</span><br><span class="line"></span><br><span class="line">prop.list(System.out);</span><br><span class="line">结果：aaa=<span class="number">111</span></span><br><span class="line">     bbb=<span class="number">222</span></span><br><span class="line">     ccc=<span class="number">333</span></span><br></pre></td></tr></table></figure>

<p><strong>store方法</strong></p>
<p>void store(OutputStream out,String comments):用来存储。</p>
<p>void store(Writer writer,String comments)</p>
<p>参数：out：输出流 writer：输出字符流 comments：属性列表的描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">prop.setProperty(<span class="string">"aaa"</span>,<span class="string">"111"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"bbb"</span>,<span class="string">"222"</span>);</span><br><span class="line">prop.setProperty(<span class="string">"ccc"</span>,<span class="string">"333"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"info.txt"</span>);</span><br><span class="line">prop.store(fos,<span class="string">"name + age"</span>);</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>

<p>注意：属性列表描述不要用中文输入，因为此方法使用ISO 8859-1字符编码写入该流，注释中不是Latin-1的字符针对其适当的十六进制值xxxx以\uxxxx的形式写入。</p>
<p><strong>修改配置信息</strong></p>
<p>void load(InputStream inStream):从输入流中读取属性列表（键和元素对）</p>
<p>void load(Reader reader):按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"info.txt"</span>);</span><br><span class="line">prop.load(fis);</span><br><span class="line">prop.list(System.out);</span><br></pre></td></tr></table></figure>

<p>对已有的配置文件中的信息进行修改</p>
<p>思路：读取这个文件</p>
<p>​     并将这个文件中的键值数据存储到集合中</p>
<p>​     再通过集合对数据进行修改</p>
<p>​     再通过流将修改后的数据存储到文件中</p>
<p><strong>练习</strong></p>
<p>定义功能：获取一个应用程序运行的次数，如果超过5次，给出使用次数已到请注册的提示。并不要再运行程序</p>
<p> 思路：</p>
<p> 1.应该有计数器</p>
<p> 每次程序启动都需要计数一次，并且是在原有的次数上进行计数。</p>
<p> 2.计数器就是一个变量。程序启动时，进行计数，计数器必须存在于内存中进行运算。</p>
<p> 可是程序一结束，计数器消失。那么再次启动该程序，计数器又重新被初始化。</p>
<p> 而我们需要多次启动同一个程序，使用的是同一个计数器</p>
<p> 这就需要计数器的生命周期变长，从内存存储到硬盘文件中</p>
<p> 3.如何使用计数器</p>
<p> 首先，程序启动时应该先读取这个用于记录计数器信息的配置文件。</p>
<p> 获取上一次计数次数，并进行试用次数的判断</p>
<p> 其次，对该次数进行自增，并将自增后的次数重新存储到配置文件中</p>
<p> 4.文件中的信息该如何进行存储并体现</p>
<p> 直接存储次数值可以，但是不明确该数据的含义。所以起名字就变得很重要</p>
<p> 这就有了名字和值的对应，所以可以使用键值对</p>
<p> 可以用映射关系的map集合，又需要读取硬盘上的数据，所以map+io=Properties</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-IO流2</title>
    <url>/2020/03/27/JavaSE-IO%E6%B5%812/</url>
    <content><![CDATA[<h1 id="IO流2"><a href="#IO流2" class="headerlink" title="IO流2"></a>IO流2</h1><h2 id="1-File对象-构造函数-amp-字段"><a href="#1-File对象-构造函数-amp-字段" class="headerlink" title="1 File对象-构造函数&amp;字段"></a>1 <strong>File对象-构造函数&amp;字段</strong></h2><p>File类：用来将文件或者文件夹封装成对象</p>
<p>方便对文件与文件夹的属性信息进行操作</p>
<p>File对象可以作为参数传递给流的构造函数</p>
<p>构造方法：</p>
<p>File file1=new File(“a.txt”);</p>
<p>File file2=new File(“c:\“,”a.txt”);</p>
<p>File file=new File(“c:\“);//将路径封装成对象。</p>
<p>File file3=new File(file,”a.txt”);</p>
<a id="more"></a>

<p>字段摘要：</p>
<p>separator：与系统有关的默认名称分隔符，为了方便它被表示为一个字符串</p>
<p>pathSeparator：与系统有关的路径分隔符</p>
<p>separatorChar：与系统有关的默认名称分隔符</p>
<p>pathSeparatoChar：与系统有关的路径分隔符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f4 = <span class="keyword">new</span> File(<span class="string">"c:"</span> + File.separator + <span class="string">"abc"</span> + File.separator + <span class="string">"a.txt"</span>);</span><br><span class="line">System.out.println(f4);</span><br><span class="line">结果：c:\abc\a.txt</span><br></pre></td></tr></table></figure>

<h2 id="2-File对象-常见功能-获取"><a href="#2-File对象-常见功能-获取" class="headerlink" title="2 File对象-常见功能-获取"></a>2 <strong>File对象-常见功能-获取</strong></h2><p>获取文件名称</p>
<p>String getName();</p>
<p>获取文件路径</p>
<p>String getAbsolutePath();获取绝对路径</p>
<p>String getPath();构造函数中路径怎么写就获取什么</p>
<p>获取文件大小</p>
<p> long length();</p>
<p>获取文件修改时间</p>
<p> long lastModified();</p>
<h2 id="3-File对象-常见功能"><a href="#3-File对象-常见功能" class="headerlink" title="3 File对象-常见功能"></a>3 <strong>File对象-常见功能</strong></h2><p>文件创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = file.createNewFile();<span class="comment">//文件不存在则创建，存在则不创建。与输出流不同</span></span><br></pre></td></tr></table></figure>

<p>文件删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = file.delete();</span><br></pre></td></tr></table></figure>

<p>文件夹创建删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = dir.mkdir();</span><br><span class="line"><span class="keyword">boolean</span> b1 = dir.delete();</span><br></pre></td></tr></table></figure>

<p>创建多级目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"abc\\w\\e\\q\\d"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = dir.mkdirs();</span><br></pre></td></tr></table></figure>

<p>判断文件是否存在、判断是否为文件、是否是路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"abc.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = f.exists();</span><br><span class="line"><span class="keyword">boolean</span> b1 = f.isFile();</span><br><span class="line"><span class="keyword">boolean</span> b2 = f.isDirectory();</span><br></pre></td></tr></table></figure>

<p>重命名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"c:\\1.txt"</span>);</span><br><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"c:\\2.txt"</span>);</span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="string">"d:\\aa.txt"</span>);</span><br><span class="line">f1.renameTo(f2);<span class="comment">//将c盘中1.txt文件重命名为2</span></span><br><span class="line">f1.renameTo(f3);<span class="comment">//将c盘中1.txt文件剪切到d盘并重命名为aa</span></span><br></pre></td></tr></table></figure>

<p>系统根目录和容量获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File[] files = File.listRoots();<span class="comment">//系统根目录获取</span></span><br><span class="line"><span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">    System.out.print(file);</span><br><span class="line">	file.getFreeSpace();<span class="comment">//获取可用空间量</span></span><br><span class="line">    file.getTotalSpace();<span class="comment">//获取总空间量</span></span><br><span class="line">    file.getUsableSpace();<span class="comment">//获取已用空间量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取目录内容</p>
<p>获取当前目录下的文件以及文件夹的名称，包含隐藏文件</p>
<p>要用list方法时，file对象中封装的必须是目录，否则会发生空指针异常。</p>
<p>如果访问的系统级目录，也会发生空指针异常</p>
<p>如果目录存在，但是没有内容，会返回一个数组，但是长度为0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"e:\\"</span>);</span><br><span class="line">String[] names = file.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤器</p>
<p>选择d盘AppStore文件夹中.exe文件，用到FilenameFilter接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"d:\\AppStore"</span>);</span><br><span class="line">String[] names = dir.list(<span class="keyword">new</span> FilterByJava());</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByJava</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.endWith(<span class="string">".exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤隐藏文件，这时用到FileFilter接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"d:\\AppStore"</span>);</span><br><span class="line">File[] files = dir.listFiles(<span class="keyword">new</span> FilterByHidden());</span><br><span class="line"><span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">    System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByHidden</span> <span class="keyword">implements</span> <span class="title">FileFilter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !pathname.isHidden();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择任意后缀文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"d:\\AppStore"</span>);</span><br><span class="line">String[] names = dir.list(<span class="keyword">new</span> SuffixFilter(<span class="string">".doc"</span>));</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuffixFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String = suffix;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuffixFilter</span><span class="params">(String suffix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.endWith(suffix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-IO流</title>
    <url>/2020/03/27/JavaSE-IO%E6%B5%81/</url>
    <content><![CDATA[<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h2 id="1-输入流-amp-输出流"><a href="#1-输入流-amp-输出流" class="headerlink" title="1 输入流&amp;输出流"></a><strong>1 输入流&amp;输出流</strong></h2><p>IO流用来处理设备之间的数据传输</p>
<p>Java对数据的操作是通过流的方式</p>
<p>Java用于操作流的对象都在IO包中</p>
<p>流按操作数据分为两种：字节流与字符流</p>
<p>流按流向分为：输入流，输出流</p>
<p>输入流和输出流相对于内容设备而言</p>
<p>将外设中的数据读取到内存中：输入</p>
<p>将内存的数据写入到外设中：输出</p>
 <a id="more"></a>

<h2 id="2-字节流-amp-字符流"><a href="#2-字节流-amp-字符流" class="headerlink" title="2 字节流&amp;字符流"></a><strong>2 字节流&amp;字符流</strong></h2><p>字符流的由来：</p>
<p>字节流读取文字字节数据后，不直接操作而是先查指定的编码表，获取对应的文字</p>
<p>再对这个文字进行操作，简单说就是字节流+编码表</p>
<h2 id="3-字符流-FileWriter"><a href="#3-字符流-FileWriter" class="headerlink" title="3 字符流-FileWriter"></a><strong>3 字符流-FileWriter</strong></h2><p>字节流的两个顶层父类：</p>
<p>1.InputStream 2.OutputStream</p>
<p>字符流的两个顶层父类：</p>
<p>1.Reader 2.Writer</p>
<p>这些体系的子类基本以父类名作为后缀</p>
<p>而子类名的前缀就是该对象的功能</p>
<p><strong>从熟悉的文字开始，即字符流:</strong></p>
<p>需求：将一些文字存储到硬盘一个文件中。</p>
<p><strong>记住</strong>：如果要操作文字数据，建议优先考虑字符流。</p>
<p>而且要将数据从内存写到硬盘上，要使用字符流中的输出流：<strong>Writer</strong>。</p>
<p>硬盘的数据基本体现是文件，希望找到一个可以操作文件的Writer。</p>
<p>找到了<strong>FileWriter</strong>。</p>
<p>1.创建一个可以往文件中写入字符数据的字符输出流对象</p>
<p>既然是往一个文件中写入文字数据，创建对象时，就必须明确该文件（用于存储数据的目的地）。</p>
<p>如果文件不存在，则会自动创建</p>
<p>如果文件存在，则会被覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>2.调用Writer对象中的write(string)方法，写入数据。</p>
<p>数据首先是写入到了临时存储（流）缓冲区中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fw.write(<span class="string">"aaa"</span>);</span><br></pre></td></tr></table></figure>

<p>3.进行刷新，将数据直接写到目的地中。</p>
<p>也可以使用关闭流。</p>
<p>关闭流，关闭资源，但关闭前会先调用flush刷新缓冲中数据到目的地。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fw.flush();</span><br><span class="line">或</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>

<h2 id="4-字符流-FileWriter-细节（换行和续写）"><a href="#4-字符流-FileWriter-细节（换行和续写）" class="headerlink" title="4 字符流-FileWriter-细节（换行和续写）"></a><strong>4 字符流-FileWriter-细节（换行和续写）</strong></h2><p>换行</p>
<p>换行不能直接输入转义字符，如\r\n，因为这只是在windows系统下才能换行，换成别的系统则不行，故需要创建一个常量，来获取系统定义的换行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">fw.write(<span class="string">"aaaa"</span> + LINE_SEPARATO + <span class="string">"AAAA"</span>);</span><br></pre></td></tr></table></figure>

<p>续写</p>
<p>在构造函数中加入true，可以实现对文件进行续写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-字符流-FileWriter-IO异常处理"><a href="#5-字符流-FileWriter-IO异常处理" class="headerlink" title="5 字符流-FileWriter-IO异常处理"></a><strong>5 字符流-FileWriter-IO异常处理</strong></h2><p>注意：最后要finally，将流关闭</p>
<h2 id="6-字符流-FileReader-读取方式一"><a href="#6-字符流-FileReader-读取方式一" class="headerlink" title="6 字符流-FileReader-读取方式一"></a><strong>6 字符流-FileReader-读取方式一</strong></h2><p>需求2：读取一个文本文件，将读取到的字符打印到控制台</p>
<p>找到了<strong>FileReader</strong></p>
<p>创建读取字符数据的流对象</p>
<p>在创建读取流对象时，必须要明确被读取的文件，一定要确定该文件是存在的。</p>
<p>用一个读取流关联一个已存在文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>用Reader中的read方法读取字符，返回的是int类型数据。当没有字符可读时返回-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假如读的是一个a</span><br><span class="line"><span class="keyword">int</span> ch = fr.read();</span><br><span class="line">System.out.println(ch);</span><br><span class="line">System.out.println((<span class="keyword">char</span>)ch);</span><br><span class="line">结果：<span class="number">97</span></span><br><span class="line">     a</span><br></pre></td></tr></table></figure>

<h2 id="7-字符流-FileReader-读取方式二"><a href="#7-字符流-FileReader-读取方式二" class="headerlink" title="7 字符流-FileReader-读取方式二"></a><strong>7 字符流-FileReader-读取方式二</strong></h2><p>使用read(char[ ]) 读取文本文件数据至数组中,并返回读取字符的个数</p>
<p>先创建字符数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fr.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-字符流-练习复制文本文件"><a href="#8-字符流-练习复制文本文件" class="headerlink" title="8  字符流-练习复制文本文件"></a>8  <strong>字符流-练习复制文本文件</strong></h2><p>需求：将c盘的一个文本文件复制到d盘</p>
<p>复制原理：</p>
<p>分析：读取c盘文件中的数据</p>
<p>将这些数据写入到d盘当中</p>
<p>连读带写</p>
<p>思路：</p>
<p>1.需要读取源</p>
<p>2.将读到的源数据写入到目的地</p>
<p>3.既然是操作文本数据，使用字符流</p>
<p>代码略</p>
<h2 id="9-字符流-缓冲区-解释"><a href="#9-字符流-缓冲区-解释" class="headerlink" title="9 字符流-缓冲区-解释"></a><strong>9 字符流-缓冲区-解释</strong></h2><p>缓冲区的出现提高了对数据的读写效率</p>
<p>对应类</p>
<p>BufferedWriter</p>
<p>BufferedReader</p>
<p>缓冲区要结合流才可以使用</p>
<p>举例：</p>
<p>缓冲区可以看做是超市里的推车或者框，可以先将想要的东西放入到里面，最后再一次就算。</p>
<h2 id="10-字符流-缓冲区-BufferedWriter"><a href="#10-字符流-缓冲区-BufferedWriter" class="headerlink" title="10 字符流-缓冲区-BufferedWriter"></a>10 <strong>字符流-缓冲区-BufferedWriter</strong></h2><p>将文本写入字符输出流，缓冲各个字符，从而提供单字符、数组和字符串的高效写入。</p>
<p>可以指定缓冲区的大小，或者接受默认的大小，在大多数情况下，默认值足够大了。</p>
<p>该类提供了<strong>newLine()方法</strong>，它使用平台自己的行分隔符概念，此概念由系统属性line_separator定义。</p>
<p>有了这个缓冲区之后，写的操作就可以由这个类的对象进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="comment">//创建写缓冲区，并与fw绑定</span></span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"><span class="comment">//写的操作就可以由这个类的对象进行操作</span></span><br><span class="line">bufw.write(<span class="string">"aaa"</span>);</span><br><span class="line">bufw.newline();<span class="comment">//换行</span></span><br><span class="line">bufw.write(<span class="string">"nnn"</span>);</span><br><span class="line">bufw.flush();</span><br><span class="line">bufw.close();</span><br></pre></td></tr></table></figure>

<h2 id="11-字符流-缓冲区-BufferedReader"><a href="#11-字符流-缓冲区-BufferedReader" class="headerlink" title="11 字符流-缓冲区-BufferedReader"></a>11 <strong>字符流-缓冲区-BufferedReader</strong></h2><p>用法与BufferedWriter一样，创建该对象与FileReader的对象绑定，然后读的操作就由BufferedReader类对象操作。</p>
<p><strong>BufferedReader中的readLine();可以进行读一行操作，返回字符串类型。</strong></p>
<p>readLine()方法原理：使用了读取缓冲区的read方法，将读取到的字符进行缓冲，并判断换行标记。将标记前的缓存数据变成字符串返回。上述临时容器可以是StringBulider，因为最终返回的是字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br><span class="line">BufferedWriter bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line"><span class="keyword">int</span> ch = bufr.read();</span><br><span class="line">String line = bufr.readline();</span><br></pre></td></tr></table></figure>

<h2 id="12-字符流-缓冲区-装饰设计模式"><a href="#12-字符流-缓冲区-装饰设计模式" class="headerlink" title="12 字符流-缓冲区-装饰设计模式"></a>12 <strong>字符流-缓冲区-装饰设计模式</strong></h2><p>装饰设计模式：</p>
<p>  对一组对象的功能进行增强时，就可以使用该模式进行问题解决。</p>
<p>装饰设计模式和继承的区别</p>
<p>装饰和继承都能实现一样的特点：进行功能的扩展增强</p>
<p>有什么区别呢？</p>
<p>首先有一个继承体系</p>
<p>Writer</p>
<p>​    TextWriter:用于操作文本</p>
<p>​    MediaWriter:用于操作媒体</p>
<p>想要对操作的动作进行效率的提高</p>
<p>按照面向对象，可以通过继承对具体的进行功能的扩展。</p>
<p>效率提高需要加入缓冲技术</p>
<p>Writer</p>
<p>​    TextWriter:用于操作文本</p>
<p>​       BufferedTextWriter:加入了缓冲技术的操作文本的对象</p>
<p>​    MediaWriter:用于操作媒体</p>
<p>​       BufferedMediaWriter:加入了缓冲技术的操作媒体的对象</p>
<p>​       </p>
<p>但是这样做好像并不理想</p>
<p>如果这个体系进行功能扩展，有多个流对象</p>
<p>那么这个流要提高效率，是不是也要产生子类呢？是，这时就会发现只为提高功能，进行的继承，导致体系越来越臃肿，不够灵活。</p>
<p>重新思考这个问题</p>
<p>既然加入的都是同一种技术–缓冲</p>
<p>前一种是让缓冲和具体的对象相结合。</p>
<p>可不可以将缓冲进行单独的封装，哪个对象需要缓冲，就将哪个对象和缓冲关联。</p>
<p>class Buffer{</p>
<p>​    Buffer(TextWriter w)</p>
<p>​    {}</p>
<p>​    Buffer(MediaWriter w)</p>
<p>​    {}</p>
<p>}</p>
<p>class BufferWriter extends Writer{</p>
<p>​    BufferWriter(Writer w)</p>
<p>​    {</p>
<p>​    }</p>
<p>}</p>
<p>Writer</p>
<p>​    TextWriter:用于操作文本</p>
<p>​    MediaWriter:用于操作媒体</p>
<p>​    BufferWrter:用于提高效率</p>
<p>所以装饰比继承更为灵活</p>
<p>装饰特点：装饰类和被装饰类都必须所属同一个接口或者父类</p>
<h2 id="13-字符流-缓冲区-LineNumberReader"><a href="#13-字符流-缓冲区-LineNumberReader" class="headerlink" title="13 字符流-缓冲区-LineNumberReader"></a>13 <strong>字符流-缓冲区-LineNumberReader</strong></h2><p>LineNumberReader:跟踪行号的缓冲字符输入流。可以设置和获取当前行号。</p>
<p>setLineNumber();设置当前行号</p>
<p>getlineNumber();获取当前行号</p>
<h2 id="14-字节流-操作文本基本演示"><a href="#14-字节流-操作文本基本演示" class="headerlink" title="14 字节流-操作文本基本演示"></a>14 <strong>字节流-操作文本基本演示</strong></h2><p>基本操作与字符流类相同，操作的是字节</p>
<p>但它不仅可以操作字符，还可以操作其他媒体文件</p>
<p>读字节流</p>
<p>FileInputStream();有可以获取文件大小的方法：available();</p>
<p>写字节流</p>
<p>FileOutputStream();</p>
<p>字节流缓冲区</p>
<p>BufferedInputStream</p>
<p>BufferedOutputStream</p>
<p><strong>不要尝试用字符流去复制媒体如视频，图片文件</strong>。因为字符流自动会将读到的字节通过码表转换为字符，但是媒体和图片文件没有这种对应的码表，所以有些字节就会随机对应一个未知的字符，这有可能导致文件大小都会不一样。</p>
<h2 id="15-演示键盘录入"><a href="#15-演示键盘录入" class="headerlink" title="15 演示键盘录入"></a>15 <strong>演示键盘录入</strong></h2><p>需求：读取一个键盘录入的数据，并打印在控制台上。</p>
<p>键盘本身就是一个标准的输入设备</p>
<p>对于java而言，对于这种输入设备，都有对应的对象。</p>
<p><strong>InputStream in:</strong>标准输入流，此流已打开并准备提供输入数据，通常，此流对应于键盘输入或者主机环境或用户指定的另一个输入源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = System.in;</span><br><span class="line"><span class="keyword">int</span> ch1 = in.read();</span><br><span class="line">System.out.println(ch1);</span><br><span class="line"><span class="keyword">int</span> ch2 = in.read();</span><br><span class="line">System.out.println(ch2);</span><br><span class="line"><span class="keyword">int</span> ch3 = in.read();</span><br><span class="line">System.out.println(ch3);</span><br><span class="line">输入：a</span><br><span class="line">结果：<span class="number">97</span></span><br><span class="line">     <span class="number">13</span></span><br><span class="line">     <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>说明：运行时，首先在显示台上可以输入字符。造成这种等待的原因是in.read()。然后按下回车，开始读取字符。一个read方法读一个。结果是三个数字是因为后面两个是Windows中回车(\r\n)的ASCII码。</p>
<p><strong>注意：</strong>对于使用系统默认的输入输出流，一般不主动关闭流。因为该流在系统中只有一个。关闭后就不能再开启，所以最好让其随着系统的关闭而关闭。</p>
<h2 id="16-转换流"><a href="#16-转换流" class="headerlink" title="16 转换流"></a>16 <strong>转换流</strong></h2><p><strong>InputStreamReader类</strong> 是字节流通向字符流的桥梁，它使用指定的chatset读取字节并将其解码为字符。被称之为转换流，它是带着编码表。</p>
<p>用此方法转成字符流，就可以使用字符流中的readLine方法实现一些功能。</p>
<p><strong>OutStreamWriter类</strong> 是字符流通向字节流的桥梁，可使用指定的charset将要写入流中的字符编码成字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入字节流，输出转换成字符流</span></span><br><span class="line">InputStream in = System.in;</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入字符流，输出转换成字节流</span></span><br><span class="line">OutputStream out = System.out;</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(out);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(osw);</span><br></pre></td></tr></table></figure>

<p>可以简写成下面形式，<strong>需要记住</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out);</span><br></pre></td></tr></table></figure>

<h2 id="17-流的操作基本规律"><a href="#17-流的操作基本规律" class="headerlink" title="17 流的操作基本规律"></a>17 <strong>流的操作基本规律</strong></h2><p>流的操作规律：</p>
<p>之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适</p>
<p>想要知道开发时用到哪些对象，只要通过四个明确即可。</p>
<p>1.明确源和目的（汇）</p>
<p>  源：InputStream Reader</p>
<p>  目的：OutputStream Writer</p>
<p>2.明确数据是否是纯文本数据</p>
<p>  源：是纯文本：Reader</p>
<p>​    否：InputStream</p>
<p>  目的：是纯文本：Writer</p>
<p>​      否：OutputStream</p>
<p>到这里就可以明确需求中具体要使用哪个体系</p>
<p>3.明确具体的设备。</p>
<p>  源设备：</p>
<p>​    硬盘：File</p>
<p>​    键盘：System.in</p>
<p>​    内存：数组</p>
<p>​    网络：Socket流</p>
<p>  目的设备：</p>
<p>​    硬盘：File</p>
<p>​    控制台：System.out</p>
<p>​    内存：数组</p>
<p>​    网络：Socket流</p>
<p>4.是否需要其他额外功能</p>
<p>  1.是否需要高效（缓冲区）：</p>
<p>​    是，就加上buffer</p>
<h2 id="18-转换流的编码解码"><a href="#18-转换流的编码解码" class="headerlink" title="18 转换流的编码解码"></a>18 <strong>转换流的编码解码</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"demo.txt"</span>, <span class="string">"GBK"</span>);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>这两句代码的功能是等同的</p>
<p>FileWriter：其实就是转换流指定了本机默认码表的体现，而且这个转换流的子类对象可以方便操作文本文件。</p>
<p>简单说：操作文件的字节流+本机默认的编码表</p>
<p>这是按照默认码表来操作文件的便捷类</p>
<p>如果操作文本文件需要明确具体的编码，FileWriter就不行了，必须用转换流。</p>
<p>用指定的编码表：</p>
<p>OutputStreamReader(“文件名”,”码表名”);</p>
<p>同样的，读取也是，如果不是默认的码表就要用</p>
<p>InputStreamReader(“文件名”,”码表名”);</p>
<p>若用一个码表来解码由另一个码表编译的文件则会出现乱码。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-其他对象API</title>
    <url>/2020/03/26/JavaSE-%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1API/</url>
    <content><![CDATA[<h1 id="其他对象API"><a href="#其他对象API" class="headerlink" title="其他对象API"></a>其他对象API</h1><h2 id="1-System类"><a href="#1-System类" class="headerlink" title="1 System类"></a>1 <strong>System类</strong></h2><p>System类包含一些有用的类字段和方法，它不能被实例化，即构造函数不对外提供。</p>
<p>System：类中的方法和属性都是静态的。</p>
<p>字段有：out、in、err    </p>
<p>常见方法：</p>
<p>long currentTimeMillis();获取当前时间的毫秒值。</p>
<a id="more"></a>

<p><strong>Properties类</strong></p>
<p>获取系统的属性信息，并存储到Properties集合中，Properties集合是map集合的子类</p>
<p>Properties集合中存储都是String类型的键和值</p>
<p>最好使用它自己的存储和取出的方法来完成元素的操作</p>
<p>System.getProperties();可以获得系统属性信息Properties类对象</p>
<p>由于<strong>不同系统的分隔符代码不同</strong>，所以需要定义一个字符串类型量来存储当前系统的分隔符符号。这样此程序就能适用于所有系统而不需要再此修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperties(<span class="string">"line.seperator"</span>);</span><br></pre></td></tr></table></figure>

<p>给系统设置一些属性信息，这些信息是全局的，其他程序也可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperties(<span class="string">"mykey"</span>,<span class="string">"myvalue"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-Runtime类"><a href="#2-Runtime类" class="headerlink" title="2 Runtime类"></a><strong>2 Runtime类</strong></h2><p>每个Java程序都有一个Runtime实例，使应用程序能够与其运行的环境相连接可以通过getRuntime方法获取当前运行时应用程序不能创建自己的Runtime类实例。</p>
<p>此类也没有对外提供构造函数，这时</p>
<p><strong>注意：</strong>如果没有提供构造函数，那么意味着这个类不能创建对象，这个类的方法都是静态的。</p>
<p>​    如果这个类有非静态的方法，则一定存在着至少一个方法是静态并返回构造对象。</p>
<p>Runtime：没有构造方法摘要，说明该类不可以创建对象。又发现还有非静态的方法，说明应该提供静态的返回该类对象的方法。而且只有一个，说明Runtime类使用了<strong>单例设计模式</strong></p>
<h2 id="3-Math类"><a href="#3-Math类" class="headerlink" title="3 Math类"></a>3 <strong>Math类</strong></h2><p>Math前面有final修饰，不能被继承，其包含用于执行基本数学运算的方法，如初等指数，对数，平方根和三角函数。都是静态方法</p>
<p>常用方法：</p>
<p>ceil();返回大于参数的最小整数。</p>
<p>floor();返回小于参数的最大整数。</p>
<p>round();返回四舍五入的整数</p>
<p>pow(a,b);返回a的b次方</p>
<p>random();返回0-1之间的伪随机数</p>
<p>random还可以封装成对象，即random对象</p>
<h2 id="4-Date类"><a href="#4-Date类" class="headerlink" title="4 Date类"></a>4 <strong>Date类</strong></h2><p>Date类表示特定的瞬间，精确到毫秒。</p>
<p>Date类可以接受或返回年、月、日、小时、分钟和秒值的方法，<strong>表示形式</strong>为</p>
<p>年份y由整数y-1900表示</p>
<p>月份从0至11的整数表示，0代表1月，11代表12月</p>
<p>日期从1至31的整数表示</p>
<p>小时从0至23的整数表示</p>
<p>秒从0至61的整数表示，60和61只对闰秒发生</p>
<p>日期对象和毫秒值之间的转换</p>
<p>毫秒值转成日期对象：</p>
<p>1.通过Date对象的构造方法完成 new Date(timeMillis)；</p>
<p>2.通过setTime(long time)设置</p>
<p>因为可以通过Date对象的方法对该日期中的各个字段（年月日等）进行操作</p>
<p>日期对象转成毫秒值：</p>
<p>1.getTime方法</p>
<p>因为可以通过具体的数值进行运算</p>
<p><strong>日期对象转换成字符串</strong></p>
<p>对日期对象进行格式化，需要用到<strong>日期格式对象</strong>，即<strong>DateFormat</strong>。</p>
<p>将日期对象转成日期格式的字符串</p>
<p>使用的是DateFormat类中的<strong>format</strong>方法。</p>
<p>获取日期格式对象，具备系统默认的风格。也可以指定FULL LONG SHORT MEDIUM风格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">String str = dateFormat.format(date);</span><br></pre></td></tr></table></figure>

<p>如果风格是自定义的如何解决？使用dateFormat的子类SimpleDateFormat</p>
<p><strong>字符串转成日期对象</strong></p>
<p>将日期格式的字符串转成日期对象</p>
<p>使用的是DateFormat类中的parse()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str_date = <span class="string">"2019-10-05"</span>;</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance();</span><br><span class="line">Date date = dateFormat.parse(str_date);</span><br></pre></td></tr></table></figure>

<h2 id="5-Calendar类"><a href="#5-Calendar类" class="headerlink" title="5 Calendar类"></a>5 <strong>Calendar类</strong></h2><p><strong>Calender类</strong>是一个<strong>抽象类</strong>，它为特定瞬间与一组诸如YEAR MONTH DAY_OF_MONTH HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法。</p>
<p>练习：</p>
<p>得出指定年份2月的天数</p>
<p>基于08的演示再加上下面的代码</p>
<p>思路：先将日期设置为指定那年的3月1日，在用偏移方法偏移一天即可得到结果。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常见对象API-集合框架4</title>
    <url>/2020/03/26/JavaSE-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1API-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B64/</url>
    <content><![CDATA[<h1 id="常见对象API-集合框架4"><a href="#常见对象API-集合框架4" class="headerlink" title="常见对象API-集合框架4"></a>常见对象API-集合框架4</h1><h2 id="集合-工具类-amp-JDK5-0特性"><a href="#集合-工具类-amp-JDK5-0特性" class="headerlink" title="集合-工具类&amp;JDK5.0特性"></a>集合-工具类&amp;JDK5.0特性</h2><h2 id="1-Collections"><a href="#1-Collections" class="headerlink" title="1 Collections"></a>1 Collections</h2><p>Collections:是集合框架的工具类，里面的方法都是静态的。</p>
<p>排序：Collections.sort();</p>
<p>调换位置顺序：Collections.swap();</p>
<p>若要按照其它方式排序就要重写比较器的方法并传入。</p>
<p>Collections.sort(List&lt;? extends T&gt; list, Comparator&lt;? Super T&gt; c);</p>
<a id="more"></a>

<p>用二分搜索法搜索指定列表，以获得指定对象，返回对象索引。</p>
<p>static int binarySearch(List&lt;? extends Comparable&lt;? Super T&gt;&gt; list,T key)</p>
<p>static int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? Super T&gt; c)</p>
<p>获取最大值</p>
<p>max(Collection&lt;? extends T&gt; coll)</p>
<p>max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp</p>
<p>逆序</p>
<p>reverseOrder();返回一个比较器，强行逆转了Comparable接口的对象collection的自然顺序</p>
<p>reverseOrder(Comparator&lt;T&gt;,comp);返回一个比较器，强行逆转指定比较器的顺序</p>
<p>reverse(List&lt;?&gt; list);反转指定列表中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用方法:</span><br><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;String&gt;(Collections.reverseOder());</span><br><span class="line">相当于传入了一个跟之前比较器比较顺序相反的比较器。</span><br></pre></td></tr></table></figure>

<p>替换</p>
<p>static boolean ReplaceAll(List(T) list,T oldVal,T newVal);使用另一个值替换列表中出现的所有某一指定值。</p>
<p>fill(List&lt;? super T&gt; list,T obj);使用指定元素替换列表中的所有元素</p>
<p>其他方法</p>
<p>shuffle(List&lt;?&gt; list);使用默认随机源对指定列表进行置换</p>
<p>enumertion(Collection&lt;T&gt; coll);返回指定集合上的枚举。</p>
<p>list(Enumeration&lt;T&gt; e);返回一个数组列表，它按返回顺序包含指定枚举返回的元素</p>
<p><strong>toArray方法</strong></p>
<p>toArray();返回包含此collection中所有元素的数组。</p>
<p>toArray(T[ ] a);返回包含此collection中所有元素的数组；返回数组运行时类型与指定数组的运行时类型相同。</p>
<p>集合转成数组</p>
<p>使用的就是Colletion接口中的toArray方法。</p>
<p>集合转成数组可以对集合中的元素操作的方法进行限定。不允许对其进行增删。</p>
<p>toArray方法需要传入一个指定类型的数组</p>
<p>​    如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组</p>
<p>​    如果长度大于集合的size，那么该该方法会使用指定的数组，存储集合中的元素，其他位置默认为null</p>
<p>​    所以建议最后长度指定为集合的size。</p>
<h2 id="2-将非同步集合转成同步集合的方法"><a href="#2-将非同步集合转成同步集合的方法" class="headerlink" title="2 将非同步集合转成同步集合的方法"></a>2 <strong>将非同步集合转成同步集合的方法</strong></h2><p>synchronizedCollection(Collection&lt;T&gt; coll);返回指定列表支持的同步（线程安全）集合。</p>
<p>synchronizedList(List&lt;T&gt; list);返回指定列表支持的同步（线程安全）列表。</p>
<p>synchronizedMap(Map&lt;K,V&gt; map);返回指定列表支持的同步（线程安全）映射。</p>
<p>synchronizedSet(Set&lt;T&gt; set);返回指定列表支持的同步（线程安全）set。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();<span class="comment">//非同步list</span></span><br><span class="line">list = synchronizedList(list);<span class="comment">//返回一个同步的list</span></span><br></pre></td></tr></table></figure>



<h2 id="3-Arrays-方法介绍、asList方法"><a href="#3-Arrays-方法介绍、asList方法" class="headerlink" title="3  Arrays-方法介绍、asList方法"></a>3  <strong>Arrays-方法介绍、asList方法</strong></h2><p>Arrays:集合框架的工具类。里面的方法都是静态的</p>
<p>重点：asList(T.. a);返回一个受指定数组支持的固定大小的列表。充当了基于数组的API与基于Collection的API之间的桥梁，<strong>将数组转成集合</strong></p>
<p>好处：其实可以使用集合的方法操作数组中的元素</p>
<p>1.数组的长度是固定的，所以对于集合的增删方法是不可以使用的。否则会发生UnsupportedOperationException异常。</p>
<p>\2. 如果数组中的元素是对象，那么转成集合时，将数组中的元素作为集合中的元素进行集合存储。如果数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line">结果：[I@<span class="number">139</span>a55]</span><br></pre></td></tr></table></figure>



<h2 id="4-JDK5-0特性-ForEach循环"><a href="#4-JDK5-0特性-ForEach循环" class="headerlink" title="4 JDK5.0特性-ForEach循环"></a>4 <strong>JDK5.0特性-ForEach循环</strong></h2><p>foreach语句：</p>
<p>​        格式：</p>
<p>​        for(类型 变量:Collection集合或者数组)</p>
<p>​        {</p>
<p>​        </p>
<p>​        }</p>
<p>传统for循环和高级for循环的区别：</p>
<p>​        传统for可以完成对语句执行很多次，因为可以定义控制循环的增量和条件。</p>
<p>​        </p>
<p>​        高级for是一种简化形式</p>
<p>​        它必须有被遍历的目标。该目标要么是数组要么是Collection单列集合</p>
<p>​        </p>
<p>​        对于数组的遍历，如果仅仅是获取数组中的元素，可以使用高级for。</p>
<p>​        如果要对数组的角标进行操作，建议使用传统for。</p>
<p>不可以使用高级for遍历map集合，但是可以将map转成单列的set就可以用。</p>
<h2 id="5-JDK5-0特性-函数可变参数"><a href="#5-JDK5-0特性-函数可变参数" class="headerlink" title="5 JDK5.0特性-函数可变参数"></a>5 <strong>JDK5.0特性-函数可变参数</strong></h2><p>函数的可变参数：就是方法的参数列表不确定有多少参数时可以用</p>
<p>其实就是一个数组，但是接受的是数组的元素</p>
<p>自动将这些元素封装成数组，简化了调用者的书写</p>
<p><strong>注意：</strong>可变参数类型必须定义在参数列表的结尾处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newAdd</span><span class="params">(<span class="keyword">int</span> ... arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length; i++)&#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = newAdd(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">结果：<span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="6-JDK5-0特性-静态导入"><a href="#6-JDK5-0特性-静态导入" class="headerlink" title="6 JDK5.0特性-静态导入"></a>6 <strong>JDK5.0特性-静态导入</strong></h2><p>静态导入可以省略代码的缩写，可用可不用。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常见对象API-集合框架3</title>
    <url>/2020/03/26/JavaSE-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1API-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B63/</url>
    <content><![CDATA[<h1 id="常见对象API-集合框架3"><a href="#常见对象API-集合框架3" class="headerlink" title="常见对象API-集合框架3"></a>常见对象API-集合框架3</h1><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><h2 id="1-Map集合特点-amp-常用方法、常用方法演示"><a href="#1-Map集合特点-amp-常用方法、常用方法演示" class="headerlink" title="1 Map集合特点&amp;常用方法、常用方法演示"></a><strong>1 Map集合特点&amp;常用方法、常用方法演示</strong></h2><p>Map：一次添加一对元素。Collection一次添加一个元素</p>
<p>​    Map也称为双列集合，Collection集合称为单列集合</p>
<p>​    其实map集合中存储的就<strong>键值对</strong></p>
<p>​    map集合中必须保证<strong>键的唯一性</strong></p>
<p>1.添加</p>
<p>​    value put(key,value):返回前一个和key关联的值，如果没有则返回null</p>
<p>2.删除</p>
<p>​    void clear():清空map集合</p>
<p>​    value remove(key):根据指定的key删除指定的键值对。</p>
<p>3.判断</p>
<p>​    boolean containsKey(key):是否包含该键</p>
<p>​    boolean containsValue(value):是否包含该值</p>
<p>​    boolean isEmpty():是否为空</p>
<p>4.获取</p>
<p>​    value get(key):通过键获取值，如果没有该键返回null。</p>
<p>​                  当然可以通过返回null来判断是否包含指定键。</p>
<p>​    int size():获取键值对的个数。</p>
<h2 id="2-Map集合重点方法keySet演示"><a href="#2-Map集合重点方法keySet演示" class="headerlink" title="2 Map集合重点方法keySet演示"></a><strong>2 Map集合重点方法keySet演示</strong></h2><p>取出Map中的所有元素，这里就用到keySet方法</p>
<p>Set keySet();返回此映射中的所有键的set集合</p>
<p>原理：通过keySet方法获取所有的键所在的set集合，再通过set的迭代器获取到每一个键，再对每一个键通过get方法获取其对应的值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">8</span>,<span class="string">"aaa"</span>);</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">"qqq"</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="string">"sss"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = keySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	<span class="keyword">int</span> key = it.next();</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Map集合重点方法entrySet演示"><a href="#3-Map集合重点方法entrySet演示" class="headerlink" title="3 Map集合重点方法entrySet演示"></a><strong>3 Map集合重点方法entrySet演示</strong></h2><p>另一种取出Map中所有元素的方法，这里用到entrySet方法</p>
<p>Map.Entry&lt;K,V&gt; entrySet();返回此映射的映射关系的set集合。</p>
<p>这样通过entrySet方法Map就转成set，这样就可以迭代</p>
<p>该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是Map.Entry类型（类似于结婚证）。</p>
<p>然后通过该类中的getKey和getValue方法得到Map中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">8</span>,<span class="string">"aaa"</span>);</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">"qqq"</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="string">"sss"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; ME = it.next();</span><br><span class="line">	<span class="keyword">int</span> key = it.getKey();</span><br><span class="line">    String value = it.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map.Entry是内部嵌套类</p>
<p>Entry包含键和值的内容，只有先有Map映射，才存在着关系，而把关系封装成对象，关系要访问Map中的键和值，即外部规则含有内部规则，内部规则直接访问外部规则的内容。</p>
<h2 id="4-方法Values演示"><a href="#4-方法Values演示" class="headerlink" title="4 方法Values演示"></a>4 <strong>方法Values演示</strong></h2><p>Colletion values();返回此映射中包含的值的Collection集合。</p>
<p>返回值是Collection不是Set是因为值可以重复，键不能重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">Iterator&lt;String&gt; it = values.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	String str = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-常见子类"><a href="#5-常见子类" class="headerlink" title="5 常见子类"></a>5 常见子类</h2><p>Map常见的子类</p>
<p>​    HashTable：内部结构是哈希表，是同步的。不允许null作为键，null作为值。</p>
<p>​               子类Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。</p>
<p>​    HashMap：内部结构是哈希表，是不同步的。允许null作为键，null作为值。</p>
<p>​    TreeMap：内部结构是二叉树，是不同步的。可以对Map集合中的键进行排序。</p>
<p>​    ConcurrentHashMap：内部结构是哈希表，线程安全，CAS+同步锁，数组+链表+红黑                                              树，不允许null作为键，null作为值。</p>
<h2 id="6-LinkedHashMap-amp-关联码"><a href="#6-LinkedHashMap-amp-关联码" class="headerlink" title="6 LinkedHashMap&amp;关联码"></a>6 <strong>LinkedHashMap&amp;关联码</strong></h2><p>LinkedHashMap存进去时，元素时按什么顺序存进去的就按什么顺序取出来。</p>
<p>演示略</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-泛型</title>
    <url>/2020/03/26/JavaSE-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>有时候编译程序会碰到如下问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">a.add(<span class="string">"abc"</span>);</span><br><span class="line">a.add(<span class="number">5</span>);</span><br><span class="line">编译不报错，运行时会报错</span><br></pre></td></tr></table></figure>

<p>这是因为5这个元素加进来类型是Int，无法强转成String类型。但是在编译的过程中不会报错，在运行时才会出现异常，这就不是非常的安全。所以要改写成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">a.add(&quot;abc&quot;);</span><br><span class="line">a.add(5);</span><br></pre></td></tr></table></figure>

<p>这样在编译时就出现报错，提升了安全性。同时发现之前的黄色感叹号也消失了，然后在给str赋值时，也不用强转，因为在之前定义集合时就已经说明里面装的是String类型的元素。</p>
<p><strong>尖括号里面的内容就是泛型。</strong></p>
<a id="more"></a>

<p>泛型：</p>
<p>jdk1.5出现的安全机制。</p>
<p>好处:</p>
<p>​    1.将运行时期的问题ClassCastException转到了编译时期</p>
<p>​    2.避免了强制转换的麻烦</p>
<p>&lt;&gt;什么时候用？</p>
<p>当操作的引用数据类型不确定的时候，就使用&lt;&gt;,将要操作的引用数据类型传入即可</p>
<p>其实&lt;&gt;就是一个用于接收具体<strong>引用数据类型</strong>的参数范围，数值数据类型不能用。</p>
<p>在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型。</p>
<h2 id="2-泛型-擦除-amp-补偿"><a href="#2-泛型-擦除-amp-补偿" class="headerlink" title="2 泛型-擦除&amp;补偿"></a>2 <strong>泛型-擦除&amp;补偿</strong></h2><p>泛型技术是给编译器使用的技术，用于编译时期。确保了类型的安全。</p>
<p>运行时会将泛型去掉，生成的class文件中是不带泛型的，这个称为泛型的<strong>擦除</strong>。</p>
<p>为什么擦除呢？</p>
<p>因为为了兼容运行的类加载器。</p>
<p>泛型的<strong>补偿</strong>：在运行时，通过获取元素的类型进行转换动作。不用使用者再强制转换了。</p>
<p>集合使用与之前没有使用泛型进行比较，有不同。然后<strong>equals方法不能用泛型</strong>，因为这个方法来自于Object，Object没有定义泛型。这里是固定类型，想要比较就要强转。</p>
<h2 id="3-泛型-泛型类"><a href="#3-泛型-泛型类" class="headerlink" title="3 泛型-泛型类"></a>3 <strong>泛型-泛型类</strong></h2><p>在jdk1.5后，使用泛型来接收类中要操作的引用数据类型</p>
<p>泛型类：什么时候用？</p>
<p>当类中的操作的引用数据类型不确定的时候，就使用泛型来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tool</span>&lt;<span class="title">QQ</span>&gt;</span>&#123;<span class="comment">//这就是泛型类</span></span><br><span class="line">    <span class="keyword">private</span> QQ q;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> QQ <span class="title">getObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObject</span><span class="params">(QQ object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.q = object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Tool&lt;Student&gt; tool = <span class="keyword">new</span> Tool&lt;Student&gt;;</span><br><span class="line">    tool.setObject(<span class="keyword">new</span> Student());</span><br><span class="line">    Student stu = tool.getObject();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子使用泛型类，就不必再强转。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-泛型-泛型方法"><a href="#4-泛型-泛型方法" class="headerlink" title="4 泛型-泛型方法"></a>4 <strong>泛型-泛型方法</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;w&gt;<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(W str)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"str"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(QQ str)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"str"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型定义在方法上，此时show方法中的参数类型跟着W走，而print方法中的参数类型跟着QQ走，即定义在类的泛型走。若W没有具体定义，那么就是Object。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(QQ str)</span></span>&#123;<span class="comment">//这是不行的</span></span><br><span class="line">    System.out.println(<span class="string">"str"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Y&gt;<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Y str)</span></span>&#123;<span class="comment">//这是可以的</span></span><br><span class="line">    System.out.println(<span class="string">"str"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当方法<strong>静态</strong>时，不能访问类上定义的泛型。如果静态方法使用泛型，只能将泛型定义在方法上。泛型只能定义在返回值的前面，修饰符的后面。使用的话就直接：类.方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Y&gt;<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Y aaa)</span></span>&#123;</span><br><span class="line">    System.out.println(aaa.length());<span class="comment">//这是不行的</span></span><br><span class="line">    System.out.println(aaa.toString());<span class="comment">//这是可以的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：不能直接在泛型方法内使用具体一个对象的方法，因为使用了泛型，就无法确定具体的类型是什么。但是可以使用Object方法，因为所有的对象都是Object类或子类。</p>
<h2 id="5-泛型接口"><a href="#5-泛型接口" class="headerlink" title="5  泛型接口"></a>5  <strong>泛型接口</strong></h2><p>泛型接口：将泛型定义在接口上</p>
<p>有两种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter1</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp1</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp2</span>&lt;<span class="title">Q</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">Q</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Q q)</span></span>&#123;</span><br><span class="line">        System.out.println(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-泛型限定（上下限）"><a href="#6-泛型限定（上下限）" class="headerlink" title="6 泛型限定（上下限）"></a>6 <strong>泛型限定（上下限）</strong></h2><p>如果想要在方法中对所有的泛型都能使用，就要用到通配符，这里通配符就是问号?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; a)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = a.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是两个集合分别是装String和Integer类型，但是方法上想都能用，就用?。</p>
<p>若方法只是能部分类型调用的，比如现在有Worker，Student和String类型的集合，但是只能前两者调用，前两者又是Person的子类，故可以使用<strong>泛型的限定</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;? extends Person&gt; a)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = a.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        Person p = it.next();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<strong>注意</strong>就是集合构建前后泛型要一致，否则失败</p>
<p>Collection&lt;Person&gt;=new ArrayList&lt;Worker&gt;(); 不行</p>
<p>Collection&lt;Worker&gt;=new ArrayList&lt;Person&gt;(); 不行</p>
<p>Collection&lt;Person&gt;=new ArrayList&lt;Person&gt;(); 行</p>
<p>泛型可以对类型进行限定</p>
<p>上限：? extends E:接收E类型或者E的子类型对象。</p>
<p>下限：? super E:接收E类型或者E的父类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Student&gt; a)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = a.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        Person p = it.next();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就只能接收Student和其父类Person，Worker不行。</p>
<h2 id="7-泛型的限定（上下限的体现）"><a href="#7-泛型的限定（上下限的体现）" class="headerlink" title="7 泛型的限定（上下限的体现）"></a>7 <strong>泛型的限定（上下限的体现）</strong></h2><p>上限的体现：一般在<strong>存储元素的时候都是用上限</strong>，因为这样取出都是按照上限类型来运算的，不会出现类型安全隐患。</p>
<p>API中，addAll(Collection&lt;? Extends Person&gt;);这就是上限的体现。</p>
<p>下限的体现</p>
<p>什么时候用下限？通常对<strong>集合中的元素进行取出操作时</strong>，<strong>可以使用下限</strong>。</p>
<p>从集合中取出元素，用本身或者父类来取出，可以保证全部接收。</p>
<p>TreeSet(Comparator&lt;? super E&gt; comp);下限的体现。</p>
<h2 id="8-泛型限定（通配符的体现）"><a href="#8-泛型限定（通配符的体现）" class="headerlink" title="8 泛型限定（通配符的体现）"></a>8 <strong>泛型限定（通配符的体现）</strong></h2><p>containsAll(Collection&lt;?&gt; coll)</p>
<p>包含的原理是用equals作判断，equals方法任何对象都具备，equals参数是Object。</p>
<p>所以传进来的集合类型是随机的未知的，所以用通配符?。</p>
<p>只要里面用的是Object方法，都用?。</p>
<p>containsAll(Collection&lt;?&gt; coll);通配符的体现。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常见对象API-集合框架2</title>
    <url>/2020/03/25/JavaSE-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1API-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B62/</url>
    <content><![CDATA[<h1 id="常见对象API-集合框架2"><a href="#常见对象API-集合框架2" class="headerlink" title="常见对象API-集合框架2"></a>常见对象API-集合框架2</h1><h2 id="list的子类与set"><a href="#list的子类与set" class="headerlink" title="list的子类与set"></a>list的子类与set</h2><h2 id="1-Vector集合"><a href="#1-Vector集合" class="headerlink" title="1 Vector集合"></a><strong>1 Vector集合</strong></h2><p>Vector集合中的方法基本都不太使用。都有ArrayList来取代了。下面例举一下其中几个方法，更多的可以去API中寻找，其中带element的都是原先Vector的方法。</p>
<p>addElement 添加</p>
<p>elements() 获得Enumeration类，使用hasMoreElements()和nextElement()方法可以对集合进行遍历。功能与Iterator接口的功能是重复的。此外Iterator接口添加了一个可选的移除操作，并使用较短的方法名。新的实现应优先考虑使用Iterator。</p>
<a id="more"></a>

<h2 id="2-LinkedList集合"><a href="#2-LinkedList集合" class="headerlink" title="2 LinkedList集合"></a><strong>2 LinkedList集合</strong></h2><p>LinkedList的一些常见的方法，更多的见API。</p>
<p>addFirst():将元素添加到第一个位置</p>
<p>addLast();将元素添加到最后一个位置</p>
<p>getFirst():获取第一个元素但不删除</p>
<p>getLast():获取最后一个元素但不删除</p>
<p>removeFirst():获取第一个元素但删除</p>
<p>removeLast():获取最后一个元素但删除</p>
<p><strong>栈和队列均可由LinkedList接口实现</strong></p>
<p>JDK在1.6后又添加了一些方法</p>
<p>​    addFirst();</p>
<p>​    addLast();</p>
<p>​    JDK1.6以后多了</p>
<p>​    offerFirst();</p>
<p>​    offetLast();</p>
<p>​    getFirst();//获取但不移除，如果链表为空，抛出NoSuchElementException</p>
<p>​    getLast();</p>
<p>​    JDK1.6以后多了</p>
<p>​    peekFirst();//获取但不移除，如果链表为空，返回null</p>
<p>​    peekLast();</p>
<p>​    </p>
<p>​    removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException</p>
<p>​    removeLast();</p>
<p>​    JDK1.6以后多了</p>
<p>​    pollFirst();//获取并移除，如果链表为空，返回null</p>
<p>​    pollLast();</p>
<h2 id="3-ArrayList集合存储自定对象"><a href="#3-ArrayList集合存储自定对象" class="headerlink" title="3 ArrayList集合存储自定对象"></a><strong>3 ArrayList集合存储自定对象</strong></h2><p>略</p>
<p>这里要注意：集合的add方法的参数类型是Object，所以什么类型的对象都能接收。接收完以后里面的对象都提升为了Object对象，用迭代器取其中的元素类型也是Object对象。Object中里面没有其子类特有的方法，故直接使用子类特有的方法会报错。所以需要创建对象来接收迭代出来的，这时需要对其进行强转。</p>
<h2 id="4-HashSet集合"><a href="#4-HashSet集合" class="headerlink" title="4 HashSet集合"></a><strong>4 HashSet集合</strong></h2><p>Set：元素不可以重复，是无序的</p>
<p>​    Set接口中的方法和Collection一致</p>
<p>常用子类之一</p>
<p>HashSet: 此类实现set接口，有哈希表支持。它不保证set的迭代顺序，特别是它不保证该顺序恒久不变。此类允许使用null元素。此实现是不同步</p>
<h2 id="5-哈希表"><a href="#5-哈希表" class="headerlink" title="5 哈希表"></a>5 哈希表</h2><p>每一个元素都会通过一个哈希算法来确定存储在集合中的位置，同一位置不能重复存储。当需要查找集合中是否存在此元素时，通过哈希算法算出位置，再判断两个元素是否相同。这样的查找速度更快，比遍历在快很多。</p>
<p>哈希表确定元素是否相同</p>
<p>1.判断的是两个元素的哈希值是否相同</p>
<p>​    如果相同，再判断两个对象的内容是否相同</p>
<p>2.判断哈希值相同，其实判断的是对象的hashCode的方法。</p>
<p>​    判断内容相同，用的是equals方法</p>
<p>注意：如果哈希值不同，是不需要判断equals。</p>
<p>如果相同， 则不再存储该值，若不同则依据当前位置再进行算法进行存储或顺延存储。</p>
<h2 id="6-HashSet存储自定义对象"><a href="#6-HashSet存储自定义对象" class="headerlink" title="6 HashSet存储自定义对象"></a>6 HashSet存储自定义对象</h2><p>往hashset集合中存储person对象。如果姓名和年龄相同，视为同一个人，视为同元素</p>
<p>具体略</p>
<p>注意：Person对象是继承Object的，也继承其hashCode和equals方法。在这个情况下equals方法中，是比较其地址值的，所以就算两个new的对象姓名和年龄一样，实际判断还是不相同。</p>
<p>所以我们需要自己建立算法和判断依据来存储数据，就需要对父类进行覆盖。</p>
<h2 id="7-LinkedHashSet集合"><a href="#7-LinkedHashSet集合" class="headerlink" title="7 LinkedHashSet集合"></a>7 LinkedHashSet集合</h2><p>LinkedHashSet具有可预知迭代顺序的Set接口的哈希表和链接列表实现</p>
<p>即保证唯一和有序</p>
<h2 id="8-TreeSet集合"><a href="#8-TreeSet集合" class="headerlink" title="8 TreeSet集合"></a>8 TreeSet集合</h2><p>TreeSet:可以对set集合中的元素进行指定顺序的排序。是不同步的。</p>
<p>判断元素唯一性的方式就是根据比较方法的返回结果是否是0.是0，就是相同元素，不存。</p>
<p>存储自定义对象</p>
<p>TreeSet集合中，要通过comparable接口来确定顺序。所以自定义对象需要实现这个接口。不实现这个接口存进去报错。</p>
<p>将自定义类实现comparable接口，复写compareTo方法</p>
<p>CompareTo方法比较此对象与指定对象的顺序，如果该对象小于，等于或者大于指定对象，则分别返回负整数，零或者正整数。返回1则排在后面。</p>
<h2 id="9-TreeSet集合-Comparator比较器"><a href="#9-TreeSet集合-Comparator比较器" class="headerlink" title="9 TreeSet集合-Comparator比较器"></a>9 TreeSet集合-Comparator比较器</h2><p>TreeSet对元素进行排序的方式一：</p>
<p>​    让元素自身具备比较功能，元素需要实现Comparable接口，覆盖compareTo方法。</p>
<p>如果不要按照对象中具备的自然顺序进行排序，如果对象中不具备自然顺序，怎么办</p>
<p>可以使用TreeSet集合的排序方式二：</p>
<p>让集合自身具备比较功能,定义一个类实现Comparator接口，覆盖compare方法</p>
<p>将该类对象作为参数传递给TreeSet集合的<strong>构造函数。</strong></p>
<p>比较器会比较常用一些。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常见对象API-集合框架1</title>
    <url>/2020/03/25/JavaSE-%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1API-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B61/</url>
    <content><![CDATA[<h1 id="常见对象API-集合框架1"><a href="#常见对象API-集合框架1" class="headerlink" title="常见对象API-集合框架1"></a>常见对象API-集合框架1</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>集合类的由来</p>
<p>​    对象用于封装特有数据，对象多了就需要存储，如果对象的个数不确定，就是使用集合容器进行存储</p>
<p>集合特点</p>
<p>1.集合是用于存储对象的容器</p>
<p>2.集合的长度是可变的</p>
<p>3.集合中不可以存储基本数据类型值</p>
<a id="more"></a>

<h2 id="2体系-amp-共性功能"><a href="#2体系-amp-共性功能" class="headerlink" title="2体系&amp;共性功能"></a><strong>2体系&amp;共性功能</strong></h2><p>集合容器因为内部的数据结构不用，有多种具体容器,不断的向上抽取就形成了集合框架，框架的顶层就是collection接口</p>
<p>collection的常见方法：（<strong>做必要掌握</strong>）</p>
<p>1.添加</p>
<p>​    boolean add(Object obj);</p>
<p>​    boolean addAll(Collection coll);添加全部</p>
<p>2.删除</p>
<p>​    boolean remove(Object obj);删除第一次出现的对象</p>
<p>​    boolean removeAll(Collection coll);将两个集合中相同的元素从调用removeAll的集合中删除</p>
<p>​    void clear();将集合中的所有元素都删除</p>
<p>3.判断</p>
<p>​    boolean contains(Object Obj);判断集合内是否存在该元素</p>
<p>​    boolean containsAll(Collection coll);判断集合内是否存在指定集合内的所有元素</p>
<p>​    boolean isEmpty();判断集合中是否有元素，没有返回true</p>
<p>4.获取</p>
<p>​    int size();获取集合中元素个数即长度</p>
<p>​    Iterator iterator();取出元素的方式：迭代器</p>
<p>5.其他</p>
<p>​    boolean retainAll(Collection coll);取交集即保留和指定集合中相同的元素在当前集合中，删除不同的元素，和removeAll功能相反。</p>
<p>​    Object[ ] toArray();将集合转为数组</p>
<h2 id="3-迭代器使用"><a href="#3-迭代器使用" class="headerlink" title="3 迭代器使用"></a>3 <strong>迭代器使用</strong></h2><p>如果想取出集合中的元素则需要使用到迭代器。</p>
<p>首先使用Collection中iterator()方法.调用集合中的迭代器方法，获取集合中的迭代器对象。</p>
<p>在迭代器对象中有两个方法：</p>
<p>object next():返回迭代的下一个元素</p>
<p>Boolean hasNext():如果仍有元素可以迭代，则返回true。</p>
<p>然后利用while循环和上述两个方法可以将集合中的元素全部迭代出来。</p>
<p>若再使用next方法，则会出现找不到元素异常，因为之前都迭代完了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时存在一个问题，就是迭代完之后，it对象仍在存在占用空间，但是却没有了用处，所以要改变一下代码的写法，使用for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(Iterator it = coll.iterator();it.hasNext();)&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子循环结束，it对象也随之消失。</p>
<p>一般开发都用这种方法</p>
<h2 id="4-迭代器的原理"><a href="#4-迭代器的原理" class="headerlink" title="4 迭代器的原理"></a>4 <strong>迭代器的原理</strong></h2><p>每个集合中都有自己的迭代器，向上抽取形成迭代器接口类型的类，这是一个<strong>内部类</strong>，里面有hasNext()和next()方法。</p>
<p>然后每个集合中都实现这个迭代器，里面都覆盖了上述的两个方法。</p>
<p>迭代器对象必须依赖于具体容器，因为每一个容器的数据结构都不同，所以该迭代器对象是在容器中进行内部实现的。对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法。</p>
<h2 id="5-List（列表）和Set（集）的特点"><a href="#5-List（列表）和Set（集）的特点" class="headerlink" title="5 List（列表）和Set（集）的特点"></a><strong>5 List（列表）和Set（集）的特点</strong></h2><p>List和Set是集合体系的子体系，也是接口</p>
<p>List：有序（存入和取出的顺序一致）、元素都有索引（角标）、元素可以重复</p>
<p>Set：元素不能重复、无序</p>
<h2 id="6-List集合的常见方法"><a href="#6-List集合的常见方法" class="headerlink" title="6 List集合的常见方法"></a><strong>6 List集合的常见方法</strong></h2><p><strong>List特有</strong>的常见方法：有一个共性特点，就是都可以操作角标(index)</p>
<p>1.添加</p>
<p>​    void add(index,element);</p>
<p>​    void add(index,collection);</p>
<p>2.删除</p>
<p>​    Object remove(index);</p>
<p>​    </p>
<p>3.修改</p>
<p>​    Object set(index,element);</p>
<p>​    </p>
<p>4.获取</p>
<p>​    Object get(index);</p>
<p>​    int indexOf(object);</p>
<p>​    int lastIndexOf(object);</p>
<p>​    List subList(from,to);包含头不包含尾</p>
<p>List集合是可以完成对元素的增删改查的</p>
<h2 id="7-ListIterator接口"><a href="#7-ListIterator接口" class="headerlink" title="7 ListIterator接口"></a><strong>7 ListIterator接口</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"abc1"</span>);</span><br><span class="line">list.add(<span class="string">"abc2"</span>);</span><br><span class="line">list.add(<span class="string">"abc3"</span>);</span><br><span class="line">Iterator it = <span class="keyword">new</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span>(obj.equals(<span class="string">"abc2"</span>))&#123;</span><br><span class="line">        list.add(<span class="string">"abc5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> System.out.println(<span class="string">"next:"</span> + obj);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line">结果：报错：ConcurrentModificationException</span><br></pre></td></tr></table></figure>

<p>想实现当迭代到abc2时，添加abc9，但是此时出现异常，即集合不能同时进行添加和迭代。也就是在迭代过程中，不要使用集合操作元素，容易出现异常。</p>
<p>解决：可以使用Iterator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"abc1"</span>);</span><br><span class="line">list.add(<span class="string">"abc2"</span>);</span><br><span class="line">list.add(<span class="string">"abc3"</span>);</span><br><span class="line">ListIterator it = <span class="keyword">new</span> list.listIterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span>(obj.equals(<span class="string">"abc2"</span>))</span><br><span class="line">        list.add(<span class="string">"abc5"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line">结果：[abc1,abc2,abc5,abc3]</span><br></pre></td></tr></table></figure>

<p>Iterator接口的子接口ListIterato它可以实现在迭代过程中完成对元素的增删改查。</p>
<p>注意：只有list集合具备该迭代功能</p>
<p>ListIterator还有反向遍历的功能</p>
<p>previous()</p>
<p>hasPrevious()</p>
<h2 id="8-List常用子类的特点"><a href="#8-List常用子类的特点" class="headerlink" title="8 List常用子类的特点"></a>8 <strong>List常用子类的特点</strong></h2><p>List有三个常用子类对象</p>
<p>​    Vector:内部是数组数据结构，是同步的即线程安全。增删，查询都很慢</p>
<p>​    ArrayList:内部是数组数据结构，是不同步的。替代了Vector。查询的速度快</p>
<p>​    LinkedList:内部是链接列表即链表数据结构，是不同步的。增删元素的速度很快</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-基本数据类型对象包装类</title>
    <url>/2020/03/25/JavaSE-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="基本数据类型对象包装类"><a href="#基本数据类型对象包装类" class="headerlink" title="基本数据类型对象包装类"></a>基本数据类型对象包装类</h1><p>为了方便操作基本数据类型值，将其封装成了对象，在对象中定义了属性和行为丰富了该数据的操作。<br>用于描述该对象的类就称为<strong>基本数据类型对象包装类</strong>。</p>
<p>基本数据类型对应关系</p>
<p>基本数据类型(8种)   包装类</p>
<p>byte            Byte</p>
<p>short          Short</p>
<p>int             Integer</p>
<p>long           Long</p>
<p>float           Float</p>
<p>double          Double</p>
<p>char            Character</p>
<p>boolean        Boolean</p>
 <a id="more"></a>



<p>常用操作之一: 用于基本数据类型和字符串之间的转换</p>
<p>1.基本类型转换为字符串方法:</p>
<p>1)基本类型数值 + “”;</p>
<p>2)使用 String 类中的静态方法 valueOf(基本类型数值);</p>
<p>3)使用 Integer 类中的静态方法 valueOf(基本类型数值);</p>
<ol start="2">
<li>字符串转换为基本类型</li>
</ol>
<p>1)使用包装类中的静态方法 <code>xxx parseXxx(&quot;xxx类型的字符串&quot;);</code></p>
<p>int a = Integer.parseInt(“234”); // 直接使用类名调用对应方法</p>
<p>int parseInt(“intstring”);</p>
<p>long parseLong(“longstring”);</p>
<p>boolean parseBoolean(“booleanstring”);</p>
<p>只有 Charater, 没有 parse 方法</p>
<p>2)如果字符串被Integer进行对象的封装。</p>
<p>可使用另一个非静态方法，intValue();</p>
<p>将一个Integer对象转成基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(i.intValue() + <span class="number">1</span>);</span><br><span class="line">结果：<span class="number">124</span></span><br></pre></td></tr></table></figure>



<p>整数具备不同的进制体现</p>
<p><strong>十进制–&gt;其他进制</strong></p>
<p>​       toBinaryString 二进制</p>
<p>​       toOctalString 八进制</p>
<p>​       toHexString 十六进制</p>
<p>​       toString(int x,int radix) 转化为字符串，radix为以几进制的形式转化</p>
<p>其他进制–&gt;十进制</p>
<p>​       parseInt(String x,int radix)</p>
<h2 id="JDK1-5自动装箱拆箱"><a href="#JDK1-5自动装箱拆箱" class="headerlink" title="JDK1.5自动装箱拆箱"></a>JDK1.5自动装箱拆箱</h2><p>作比较</p>
<p>compareTo(another Integer)；大于、小于、等于分别返回1，-1和0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="string">"3"</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a.compareTo(b));</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line">结果：<span class="number">0</span></span><br><span class="line">     <span class="keyword">false</span></span><br><span class="line">     <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>Integer覆盖了Object中的equals方法。第一个输入的字符串自动转成数值</p>
<p>JDK1.5之后，简化了定义的方式</p>
<p>Integer i=new Integer(4);</p>
<p>可以直接写成Integer i=4; 这叫<strong>自动装箱</strong>，基本数据类型值赋值给引用数据类型值的时候会装箱，简化书写，这段代码等同于：Integer i=Integer.valueOf (4) 。</p>
<p>两个对象运算时可以写成i = i+ 6;</p>
<p>本来两个对象除了字符串是不能相加的，但这里做了一些动作：</p>
<p>i=new Integer(i.intValue()+6);//i.intValue() 这叫<strong>自动拆箱</strong>，即基本数据类型和引用数据类型进行运算时会拆箱。</p>
<p>这里注意Integer比int num多了一个null值，null一旦调用intValue()会发生控制异常，所以需要进行健壮性判断操作，这也是自动装箱拆箱的一个弊端</p>
<p>自动装箱拆箱一个特殊地方，可能会出<strong>面试题</strong></p>
<p><a href="https://blog.csdn.net/weixin_37650458/article/details/86714172" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37650458/article/details/86714172</a></p>
<p>这上面有具体的装箱和拆箱的题目实例，可以去看。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常用对象API-StringBuffer、StringBuilder类</title>
    <url>/2020/03/24/JavaSE-%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1API-StringBuffer%E3%80%81StringBuilder%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="常用对象API-StringBuffer、StringBuilder类"><a href="#常用对象API-StringBuffer、StringBuilder类" class="headerlink" title="常用对象API-StringBuffer、StringBuilder类"></a>常用对象API-StringBuffer、StringBuilder类</h1><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><h2 id="1特点-amp-添加功能-amp-插入"><a href="#1特点-amp-添加功能-amp-插入" class="headerlink" title="1特点&amp;添加功能&amp;插入"></a>1特点&amp;添加功能&amp;插入</h2><p>Buffer：缓冲区</p>
<p>StringBuffer:就是字符串缓冲区</p>
<p>​        用于存储数据的容器</p>
<p>特点：</p>
<p>1.长度是可变的</p>
<p>2.可以存储不同类型数据</p>
<p>3.最终要转成字符串进行使用</p>
<p>4.可以对字符串进行修改</p>
<a id="more"></a>

<p>功能：添加</p>
<p>StringBuffer append(data);</p>
<p>StringBuffer insert(index,data);//index是插入的位置索引，data是插入的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(<span class="number">2</span>).append(<span class="keyword">false</span>).append(<span class="string">"aa"</span>);</span><br><span class="line">sb.insert(<span class="number">2</span>,bb);</span><br><span class="line">结果：<span class="number">2f</span>alseaa</span><br><span class="line">     <span class="number">2f</span>bbalseaa</span><br></pre></td></tr></table></figure>

<p>2删除&amp;查找&amp;修改</p>
<p>删除</p>
<p>StringBuffer delete(int start,int end);包含头，不包含尾</p>
<p>StringBuffer deleteAt(int index);删除指定位置的元素</p>
<p>查找</p>
<p>char charAt(index);</p>
<p>int indexOf(string);</p>
<p>int lastIndexOf(string);</p>
<p>修改</p>
<p>StringBuffer replace(int start,int end,string str);</p>
<p>void setCharAt(index,char);</p>
<p>其他</p>
<p>设置长度：setLength(int num);</p>
<p>反转：reverse();</p>
<h2 id="3-可变长度数组"><a href="#3-可变长度数组" class="headerlink" title="3 可变长度数组"></a>3 可变长度数组</h2><p>StringBuffer有四种构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer();构造一个没有字符的字符串缓冲区，初始容量为<span class="number">16</span>个字符</span><br><span class="line">StringBuffer(CharSequence seq);构造一个包含与指定的相同字符的字符串缓冲区</span><br><span class="line">StringBuffer(<span class="keyword">int</span> capacity);构造一个没有字符的字符串缓冲区和指定的初始容量</span><br><span class="line">StringBuffer(String str);构造一个初始化为指定字符串内容的字符缓冲区</span><br></pre></td></tr></table></figure>

<p>如果用第一个构造方法，一开始默认是16个字符。若要进去第17个，则先复制原来的数组，创建为原来两倍的新数组，再将原来的数组复制到新数组。这是可变长度数组原理</p>
<p>第三个函数是指定初始容量。与第一个的区别是在于效率上。如果能一开始能确定数组在比如40个以内，则就构造40即可，若是第一个，一旦超过16，则要延长，要开辟空间，进行运算</p>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>1</p>
<p>StringBuilder类提供一个与StringBuffer兼容的API，功能一样，用法一样。其实就是一类。</p>
<p>但StringBuilder不保证同步，即不安全。</p>
<p>jdk1.5以后出现了功能和StringBuffer一模一样的对象，就是StringBuilder</p>
<p>不同的是</p>
<p>StringBuffer是线程同步的。通常用于多线程</p>
<p>StringBuilder是线程不同步的。通常用于单线程   </p>
<p>二者通常应该优先使用StringBuilder类，因为它支持所有相同的操作，但是由于它不执行同步，所以速度更快（不执行锁）。</p>
<p>jdk升级原因</p>
<p>1.简化书写</p>
<p>2.提高效率</p>
<p>3.增加安全性</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-常用对象API-String类</title>
    <url>/2020/03/24/JavaSE-%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1API-String%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="常用对象API-String类"><a href="#常用对象API-String类" class="headerlink" title="常用对象API-String类"></a>常用对象API-String类</h1><h2 id="1特点"><a href="#1特点" class="headerlink" title="1特点"></a>1特点</h2><p>字符串对象一旦被初始化就不会被改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"abc"</span>;</span><br><span class="line">s = <span class="string">"nba"</span>;</span><br><span class="line">System.out.println(s);</span><br><span class="line">结果：nba</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p>s是引用型变量，“abc”是被创建的字符串变量，它是不会被改变的。s=“nba”只是s引用的地址发生了变化。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"abc"</span>;</span><br><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s == s1);</span><br><span class="line">结果：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>原因：”abc”存储在字符串常量池中。如果没有就创建，如果有就直接拿来用。所以s建立时，到字符串常量池中找abc，发现没有，就建立，然后相应的地址赋给s。当s1也创建abc时，也在常量池中找，发现有，就直接拿其地址赋给s1，所以s和s1地址一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"abc"</span>;</span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s == s1);</span><br><span class="line">System.out.println(s.equals(s1));</span><br><span class="line">结果：<span class="keyword">false</span></span><br><span class="line">     <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>首先第一条是创建一个字符串对象在常量池中，第二条是创建两个对象一个new一个字符串对象在堆内存当中。然后s所引用的地址是常量池中abc的地址，s1引用的地址是new对象在堆内存中的地址，所以直接这两者比较是false。但是使用了equals方法结果是true是因为string类是Object类的子类，其equals复写Object中的equals建立了string类自己的判断字符串对象是否相同的依据，其实也就是比较字符串内容。</p>
<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h2><p>String(char[ ] value) </p>
<p>分配一个新的String ，以便它表示当前包含在字符数组参数中的字符序列。</p>
<p>字符数组的内容被复制; 字符数组的后续修改不会影响新创建的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">'w'</span>,<span class="string">'a'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'x'</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(arr);</span><br><span class="line">结果：s = wapqx</span><br></pre></td></tr></table></figure>

<p>String(char[ ] value,int offset,int count) </p>
<p>分配一个新的String ，其中包含字符数组参数的子阵列中的字符。 </p>
<p>offset参数是子阵列的第一个字符的索引，count参数指定子阵列的长度。 </p>
<p>副本的内容被复制; 字符数组的后续修改不会影响新创建的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">'w'</span>,<span class="string">'a'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'x'</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(arr,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">结果：s = pqx</span><br></pre></td></tr></table></figure>

<p>String(byte[ ] bytes)</p>
<p>通过使用平台的默认字符集解码指定的字节数组来构造新的String 。 </p>
<p>新的String的长度是字符集的函数，因此可能不等于字节数组的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arr = &#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">String s = <span class="keyword">new</span> String(arr);</span><br><span class="line">结果：s = ABCD</span><br></pre></td></tr></table></figure>

<p>数字相应转变为ASCII码中对应的字母。</p>
<p>更多的构造函数可以查看API文件</p>
<h2 id="3-常见功能-获取"><a href="#3-常见功能-获取" class="headerlink" title="3 常见功能-获取"></a>3 常见功能-获取</h2><p>1.获取</p>
<p>1.1 获取字符串中字符的个数(长度)</p>
<p>int length();</p>
<p>这与数组获取长度不用，数组获取长度是用的属性，而字符串是函数。</p>
<p>1.2 根据位置获取字符</p>
<p>char charAt(int index);</p>
<p>1.3 根据字符获取在字符串中第一次出现的位置即索引</p>
<p>int indexOf(int ch);参数是int类型，因为它会转成ASCII码。如果该字符不在则返回为-1</p>
<p>int indexOf(int ch,int fromIndex);从指定位置进行字符的查找，返回第一次出现的位置</p>
<p>int indexOf(String str);返回字符串在此字符串中第一次出现的位置</p>
<p>int indexOf(String str,int fromIndex);从指定位置进行字符串的查找，返回第一次出现的位置</p>
<p>根据字符获取在字符串中最后一次出现的位置即索引</p>
<p>int lastIndexOf(int ch);返回最后一次出现的位置</p>
<p>int lastIndexOf(int ch,int fromIndex);</p>
<p>int lastIndexOf(String str);</p>
<p>int lastIndexOf(String str,int fromIndex);</p>
<p>1.4 获取字符串中的一部分字符串，也叫子串</p>
<p>String substring (int beginIndex ,int endIndex);包含开始不包含结束</p>
<p>String substring (int beginIndex);</p>
<h2 id="4-常见功能-转换"><a href="#4-常见功能-转换" class="headerlink" title="4 常见功能-转换"></a>4 常见功能-转换</h2><p>2.1 将字符串变成字符串数组（字符串的切割）</p>
<p>String[ ] split(String regex);根据正则表达式的匹配拆分此字符串 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"张三,李四,王五"</span>;</span><br><span class="line">String[] arr = s.split(<span class="string">','</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">结果：张三</span><br><span class="line">     李四</span><br><span class="line">     王五</span><br></pre></td></tr></table></figure>

<p>如果是.的话，就需要转义一下，因为在正则表达式中.具有特殊的意义。转义需要两条反斜线，因为\.在正则表达式中也有特殊意义。</p>
<p>2.2 将字符串变成字符数组</p>
<p>char[ ] toCharArray();</p>
<p>2.3 将字符串转成字节数组</p>
<p>byte[ ] getBytes();</p>
<p>2.4 将字符串中的字母转成大小写</p>
<p>String toUpperCase();大写</p>
<p>String toLowerCase();小写</p>
<p>2.5 将字符串中的内容进行替换</p>
<p>String replace(char oldch,char newch);</p>
<p>String replace(string s1,string s2);</p>
<p>若要替换的字母在字符串中不存在，则该方法无效。然后两个引用变量的地址相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">String s2 = s1.replace(<span class="string">'a'</span>,<span class="string">'o'</span>);</span><br><span class="line">System.out.prinyln(s2);</span><br><span class="line">System.out.prinyln(s1 == s2);</span><br><span class="line">结果：jovo</span><br><span class="line">     <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>2.6 将字符串两端的空格去除</p>
<p>String trim();</p>
<p>2.7 将字符串进行连接</p>
<p>Srting concat(String str);</p>
<h2 id="5-常见功能-判断"><a href="#5-常见功能-判断" class="headerlink" title="5 常见功能-判断"></a>5 常见功能-判断</h2><p>3.1 两个字符串内容是否相同</p>
<p>boolean equals(Object obj);</p>
<p>boolean equalsIgnoreCase(String str);忽略大写比较字符串内容，原理就是全部转换成小写</p>
<p>3.2 字符串当中是否包含指定字符串</p>
<p>boolean contains(string str);</p>
<p>3.3 字符串是否以指定字符串开头，是否以指定字符串结尾</p>
<p>boolean startsWith(string str);</p>
<p>boolean endsWith(string str);</p>
<h2 id="6-常见功能-比较"><a href="#6-常见功能-比较" class="headerlink" title="6 常见功能-比较"></a>6 常见功能-比较</h2><p>对数值的比较用的是&lt;&gt;==等，如4&gt;1</p>
<p>对对象的比较如字符串用的是函数方法，如 “a”.compareTo(“A”)</p>
<p>字符串的比较是基于字符串中各个字符的Unicode值，按字典顺序将此String对象表示的字符序列与参数字符串所表示的字符序列进行比较</p>
<p>如果参数字符串等于此字符串，则返回值0。如果此字符串按字典顺序小于字符串参数，则返回一个小于0的值，如果此字符串按字典顺序大于字符串参数，则返回一个大于0的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.prinln(<span class="string">"abc"</span>.compareTo(<span class="string">"aqw"</span>));</span><br><span class="line">结果：-<span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="7-intern方法"><a href="#7-intern方法" class="headerlink" title="7 intern方法"></a>7 intern方法</h2><p>返回字符串对象的规范表示，可以对字符串池进行操作。 </p>
<p>最初为空的字符串池由类String私有地维护。 </p>
<p>当调用intern方法时，如果池已经包含与equals(Object)方法确定的等于此String对象的字符串，则返回来自池的字符串。否则，此String对象将添加到池中，并返回对此String对象的引用。 </p>
<p>它遵循以下规则，对于任何两个字符串s和t ，当且仅当s.equals(t)是true 时s.intern() == t.intern()是true。 </p>
<p>结果 </p>
<p>一个字符串与该字符串具有相同的内容，则保证来自一个唯一的字符串池。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-线程通信</title>
    <url>/2020/03/24/JavaSE-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="1-等待-唤醒机制"><a href="#1-等待-唤醒机制" class="headerlink" title="1 等待/唤醒机制"></a>1 等待/唤醒机制</h2><p>如何完成你输入一次我输出一次的操作。</p>
<p>这里就涉及到等待/唤醒机制</p>
<p>等待/唤醒机制</p>
<p>涉及的方法：</p>
<p>1.wait();</p>
<p>让线程处于冻结状态</p>
<p>被wait的线程会被存储到线程池中</p>
<p>如果线程在r锁被wait了，就存储在r锁的线程池中</p>
<p>就只能用r锁的notify来唤醒，锁就用来监视这个线程。</p>
<a id="more"></a>

<p>2.notify();</p>
<p>唤醒线程池中的一个线程（任意的）</p>
<p>3.notifyAll();</p>
<p>唤醒线程池中的所有线程</p>
<p>这些方法必须定义在同步中</p>
<p>因为这些方法是用于操作线程状态的方法，必须要明确到底操作的是哪个锁上的线程</p>
<p>为什么操作线程的方法定义在Object类中？</p>
<p>因为这些方法是监视器的方法，监视器其实就是锁。</p>
<p>锁可以是任意的对象，任意的对象调用的方法一定定义在Object当中。</p>
<p>if判断标记，只有一次，会导致不该运行的线程运行了，出现了数据错误的情况</p>
<p>while判断标记，解决了线程获取执行权后是否要运行！</p>
<p>notify只能唤醒一个线程，如果本方唤醒了本方，没有意义。而且while判断标记+notify会导致死锁</p>
<p>notifyAll解决了本方线程一定会唤醒对方线程。</p>
<p>但是唤醒所有的线程后，cpu执行的又是不需要的线程，则又要进行判断，这样效率不高，所以需要新的方法。</p>
<h2 id="2-JDK1-5新特性-Lock、Condition"><a href="#2-JDK1-5新特性-Lock、Condition" class="headerlink" title="2 JDK1.5新特性-Lock、Condition"></a>2 JDK1.5新特性-Lock、Condition</h2><p>1.5版本以后，有对同步进行技术更新              </p>
<p>原来synchronized(obj)中锁的操作是隐式的</p>
<p>1.5以后，引入lock 接口</p>
<p>Lock实现提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition。</p>
<p>思想：将同步和锁封装成了对象，并将操作锁的隐式方式定义到了该对象中，将隐式动作变成了显示动作。</p>
<p>所以相应的代码转变为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        code...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转变为</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock()<span class="comment">//获取锁</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock.unlock()放在finally中是因为万一执行代码出现异常，如果不放在这里，则不会执行解锁，但我们需要每步之后都要解锁。</p>
<p>Condition将Object监视器方法（ wait，notify和notifyAll）分装成不同的对象，以便通过将这些对象与任意Lock实现组合使用，为每个对象提供多个等待set（wait-set）。其中，Lock替换synchronized方法和语句的使用，Condition取代了Object监视器方法的使用。</p>
<p>即以前一个锁只有一组监视器方法，现在可以创建多个Condition对象，这样现在一个锁就可以有多个监视器方法</p>
<p>转变如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">    notify();</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"><span class="keyword">synchronized</span>(d)&#123;</span><br><span class="line">    d.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Condition</span></span>&#123;</span><br><span class="line">    await();<span class="comment">//对标wait();</span></span><br><span class="line">    signal();<span class="comment">//对标notify();</span></span><br><span class="line">    signalAll();<span class="comment">//对标signalAll();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转变为</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> reentrantLock();</span><br><span class="line">Condition c1 = lock.newCondition();</span><br><span class="line">Condition c2 = lock.newCondition();</span><br></pre></td></tr></table></figure>

<p>Lock接口：出现替代了同步代码块或者同步函数，将同步的隐式锁操作变成现实锁操作</p>
<p>同时更为灵活，可以一个锁上加上多组监视器</p>
<p>lock();获取锁</p>
<p>unlock();释放锁，通常需要定义在finally代码块中</p>
<p>Conditon接口：出现替代了Object中的wait notify notifyAll方法</p>
<p>​              将这些监视器方法单独进行了封装，变成Condition监视器对象</p>
<p>​              可以任意锁进行组合</p>
<p>await(); signal(); signalAll();</p>
<h2 id="3-wait和sleep的区别"><a href="#3-wait和sleep的区别" class="headerlink" title="3  wait和sleep的区别"></a>3  wait和sleep的区别</h2><p>wait和sleep区别</p>
<p>1.wait可以指定时间也可以不指定</p>
<p> sleep必须指定时间</p>
<p>2.在同步中是，对cpu的执行权和锁的处理不同</p>
<p> wait：释放执行权，释放锁</p>
<p> sleep：释放执行权，不释放锁</p>
<p>同步中可以进入有多个线程，但是要执行只能拿到锁的才能执行。</p>
<h2 id="4-停止线程的方式"><a href="#4-停止线程的方式" class="headerlink" title="4 停止线程的方式"></a>4 停止线程的方式</h2><p>第一种方式：定义标记</p>
<p>1.stop方法，已过时，不建议使用</p>
<p>2.run方法结束</p>
<p>怎么控制线程的任务结束</p>
<p>任务中都会有循环结构，只要控制住循环就可以结束任务。</p>
<p>控制循环通常就用定义标记来完成</p>
<p>第二种方式：Interrupt</p>
<p>但是如果线程处于冻结状态，就无法读取标记</p>
<p>可以使用interrupt();方法将线程从冻结状态强制恢复到运行状态中来，让线程具备cpu执行资格</p>
<p>但是强制动作会发生InterruptedException，记得要处理</p>
<h2 id="5-守护线程-setDaemon"><a href="#5-守护线程-setDaemon" class="headerlink" title="5 守护线程-setDaemon"></a>5 守护线程-setDaemon</h2><p>setDaemon();该方法将此线程标记为daemon线程或用户线程。</p>
<p>当正在运行的线程都是守护进程线程时，Java虚拟机将退出。</p>
<p>该方法必须在线程启动前调用。</p>
<p>也可以称为联合线程，后台线程</p>
<p>后台线程：它和前台线程都正常进行开启，运行也一样。结束时。前台线程结束需要手动结束，而后台线程如果所有前台都结束了，后台线程无论处于什么状态，都将结束。</p>
<h2 id="6-其他方法"><a href="#6-其他方法" class="headerlink" title="6 其他方法"></a>6 其他方法</h2><p>join</p>
<p>在进行线程运算时，希望临时加入一个线程进来进行运算，这是就要使用join方法。</p>
<p>join方法：等待这个线程结束，会抛出InterruptedException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="function">Thread <span class="title">t1</span><span class="params">(d)</span></span>;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="function">Thread <span class="title">t2</span><span class="params">(d)</span></span>;</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        </span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中：</p>
<p>第一个join方法：t1线程申请要加入进来，运行，然后主线程释放执行权和执行资格，主线程处于冻结状态。然后等待该线程运行结束才重新获得执行权</p>
<p>第二个join方法：若join在这，则主线程释放执行权和执行资格，处于冻结状态，t1和t2争抢执行权。主线程只有等t1执行完之后才能够重新获得执行资格和执行权</p>
<p>toString();返回此线程的字符串表示，包括线程的名称、优先级和线程组</p>
<p>*.setPriority(Thread.MAX_PRIORITY);可以将其设置为最高优先级</p>
<p>线程组</p>
<p>表示一个线程的集合。此外，线程组也可以包含其他线程。线程组构成一颗树，在树中，除了初始线程组外，每个线程组都有一个父线程组。具体以后再说。</p>
<p>yield();暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>即当线程执行该方法时，释放执行权。这样别的线程和该线程又开始同时竞争执行权</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-线程安全、同步、锁</title>
    <url>/2020/03/23/JavaSE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E9%94%81/</url>
    <content><![CDATA[<h1 id="线程安全、同步、锁"><a href="#线程安全、同步、锁" class="headerlink" title="线程安全、同步、锁"></a>线程安全、同步、锁</h1><h2 id="1-线程安全问题的现象、问题产生的原因"><a href="#1-线程安全问题的现象、问题产生的原因" class="headerlink" title="1 线程安全问题的现象、问题产生的原因"></a>1 线程安全问题的现象、问题产生的原因</h2><p>建立多线程进行买票操作时，可能会出现这样一种状况：假设当票数减到1时，cpu切到线程0运行，符合票数&gt;0的条件，线程0就具备执行资格，但这时cpu突然切换到线程1，同样这时票数还是为1，线程1也符合条件，具备执行资格，然后这时cpu又切换回线程0，执行输出语句，执行完，票数变为0，然后切到线程1，执行输出语句，这时票数输出为0，但这是不符合条件的，却又输出了。这就出现了线程安全问题。</p>
<p><strong>线程安全问题产生的原因</strong>:</p>
<p>1.多个线程在操作共享数据。</p>
<p>2.操作共享数据的线程代码有多条</p>
<p>当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问题的产生。</p>
<a id="more"></a>

<h2 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2 同步代码块"></a>2 同步代码块</h2><p>解决上述问题的方法</p>
<p>解决思路</p>
<p>就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码时,其他线程不可以参与运算，</p>
<p>必须要当前线程把这些代码都执行完毕以后，其他线程才可以参与运算。</p>
<p>在java中，用同步代码块就可以解决这个问题</p>
<p>同步代码块的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">				<span class="keyword">if</span>(num &gt; <span class="number">0</span>)</span><br><span class="line">                    System.out.println(num--);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-同步的原理"><a href="#3-同步的原理" class="headerlink" title="3 同步的原理"></a>3 同步的原理</h2><p>原理：synchronized(对象)，里面的对象是同步锁，当线程0运行到此时判断锁为1，就运行里面的代码，同时同步锁变为0。当线程0被睡眠时，cpu执行线程1，但是线程1运行到此时，同步锁为0，不能运行里面的代码，所以就解决了上述的问题。</p>
<h2 id="4-同步的前提"><a href="#4-同步的前提" class="headerlink" title="4 同步的前提"></a>4 同步的前提</h2><p>同步的前提：同步中必须有多个线程并使用同一个锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">            <span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">				<span class="keyword">if</span>(num &gt; <span class="number">0</span>)</span><br><span class="line">                    System.out.println(num--);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述中将同步对象定义在run函数中，这样当线程执行start()时，每个线程就都有一个锁，安全问题就没有得到解决。</p>
<h2 id="5-同步函数"><a href="#5-同步函数" class="headerlink" title="5 同步函数"></a>5 同步函数</h2><p>我们引入同步函数，即同步的第二种表现形式。被同步关键字修饰的函数就是同步函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num &gt; <span class="number">0</span>)</span><br><span class="line">            	System.out.println(num--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证同步函数的锁</p>
<p><strong>同步函数使用的锁是：this</strong></p>
<p>同步函数和同步代码块的<strong>区别</strong>：</p>
<p>同步函数的锁是固定的this</p>
<p>同步代码块的锁是任意的对象</p>
<p><strong>建议使用同步代码块。</strong></p>
<p>验证程序：构造两个线程，一个线程用同步代码，一个线程用同步函数，若改变同步代码块里的锁，若不出现安全问题，则同步代码块里的锁就是同步函数的锁。</p>
<p>验证<strong>静态</strong>同步函数的锁</p>
<p>静态的同步函数使用的锁：</p>
<p><strong>该函数所属字节码文件对象</strong>，可以用getClass方法获取，也可以用当前 类名.class 表示。</p>
<p>锁对象是唯一的。</p>
<h2 id="6-单例模式涉及的多线程问题"><a href="#6-单例模式涉及的多线程问题" class="headerlink" title="6 单例模式涉及的多线程问题"></a>6 单例模式涉及的多线程问题</h2><p>懒汉式在多线程时会遇到安全问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样多线程就会产生多个对象，达不到单例效果</p>
<p>为了解决该问题，则同步</p>
<p>1.使用同步函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            s = <span class="keyword">new</span> Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然解决了安全问题，但是效率会很低</p>
<p>2使用同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>()&#123;</span><br><span class="line">            	<span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">            		s = <span class="keyword">new</span> Single();</span><br><span class="line">        		&#125;	 </span><br><span class="line">        	&#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样既解决了安全问题，又解决了效率问题</p>
<h2 id="7-死锁示例"><a href="#7-死锁示例" class="headerlink" title="7 死锁示例"></a>7 死锁示例</h2><p>死锁：常见情景之一：同步的嵌套，即假设有两个线程，它们各自拿着一个锁，想进去有着另一个锁的同步代码块，但双方拿着锁不放，这样就进不去另一锁的同步代码块，就死锁了。</p>
<p>一个简单的死锁程序代码，面试若让当场写出一个就可以写这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    Test(<span class="keyword">boolean</span> flag)&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Myclock.locka)&#123;</span><br><span class="line">                System.out.println(<span class="string">"if locka..."</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(Myclock.lockb)&#123;</span><br><span class="line">                     System.out.println(<span class="string">"if lockb..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Myclock.lockb)&#123;</span><br><span class="line">                System.out.println(<span class="string">"else lockb..."</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(Myclock.locka)&#123;</span><br><span class="line">                     System.out.println(<span class="string">"else locka..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mylock</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object locka = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lockb = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test(<span class="keyword">true</span>);</span><br><span class="line">        Test b = <span class="keyword">new</span> Test(<span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(b);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-多线程</title>
    <url>/2020/03/23/JavaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-多线程-概述"><a href="#1-多线程-概述" class="headerlink" title="1 多线程-概述"></a>1 多线程-概述</h2><p>进程：正在进行中的程序（直译）</p>
<p>线程：就是进程中一个负责程序执行的控制单元（执行路径）</p>
<p>一个进程中可以有多个执行路径，称之为多线程</p>
<p>一个进程当中至少有个线程。</p>
<p>开启多个线程是为了同时运行多部分代码</p>
<p>每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务。</p>
<p>好处与弊端</p>
<p>好处：解决了多部分同时运行的问题。</p>
<p>弊端：线程太多会导致效率低下，因为一个cpu只能同行运行一个线程，线程太多则会让cpu效率降低。</p>
<p>其实应用程序的执行都是cpu在做着快速的切换完成的。这个切换是随机的。</p>
<a id="more"></a>

<h2 id="2-JVM中的多线程解析"><a href="#2-JVM中的多线程解析" class="headerlink" title="2 JVM中的多线程解析"></a>2 JVM中的多线程解析</h2><p>JVM启动时就启动了多个线程，至少有两个线程可以分析的出来</p>
<p>1.执行main函数的线程，</p>
<p>​       该线程的任务代码都定义在main函数中。</p>
<p>2.负责垃圾回收的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;<span class="comment">//当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</span></span><br><span class="line">        System.out.println(<span class="string">"demo ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">        System.gc();<span class="comment">//运行垃圾回收器</span></span><br><span class="line">        <span class="keyword">new</span> Demo();</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果<span class="number">1</span>：hello world		结果<span class="number">2</span>：demo ok			结果<span class="number">3</span>：hello world</span><br><span class="line">      demo ok				hello world			  demo ok</span><br><span class="line">      demo ok				demo ok</span><br></pre></td></tr></table></figure>

<p>这个例子显示了有两个线程在运行。当启动垃圾回收器时，就运行了垃圾回收线程，然后主线程仍在运行，所以会出现Hello World！。因为cpu运行线程的时候是随机的，所以Hello World！和demo ok出现顺序也是随机的。当函数运行结束时，虚拟机关闭，导致强制回收，所以出现demo ok的个数也不一样。</p>
<h2 id="3-主线程运行实例、多线程创建的方式-继承Thread类"><a href="#3-主线程运行实例、多线程创建的方式-继承Thread类" class="headerlink" title="3 主线程运行实例、多线程创建的方式-继承Thread类"></a>3 主线程运行实例、多线程创建的方式-继承Thread类</h2><p>Thread：是程序中的执行线程。Java虚拟机允许应用程序<strong>并发</strong>地运行多个执行线程。</p>
<p>创建线程的目的是为了开启一条执行路径，让指定的代码和其他代码实现同时运行</p>
<p>而运行的指定代码就是这个执行路径的任务</p>
<p>而自定义的线程它的任务在哪呢？</p>
<p>Thread类用于描述线程，线程是需要任务的。所以Thread类也有对任务的描述</p>
<p>这个任务就通过<strong>Thread类中的run方法</strong>来体现，也就是说run方法就是封装自定义线程运行任务的函数。</p>
<p>run方法中定义就是线程要运行的任务代码。所以需要<strong>覆盖Thread类中的run方法</strong>。</p>
<p>开启线程是为了运行指定代码，所有只有继承Thread类并复写run方法，将运行的代码定义在run方法中即可。</p>
<p>如何创建一个线程</p>
<p><strong>创建线程方式一</strong>：继承Thread类</p>
<p>步骤：</p>
<p>1.定义一个类继承Thread类</p>
<p>2.覆盖Thread类中run方法</p>
<p>3.直接创建Thread类中的子类对象创建线程</p>
<p>4.调用start方法开启线程，并调用线程的任务，run方法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Threads</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Demo(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">"...x="</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo d1 = <span class="keyword">new</span> Demo(<span class="string">"啊啊啊"</span>);</span><br><span class="line">        Demo d2 = <span class="keyword">new</span> Demo(<span class="string">"aaa"</span>);</span><br><span class="line">        d1.start();<span class="comment">//开启线程</span></span><br><span class="line">        d2.start();</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考</strong>：调用run和调用start有什么区别</p>
<p>调用run相当于调用了一个普通的方法，还是在主线程中运行，没有实现多线程。调用start开启了新的线程，run方法自动在该新线程运行。</p>
<h2 id="4-Thread类中的方法-amp-线程名称"><a href="#4-Thread类中的方法-amp-线程名称" class="headerlink" title="4 Thread类中的方法&amp;线程名称"></a>4 Thread类中的方法&amp;线程名称</h2><p>可以通过Thread类中的getName方法获取线程的名称：Thread-编号（从0开始）</p>
<p>当线程一创建时就会有名称，不管它有没有开启。</p>
<p>返回当前运行线程的名字用currentThread方法：Thread.currentThread().getName();</p>
<p>返回对当前正在执行的线程对象的引用。 </p>
<p>结果：当前正在执行的线程。</p>
<p>也可以给线程命名，因为Thread类中有Thread(String name)构造函数</p>
<h2 id="5-多线程运行图解"><a href="#5-多线程运行图解" class="headerlink" title="5 多线程运行图解"></a>5 多线程运行图解</h2><p>主线程路径在执行的过程中，当读到d1.start()时，开启一条路径run，当读到d2.start()时。又开启一条路径run。相当于每个路径在栈中都有一个独立的空间，且互不冲突。每个run方法里面都有个变量x。如果有个线程执行一个方法，则这个方法就进这个线程所在的栈区，结束后弹栈。这个线程的run方法结束，则这个线程所占用的空间就释放。如果主线程结束了，虚拟机不会结束，因为还有线程在运行。所以只要有线程在运行，虚拟机就不会结束。</p>
<p>如果哪个线程发生了异常，则这个线程就停止执行，但其他线程不受到影响。</p>
<h2 id="6-线程的状态"><a href="#6-线程的状态" class="headerlink" title="6 线程的状态"></a>6 线程的状态</h2><p>线程有四种状态</p>
<p>被创建、运行、冻结、消亡</p>
<p>CPU的执行资格：可以被cpu处理，在处理队列中排队</p>
<p>CPU的执行权：正在被cpu处理</p>
<h2 id="7-创建线程的第二种方式-实现Runnable接口"><a href="#7-创建线程的第二种方式-实现Runnable接口" class="headerlink" title="7 创建线程的第二种方式-实现Runnable接口"></a>7 创建线程的第二种方式-实现Runnable接口</h2><p>如果类已经继承了一个父类，则若准备扩展Demo类的功能，让其中的内容可以作为线程的任务执行，需要通过接口完成。所有就有了第二种方式</p>
<p>Runnable接口：应该由那些打算通过某一线程执行其实例的类来实现。类必须定义为一个称为run的无参数方法。</p>
<p>创建线程的第二种方式：实现Runnable接口</p>
<p>1.定义类实现Runnable接口</p>
<p>2.覆盖接口中的run方法，将线程的任务代码封装到run方法中</p>
<p>3.通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类构造函数的</p>
<p>参数进行传递</p>
<p>​    <strong>为什么</strong>？</p>
<p>​    因为线程任务都封装在Runnable接口子类对象的run方法中，所以要在线程对象创建时就必须明确要运行的任务。</p>
<p>4.调用线程对象的start方法开启线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"..."</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节：</p>
<p>Thread t1= new Thread(d);</p>
<p>这里有个细节就是本身Thread类里面有一个run方法，对象d里面也有一个run方法，那么到底是执行哪个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable r;</span><br><span class="line">    Thread()&#123;&#125;;</span><br><span class="line">    Thread(Runnable r)&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> run <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadImp1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Threads</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"haha"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadImp1 i = <span class="keyword">new</span> ThreadImp1();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(i);</span><br><span class="line">Demo t2 = <span class="keyword">new</span> Demo();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>从这个化简的源代码进行分析。</p>
<p>第二个方式的好处</p>
<p>Runnable接口的出现仅仅是将线程的任务进行了对象的封装。这是思想上的转变，需要重点关注。</p>
<p>Thread类对Runnable接口进行了默认实现。</p>
<p>实现Runnable接口的好处：</p>
<p>1.将线程的任务从线程的子类中分离出来进行了单独的封装，按照面向对象的思想将任务封装成对象。</p>
<p>2.避免了java单继承的局限性</p>
<p>所以创建线程的第二种方式较为常用。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象-包</title>
    <url>/2020/03/22/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8C%85/</url>
    <content><![CDATA[<h1 id="面向对象-包"><a href="#面向对象-包" class="headerlink" title="面向对象-包"></a>面向对象-包</h1><h2 id="1-面向对象-包-概述"><a href="#1-面向对象-包-概述" class="headerlink" title="1 面向对象-包-概述"></a>1 面向对象-包-概述</h2><p>对类文件进行分类管理</p>
<p>给类提供多层命名（名称）空间</p>
<p><strong>写在程序文件第一行</strong></p>
<p><strong>类名的全称的：包名.类名。</strong></p>
<p>包也是一种封装形式</p>
<p>包在系统中的表现形式是文件夹</p>
<p>包命名时字母都小写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack</span><br></pre></td></tr></table></figure>

<p>也可以创建多级包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack.aa.bb.cc.dd</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-面向对象-包-包之间的访问-protected"><a href="#2-面向对象-包-包之间的访问-protected" class="headerlink" title="2 面向对象-包-包之间的访问-protected"></a>2 面向对象-包-包之间的访问-protected</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PackageDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DemoA d = <span class="keyword">new</span> DemoA();</span><br><span class="line">        d.show();</span><br><span class="line">        System.out.println(<span class="string">"hello package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> packa;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"demoa show run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，要先编译DemoA.java。以前在同一个包中时，先编译PackageDemo.java时，会在当前包中找所需要的类，如果没有就找需要的.java源文件。但是现在不在同一个包中，DemoA有个包所属，所以我们要用的这个类全称是packa.DemoA.class，如果没有就找packa.DemoA.java，然而在目前的情况下是找不到，因为其源文件不在packa文件夹中，在别的地方，所以是找不到的。所以要先编译后者。</p>
<p>按顺序编译后出现问题</p>
<p>原因 类型名写错</p>
<p>因为DemoA类已经有包的所属，所以必须要明确其包名</p>
<p>记住：DemoA这个名字是错的，正确的名称是<strong>包名.类名. packa.DemoA</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">packa.Demoa d = <span class="keyword">new</span> packa.DemoA();</span><br></pre></td></tr></table></figure>

<p>再次编译，仍出现问题</p>
<p>原因：DemoA不是公共的，加public</p>
<p>加了之后，还是出现问题</p>
<p>原因：show()不是公共的，加public</p>
<p>总结：</p>
<p>包与包之间的类进行访问，被访问的包中的类必须是public的，被访问包中的类的方法也必须是public的。</p>
<p>protected（保护）：被这个修饰的类、函数。同一包中的类可以访问，不同包中，只有其子类才可以使用。</p>
<table>
<thead>
<tr>
<th>四种权限</th>
<th>public</th>
<th>protected</th>
<th>default(默认全限)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
</tr>
<tr>
<td>同一包中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
</tr>
<tr>
<td>子类中</td>
<td>ok</td>
<td>ok</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中</td>
<td>ok</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-面向对象-包-导入import"><a href="#3-面向对象-包-导入import" class="headerlink" title="3 面向对象-包-导入import"></a>3 面向对象-包-导入import</h2><p>Import：导入其他包中的类。这样在调用其他包中的类就不用加包名称，简化类名书写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br><span class="line"><span class="keyword">import</span> packa.DemoA;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PackageDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DemoA d = <span class="keyword">new</span> DemoA();</span><br><span class="line">        d.show();</span><br><span class="line">        System.out.println(<span class="string">"hello package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>import packa.<em>;：导入了packa包中所有的类，但*</em>不导入其包中的子包**。</p>
<p>比如</p>
<p>packa\DemoA.class</p>
<p>packa\abc\DemoAbc.class</p>
<p>import packa.*时，不导入DemoAbc.class。</p>
<p><strong>导包原则</strong>：用到哪个类，就导入哪个类，不建议一起全部导入。</p>
<p>4 面向对象-包-jar包</p>
<p>Jar：java的压缩包，不是图形化界面的工具，是dos命令行形式的工具</p>
<p>用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files …</p>
<p>选项:</p>
<p>  -c 创建新档案</p>
<p>  -t 列出档案目录</p>
<p>  -x 从档案中提取指定的 (或所有) 文件</p>
<p>  -u 更新现有档案</p>
<p>  -v 在标准输出中生成详细输出</p>
<p>  -f 指定档案文件名</p>
<p>  -m 包含指定清单文件中的清单信息</p>
<p>  -n 创建新档案后执行 Pack200 规范化</p>
<p>  -e 为捆绑到可执行 jar 文件的独立应用程序</p>
<p>​    指定应用程序入口点</p>
<p>  -0 仅存储; 不使用任何 ZIP 压缩</p>
<p>  -P 保留文件名中的前导 ‘/‘ (绝对路径) 和 “..” (父目录) 组件</p>
<p>  -M 不创建条目的清单文件</p>
<p>  -i 为指定的 jar 文件生成索引信息</p>
<p>  -C 更改为指定的目录并包含以下文件</p>
<p>如果任何文件为目录, 则对其进行递归处理。</p>
<p>清单文件名, 档案文件名和入口点名称的指定顺序</p>
<p>与 ‘m’, ‘f’ 和 ‘e’ 标记的指定顺序相同。</p>
<p>示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中:</p>
<p>​    jar cvf classes.jar Foo.class Bar.class</p>
<p>示例 2: 使用现有的清单文件 ‘mymanifest’ 并将 foo/ 目录中的所有文件归档到 ‘classes.jar’ 中:</p>
<p>​    jar cvfm classes.jar mymanifest -C foo/ .</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象-Object类</title>
    <url>/2020/03/22/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="面向对象-Object类"><a href="#面向对象-Object类" class="headerlink" title="面向对象-Object类"></a>面向对象-Object类</h1><h2 id="1-面向对象-Object类-equals方法、equals方法覆盖"><a href="#1-面向对象-Object类-equals方法、equals方法覆盖" class="headerlink" title="1 面向对象-Object类-equals方法、equals方法覆盖"></a>1 面向对象-Object类-equals方法、equals方法覆盖</h2><p>equals比较对象是否相同，<strong>比较的是地址</strong>。</p>
<p>但是单纯比较地址值没有意义，一般都会覆盖equals方法，根据对象的特有内容，建立判断对象是否相同的依据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))<span class="comment">//先判断是否为同类型&#123;</span></span><br><span class="line">            <span class="function">thow new <span class="title">ClassCastException</span><span class="params">(<span class="string">"类型错误"</span>)</span></span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	Person p = (Person) obj;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.age == p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">30</span>);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">20</span>);</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-面向对象-Object类-hashCode方法"><a href="#2-面向对象-Object类-hashCode方法" class="headerlink" title="2 面向对象-Object类-hashCode方法"></a>2 面向对象-Object类-hashCode方法</h2><p>hashCode：返回该对象的哈希码值</p>
<p>实际上Object类定义的hashCode方法确实会针对不同的对象返回不同的整数（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是Java编程语言不需要这种实现技巧）。</p>
<p>在Java应用程序执行期间，在对同一个对象多次调用hashCode方法时，必须一致地返回相同的整数，前提是将对象进行equals比较时所用的信息没有被修改，</p>
<p>如果根据equals方法两个对象是相等的，那么对这两个对象进行hashCode方法都必须生成相同的整数结果。</p>
<p>当equals被重写时，通常有必要重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
<p>同样也可以复写其方法，改变哈希值的算法定义</p>
<h2 id="3-面向对象-Object类-getClass方法"><a href="#3-面向对象-Object类-getClass方法" class="headerlink" title="3 面向对象-Object类-getClass方法"></a>3 面向对象-Object类-getClass方法</h2><p>getClass方法返回此Object的运行时类，返回的是当前对象所属的字节码文件对象，</p>
<p>即class Class，里面有名称、字段（属性）、构造器、方法。</p>
<p>如果加载进一个Person类，第一步在堆中产生一个对应的字节码文件对象，即Person.Class</p>
<p>所以当类加载时，就会有对象产生，</p>
<h2 id="4-面向对象-Object类-toString方法"><a href="#4-面向对象-Object类-toString方法" class="headerlink" title="4 面向对象-Object类- toString方法"></a>4 面向对象-Object类- toString方法</h2><p>toString方法返回该对象的字符串表示</p>
<p>Object类的该方法返回一个字符串，该字符串有类名、@、和此对象哈希码的无符号+十六进制表示组成，换句话说，该方法返回一个字符串，它的值等于</p>
<p>getClass().getName()+”@”+Interger.toHexString(hashCode())</p>
<p>建议所有子类都重写该方法。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象异常</title>
    <url>/2020/03/22/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="面向对象-异常"><a href="#面向对象-异常" class="headerlink" title="面向对象-异常"></a>面向对象-异常</h1><h2 id="1-面向对象-异常-概述"><a href="#1-面向对象-异常-概述" class="headerlink" title="1 面向对象-异常-概述"></a>1 面向对象-异常-概述</h2><p>异常：是在运行时期发生的不正常情况。</p>
<p>在java中用类的形式对不正常情况进行描述和封装对象</p>
<p>描述不正常的情况的类，就称为异常类。</p>
<p>以前正常流程代码和问题处理代码相结合，</p>
<p>现在将正常流程代码和问题处理代码分离，提高阅读性。</p>
<p>其实异常就是java通过面向对象的思想将问题封装成了对象</p>
<p>用异常类对其进行描述。</p>
<p>不同的问题用不同的类进行具体的描述。比如角标越界，空指针等等。</p>
<a id="more"></a>

<h2 id="2-面向对象-异常-体系"><a href="#2-面向对象-异常-体系" class="headerlink" title="2 面向对象-异常-体系"></a>2 面向对象-异常-体系</h2><p>问题很多，意味着描述的类也很多</p>
<p>将其共性进行向上抽取，形成了异常体系</p>
<p>最终问题（不正常情况）分成两大类</p>
<p>Throwable:无论是error还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理</p>
<p>​           该体系的特点就在于Throwable及其所有的子类都具有可抛性。</p>
<p>可抛性指的是什么？如何体现可抛性？</p>
<p>​           通过两个关键字来体现的，分别是throws，throw</p>
<p>​           凡是可以被这两个关键字所操作的类和对象都具备可抛性。</p>
<p>1.一般不可处理的。用Error表示</p>
<p>​    特点：是有jvm抛出的严重性的问题</p>
<p>​       这种问题发生一般不针对性处理。直接修改程序。</p>
<p>2.可处理的。用Exception表示</p>
<p>该体系特点：</p>
<p>子类的后缀名都是用其父类名作为后缀，阅读性很强。</p>
<h2 id="3-面向对象-异常-原理-amp-异常对象的抛出throw"><a href="#3-面向对象-异常-原理-amp-异常对象的抛出throw" class="headerlink" title="3 面向对象-异常-原理&amp;异常对象的抛出throw"></a>3 面向对象-异常-原理&amp;异常对象的抛出throw</h2><p>原理：</p>
<p>1.遇到识别的问题进行对象的封装</p>
<p>2.将问题抛给调用者，结束函数。</p>
<p>我们可以自己设置异常</p>
<p>谁调用就将异常抛给谁，还可以自己定义异常信息，这里用到了throw 关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组引用不能为空"</span>);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= arr.length)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"角标越界"</span>);</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"角标不能为负数"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">int</span> num = d.method(<span class="keyword">null</span>, -<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：Exception in thread <span class="string">"main"</span> java.lang.NullPointException：数组的引用不能为空</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-异常-自定义异常-amp-异常类的抛出throws"><a href="#4-面向对象-异常-自定义异常-amp-异常类的抛出throws" class="headerlink" title="4 面向对象-异常-自定义异常&amp;异常类的抛出throws"></a>4 面向对象-异常-自定义异常&amp;异常类的抛出throws</h2><p>对于角标是整数不存在，可以用角标越界表示</p>
<p>对于负数为角标的情况，准备用负数角标异常来表示</p>
<p>负数角标这种异常在java中并没有定义过</p>
<p>那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象</p>
<p>这种自定义的问题描述称为自定义异常</p>
<p><strong>注意</strong>：如果让一个类成为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性才可以被两个关键字所操作，throws，throw</p>
<p>除此之外，如果函数内发生了异常，<strong>还需要在函数上进行声明</strong>，如下所示。否则编译失败，声明的目的是为了处理。调用发生异常的函数，必须要处理，处理的方式之一就是抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(...)</span> <span class="keyword">throws</span> xxxException</span></span><br></pre></td></tr></table></figure>

<h2 id="5-编译时检测异常和运行时异常的区别-amp-throw和throws的区别"><a href="#5-编译时检测异常和运行时异常的区别-amp-throw和throws的区别" class="headerlink" title="5 编译时检测异常和运行时异常的区别&amp;throw和throws的区别"></a>5 编译时检测异常和运行时异常的区别&amp;throw和throws的区别</h2><p>异常的分类</p>
<p>1.编译时被检测异常：只要是Exception和其子类都是，除了特殊子类RuntimeException体系。</p>
<p>​    这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。</p>
<p>​    这样的问题都可以针对性的处理。</p>
<p>2.编译时不检测异常（运行时异常）：就是Exception中的RuntimeException和其子类</p>
<p>​    RuntimeException是那些可能在Java虚拟机正常运行期间抛出的异常超类。</p>
<p>​    这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的或者引发了内部状态的改变导致的。</p>
<p>​    这种问题一般不处理，直接编译通过，在运行时，让调用者调用时的程序强制停止，让调用者对代码进行修正。</p>
<p>​    在执行方法期间抛出但未被捕获的RuntimeException的任何子类都无需再throws子句中进行声明。</p>
<p>throws和throw的区别</p>
<ol>
<li><p>throws使用在函数上</p>
<p>throw使用在函数内</p>
</li>
<li><p>throws抛出的是异常类，可以抛出多个，用逗号隔开</p>
<p>throw抛出的是异常对象，只能抛出一个，因为抛出后函数就停止了。</p>
</li>
</ol>
<h2 id="6-面向对象-异常-异常捕捉trycatch"><a href="#6-面向对象-异常-异常捕捉trycatch" class="headerlink" title="6 面向对象-异常-异常捕捉trycatch"></a>6 面向对象-异常-异常捕捉trycatch</h2><p>异常处理的捕捉形式：</p>
<p>这是可以对异常进行针对性处理的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//需要被检测异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 变量)<span class="comment">//该变量用于接收发生的异常对象&#123;</span></span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候用trycatch</p>
<p>当在这里可以处理时用trycatch，如果不能处理，则继续抛出。</p>
<p>过程：</p>
<p>执行method函数，函数进栈，往里面传值。-30满足条件，则异常抛出被触发，然后将异常抛出到主函数调用的部分中。然后try开始检测，检测到后丢给了catch，然后catch里的参数变量接收异常对象即FuShuIndexException e=new FuShuIndexException(“角标变成负数啦”);</p>
<p>若传入的值是不发生异常的，则程序正常运行</p>
<p>对catch里面的异常类对象进行常见方法调用</p>
<p>e.getMessage()</p>
<p>e.printStackTrace()</p>
<p>略</p>
<h2 id="7-面向对象-异常-多catch情况"><a href="#7-面向对象-异常-多catch情况" class="headerlink" title="7 面向对象-异常-多catch情况"></a>7 面向对象-异常-多catch情况</h2><p>有几个抛出就有几个catch</p>
<p>有多个catch，抛出的异常就按顺序进行catch。</p>
<p>然后多catch情况下父类的catch放在最下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(...)</span> <span class="keyword">throws</span> xxxException，yyyException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>() <span class="keyword">throw</span> <span class="keyword">new</span> xxxException();</span><br><span class="line">    <span class="keyword">if</span>() <span class="keyword">throw</span> <span class="keyword">new</span> yyyException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//因为有trycatch了所以不用声明</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">int</span> num = d.method(<span class="keyword">null</span>, -<span class="number">30</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(xxxException e)&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(yyyException e)&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	System.out.println(“over”);</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-面向对象-异常-异常处理原则"><a href="#8-面向对象-异常-异常处理原则" class="headerlink" title="8 面向对象-异常-异常处理原则"></a>8 面向对象-异常-异常处理原则</h2><p>异常处理的原则：</p>
<p>1.函数内部如果抛出异常需要检测的异常，那么函数上必须要声明，否则必须在函数内用trycatch捕捉，否则编译失败。</p>
<p>2.如果调用到了声明异常的函数，要么trycatch要么throws，否则编译失败。</p>
<p>3.什么时候catch，什么时候throws：功能内部可以解决用catch，解决不了用throws，告诉调用者，由调用者解决。</p>
<p>4.一个功能如果抛出了多个异常，那么调用时必须有对应多个catch进行针对性的处理。内部有几个需要检测的异常，就抛出几个，就catch几个。</p>
<h2 id="9-面向对象-异常-finally代码块"><a href="#9-面向对象-异常-finally代码块" class="headerlink" title="9 面向对象-异常-finally代码块"></a>9 面向对象-异常-finally代码块</h2><p>finally通常用于关闭（释放）资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//一定会被执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try catch finally 代码块组合特点：</p>
<p>1.try catch finally</p>
<p>2.try catch(多个)d当没有必要资源需要释放时，可以不用定义finally</p>
<p>3.try finally//异常无法直接catch处理，但是资源需要关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		开启资源</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		关闭资源</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//这时没有catch就没有处理，就需要声明即throws。</span></span><br></pre></td></tr></table></figure>

<h2 id="10-面向对象-异常-异常注意事项"><a href="#10-面向对象-异常-异常注意事项" class="headerlink" title="10 面向对象-异常-异常注意事项"></a>10 面向对象-异常-异常注意事项</h2><p>异常的注意事项：</p>
<p>1.子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的子类或者不抛。</p>
<p>2.如果父类抛出多个异常，那么子类只能抛出父类异常的子集。即父类有ABCD 四个异常，子类只能抛出其中3个及其以下的异常</p>
<p>简单说子类覆盖父类，只能抛出父类的异常或者子类或者子集。</p>
<p><strong>注意</strong>：如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，就只能try。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象多态内部类</title>
    <url>/2020/03/21/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="面向对象-多态-amp-内部类"><a href="#面向对象-多态-amp-内部类" class="headerlink" title="面向对象-多态&amp;内部类"></a>面向对象-多态&amp;内部类</h1><h2 id="1-面向对象-多态-概述、好处"><a href="#1-面向对象-多态-概述、好处" class="headerlink" title="1 面向对象-多态-概述、好处"></a>1 面向对象-多态-概述、好处</h2><p>定义：某一类型事物的多种存在形态</p>
<p>对象的多态性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 猫 <span class="keyword">extends</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 狗 <span class="keyword">extends</span> 动物</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoTaiDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        猫 x=<span class="keyword">new</span> 猫();</span><br><span class="line">		动物 x=<span class="keyword">new</span> 猫();<span class="comment">//一个对象两种形态。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猫这类事物即具备着猫的形态，又具备着动物的形态</p>
<p>这就是对象的多态性。</p>
<p>简单说<strong>就是一个对象对应着不同类型。</strong></p>
<p>多态在代码中的体现：父类或者接口的引用指向其子类的对象。</p>
<p>多态的好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容</p>
<h2 id="2-面向对象-多态-弊端-amp-前提"><a href="#2-面向对象-多态-弊端-amp-前提" class="headerlink" title="2 面向对象-多态-弊端&amp;前提"></a>2 面向对象-多态-弊端&amp;前提</h2><p>多态的弊端：前期定义的内容不能使用（调用）后期子类的特有内容。</p>
<p>动物 x = new 猫();这个对象x不能调用猫类中的特有内容。但方法若能调用，则都是猫类中复写的方法。</p>
<p>多态的前提</p>
<p>1.必须有关系，继承，实现</p>
<p>2.要有覆盖</p>
<h2 id="3-面向对象-多态-转型"><a href="#3-面向对象-多态-转型" class="headerlink" title="3 面向对象-多态-转型"></a>3 面向对象-多态-转型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal x=<span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>

<p>自动类型提升，猫对象提升了为动物类型。但是特有功能无法访问。</p>
<p>作用就是提高扩展性和限制对特有功能的访问。</p>
<p>专业讲：向上转型。将子类型隐藏，就不能使用子类的特有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c = (Cat)x;</span><br></pre></td></tr></table></figure>

<p>如果还想用具体动物猫的特有功能，你可以将该对象进行向下转型</p>
<p>写法与强制转型相同</p>
<p>向下转型的目的是为了使用子类中的特有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a1 = <span class="keyword">new</span> Dog();</span><br><span class="line">Cat c1 = (Cat)a1;</span><br></pre></td></tr></table></figure>

<p>这样会转型失败。</p>
<p><strong>注意</strong>：对于转型，自始至终都是子类对象在做着类型的变化。而cat和dog没有继承关系</p>
<h2 id="4-面向对象-多态-类型判断-instanceof"><a href="#4-面向对象-多态-类型判断-instanceof" class="headerlink" title="4 面向对象-多态-类型判断-instanceof"></a>4 面向对象-多态-类型判断-instanceof</h2><p>instanceof 用于判断对象的具体类型。只能用于引用数据类型判断。</p>
<p>通常在向下转型前用于健壮性的判断</p>
<h2 id="5-面向对象-多态-成员变量"><a href="#5-面向对象-多态-成员变量" class="headerlink" title="5 面向对象-多态-成员变量"></a>5 面向对象-多态-成员变量</h2><p>1.成员变量</p>
<p>​    编译时：参考的是引用型变量所属的类中是否有调用的成员变量，有，编译通过，没有，编译失败</p>
<p>​    运行时：参考的是引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量</p>
<p>​    简单说：编译和运行都参考等号左边的类中是否存在需要的成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuoTaiDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">		System.out.print(f.num);<span class="comment">//此时会编译失败，因为Fu类中不存在num这个成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-面向对象-多态-成员函数（非静态）"><a href="#6-面向对象-多态-成员函数（非静态）" class="headerlink" title="6 面向对象-多态-成员函数（非静态）"></a>6 面向对象-多态-成员函数（非静态）</h2><p>图解：</p>
<p>主函数进栈，然后Fu类加载，接着Zi类加载。堆中创建Zi对象，先生成地址，没有变量，无需初始化，将地址赋给f。调用show()方法，show进栈，f的地址指向Zi对象，先在Zi类中寻找show方法，若Zi类中没有，则在Fu类中寻找。</p>
<p>编译时：参考的是引用型变量所属的类中是否有调用的成员函数，有，编译通过，没有，编译失败</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：编译看左边，运行看右边。</p>
<h2 id="7-面向对象-多态-静态函数"><a href="#7-面向对象-多态-静态函数" class="headerlink" title="7 面向对象-多态-静态函数"></a>7 面向对象-多态-静态函数</h2><p>与上述不同，加载时，两个类中的静态show在静态区，调用直接和类绑定，与对象无关。所以f.show（）；，一看f是属于Fu类吗，就直接调用Fu的show。</p>
<p>编译时：参考的是引用型变量所属的类中是否有调用的静态方法，有，编译通过，没有，编译失败</p>
<p>运行时：参考的是引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：编译和运行都参考左边</p>
<p>其实对于静态方法，是不需要对象的，直接用类名调用即可。</p>
<h2 id="8-面向对象-内部类-概述"><a href="#8-面向对象-内部类-概述" class="headerlink" title="8 面向对象-内部类-概述"></a>8 面向对象-内部类-概述</h2><p>将一个类定义在另一个类的里面，对里面那个类就称为内部类（内置类、嵌套类）。</p>
<p>内部类生成文件的名字为：外部类$内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.内部类可以直接访问外部类中的成员</p>
<p>2.外部类要访问内部类，必须建立内部类的对象</p>
<p>一般用于类的设计</p>
<p>分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述事物的内容</p>
<p>这时就是还有的事物定义成内部类来描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">		System.out.print(<span class="string">"aaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="9-面向对象-内部类-修饰符"><a href="#9-面向对象-内部类-修饰符" class="headerlink" title="9 面向对象-内部类-修饰符"></a>9 面向对象-内部类-修饰符</h2><p>直接访问外部类中的内部类的成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br><span class="line">in.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，相当于一个外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in =<span class="keyword">new</span> Outer.Inner();</span><br><span class="line">in.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，成员是静态的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = Outer.Inner.show();</span><br></pre></td></tr></table></figure>

<p>如果内部类中定义了静态成员，该内部类也必须是静态。</p>
<h2 id="10-面向对象-内部类-细节"><a href="#10-面向对象-内部类-细节" class="headerlink" title="10 面向对象-内部类-细节"></a>10 面向对象-内部类-细节</h2><p>为什么内部类能直接访问外部类中成员呢？</p>
<p>那是因为内部类持有了外部类的引用。外部类名.this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">            System.out.print(<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果是<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="11-面向对象-内部类-局部内部类"><a href="#11-面向对象-内部类-局部内部类" class="headerlink" title="11 面向对象-内部类-局部内部类"></a>11 面向对象-内部类-局部内部类</h2><p>内部类可以存放在局部位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            	System.out.print(num);</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">答案：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p>内部类在局部位置上只能访问局部中被final修饰的局部变量。</p>
<h2 id="12-面向对象-匿名内部类-概述"><a href="#12-面向对象-匿名内部类-概述" class="headerlink" title="12 面向对象-匿名内部类-概述"></a>12 面向对象-匿名内部类-概述</h2><p>匿名内部类，就是内部类的简写格式</p>
<p><strong>必须有前提</strong></p>
<p>内部类必须继承或者实现一个外部类或者接口</p>
<p>匿名内部类：其实就是一个匿名子类对象。</p>
<p>格式：new 父类or接口名(){子类内容}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Demo()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function">abtract <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        out.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h2 id="13-面向对象-匿名内部类-应用、细节"><a href="#13-面向对象-匿名内部类-应用、细节" class="headerlink" title="13  面向对象-匿名内部类-应用、细节"></a>13  面向对象-匿名内部类-应用、细节</h2><p>通常使用场景之一：</p>
<p>当函数参数是接口类型时，而且接口中的方法不超过三个</p>
<p>可以用匿名内部类作为实际参数进行传递</p>
<p>细节：1.匿名内部类这个子类对象被向上转型了为Object类型，这样就不能再使用子类的特有方法了。</p>
<p>​            2.在静态方法中不能创建匿名内部类。</p>
<h2 id="14-面向对象-对象的初始化过程（总结）"><a href="#14-面向对象-对象的初始化过程（总结）" class="headerlink" title="14 面向对象-对象的初始化过程（总结）"></a>14 面向对象-对象的初始化过程（总结）</h2><p>1.首先产生对象，堆中开辟内存，默认初始化变量。</p>
<p>2.然后先进Zi类的构造函数，根据super();进入Fu类的构造函数，执行语句</p>
<p>3.调用其中的show函数，这个show函数为Zi类中的show函数，因为被覆盖了。</p>
<p>4.开始显示初始化</p>
<p>5.开始构造代码块初始化</p>
<p>6.构造函数具体初始化</p>
<p>7.调用show函数</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象抽象类接口</title>
    <url>/2020/03/21/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="面向对象-抽象类-amp-接口"><a href="#面向对象-抽象类-amp-接口" class="headerlink" title="面向对象-抽象类&amp;接口"></a>面向对象-抽象类&amp;接口</h1><h2 id="1-抽象类概述-amp-特点"><a href="#1-抽象类概述-amp-特点" class="headerlink" title="1 抽象类概述&amp;特点"></a>1 抽象类概述&amp;特点</h2><p>抽象：笼统、模糊</p>
<p>当一个类描述一个事物时，没有足够的信息描述时，就叫抽象类。</p>
<p>比如狗和狼都会吼叫，他们提取出来都是犬科，犬科也有吼叫，但是吼叫内容不一样，所以就是有着相同的函数声明，但内容不同，这样就出现了抽象的概念。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> 吼叫();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 狗 <span class="keyword">extends</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 吼叫()&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 狼 <span class="keyword">extends</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 吼叫()&#123;</span><br><span class="line">        System.out.println(<span class="string">"嗷嗷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>特点：</p>
<p>1.方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰</p>
<p>​    抽象方法必须定义在抽象类中，该类必须也被关键字修饰</p>
<p>2.抽象类不可以被实例化，即不能被new创建对象。因为调用抽象方法没有意义。</p>
<p>3.抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化</p>
<p>​    否则这个子类还是抽象类。</p>
<h2 id="2-面向对象-抽象类-细节"><a href="#2-面向对象-抽象类-细节" class="headerlink" title="2 面向对象-抽象类-细节"></a>2 面向对象-抽象类-细节</h2><p>1)抽象类中有构造函数吗？</p>
<p>有，用于给子类对象进行初始化</p>
<p>2)抽象类可以不定义抽象方法吗？</p>
<p>可以的。但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类</p>
<p>通常这个类中的方法有方法体，但是没有内容</p>
<p>3)抽象关键字不可以和哪些关键字共存？</p>
<p>private 抽象方法需要被覆盖，私有了子类就无法访问就无法覆盖。</p>
<p>static 成员变静态，不需要对象，抽象方法没有方法体，运行没有意义，</p>
<p>final 抽象需要覆盖，而final不让覆盖</p>
<p>4)抽象类和一般类的异同点</p>
<p>相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员</p>
<p>不同点：</p>
<p>1.一般类有足够的信息描述事物，抽象类描述事物的信息有可能不足。</p>
<p>2.一般类中不能定义抽象方法，只能定义非抽象方法，而抽象类中可以定义抽象方法金和非抽象方法。</p>
<p>3.一般类可以被实例化，抽象类不可被实例化</p>
<p>5)抽象类一定是个父类吗？</p>
<p>是的，因为需要子类覆盖其方法后才可以对子类实例化。</p>
<h2 id="3-面向对象-接口-定义interface、实现implements"><a href="#3-面向对象-接口-定义interface、实现implements" class="headerlink" title="3 面向对象-接口-定义interface、实现implements"></a>3 面向对象-接口-定义interface、实现implements</h2><p>当一种抽象类中的<strong>方法都是抽象</strong>的时候，这是可以将该抽象类用另一种形式定义和表示，就是接口，interface</p>
<p>定义接口使用的关键字不是class，是interface,但编译出来的文件后缀名仍是class。</p>
<p>对于接口当中常见的成员，而且这些成员都有固定的修饰符</p>
<p>1.全局常量：public static final</p>
<p>2.抽象方法；public abstract</p>
<p>由此得出结论：<strong>接口中的成员都是公共的权限即权限都是最大的</strong>。</p>
<p>因为接口中的成员修饰符是固定的，所以可以省略前面的修饰符，编译器会自动加上。例如abstract因为接口中的方法必是抽象方法，所有可以省略abstract。</p>
<p>虽说如此，但修饰符还是要带上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">4</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<p><strong>类与类之间是继承关系，类与接口之间是实现关系</strong></p>
<p>接口<strong>不可以实例化</strong></p>
<p>只能由实现了接口的子类并<strong>覆盖了接口中所有的抽象方法</strong>后，该子类才可以实例化</p>
<p>否则这个子类就是一个抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoImp1</span> <span class="keyword">implements</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DemoImp1 d = <span class="keyword">new</span> DemoImp1();</span><br><span class="line">        System.out.println(d.NUM);</span><br><span class="line">        System.out.println(Demo.NUM);</span><br><span class="line">        System.out.println(DemoImp1.NUM);<span class="comment">//这三种调用皆可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-接口-多实现"><a href="#4-面向对象-接口-多实现" class="headerlink" title="4 面向对象-接口-多实现"></a>4 面向对象-接口-多实现</h2><p>在java中不直接支持多继承，因为会出现调用的不确定性</p>
<p>所以java将多继承机制进行改良，在java中变成了多实现</p>
<p>一个类可以实现多接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-面向对象-接口-细节"><a href="#5-面向对象-接口-细节" class="headerlink" title="5 面向对象-接口-细节"></a>5 面向对象-接口-细节</h2><p>一个类继承另一个类的同时，还可以实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Q</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">Z</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口与接口之间是继承关系，而且接口可以多继承，原理在于是否存在方法体，是否存在不确定性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ZZ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">QQ</span> <span class="keyword">extends</span> <span class="title">AA</span>, <span class="title">ZZ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">QQ</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-面向对象-接口-特点"><a href="#6-面向对象-接口-特点" class="headerlink" title="6 面向对象-接口-特点"></a>6 面向对象-接口-特点</h2><p>接口是对外暴露的规则</p>
<p>接口是程序的功能扩展</p>
<p>接口的出现降低耦合性</p>
<p>接口可以用来多实现</p>
<p>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</p>
<p>接口与接口之间可以有继承关系</p>
<h2 id="7-面向对象-接口-接口和抽象类的区别"><a href="#7-面向对象-接口-接口和抽象类的区别" class="headerlink" title="7 面向对象-接口-接口和抽象类的区别"></a>7 面向对象-接口-接口和抽象类的区别</h2><p>抽象类和接口的异同点</p>
<p>相同点：</p>
<p>都是不断向上抽取而来的</p>
<p>不同点：</p>
<p>1.抽象类需要被继承，而且只能单继承</p>
<p>   接口需要被实现，而且可以多实现</p>
<p>2.抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法</p>
<p>   接口中只能定义抽象方法，必须有子类去实现</p>
<p>3.抽象类的继承是is a 关系，所属关系，在定义该体系的基本共性内容</p>
<p>   接口的实现时like a关系，像关系，在定义体系额外功能</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象4</title>
    <url>/2020/03/20/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14/</url>
    <content><![CDATA[<h1 id="面向对象4"><a href="#面向对象4" class="headerlink" title="面向对象4"></a>面向对象4</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h2 id="1-面向对象-继承-概述"><a href="#1-面向对象-继承-概述" class="headerlink" title="1 面向对象-继承-概述"></a>1 面向对象-继承-概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span>/*继承*/ <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">"..."</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        s.name = <span class="string">"aaa"</span>;</span><br><span class="line">        s.age = <span class="number">22</span>;</span><br><span class="line">        s.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：aaa…22</p>
<a id="more"></a>

<p>上述代码中，Person是Student的父类，Student继承了Person中的name和age。</p>
<p>继承的好处</p>
<p>1.提高代码的复用性</p>
<p>2.让类与类之间产生了关系，给第三个特征多态提供了前提。</p>
<h2 id="2-面向对象-继承-单继承与多重继承"><a href="#2-面向对象-继承-单继承与多重继承" class="headerlink" title="2 面向对象-继承-单继承与多重继承"></a>2 面向对象-继承-单继承与多重继承</h2><p>java中支持单继承，不直接支持多继承，但对c++中的多继承机制进行改良</p>
<p>单继承：一个子类只能有一个直接父类</p>
<p>多继承：一个子类可以有多个直接父类（java中不允许，进行改良）。</p>
<p>​               不直接支持，是因为若父类中有相同的成员，会产生调用的不确定性。</p>
<p>​               在java中是通过“多实现”的方式来体现。</p>
<p>java支持多层（多重）继承</p>
<p>即C继承B，B继承A。</p>
<p>就会出现继承体系</p>
<p>当要使用继承体系时</p>
<p>1.查看该体系中的顶层类，了解该体系的基本功能</p>
<p>2.创建体系中的最子类对象，完成功能的使用</p>
<h2 id="3-面向对象-继承-定义继承"><a href="#3-面向对象-继承-定义继承" class="headerlink" title="3 面向对象-继承-定义继承"></a>3 面向对象-继承-定义继承</h2><p>什么时候定义继承</p>
<p>当类与类之间存在着所属关系的时候，就定义继承。</p>
<p>如xxx是yyy中的一种，则xxx extends yyy。</p>
<p>若A类有a方法和b方法，B类有a方法和c方法，即使B类有a方法，但是A类中没有c方法，所有这两个类不能构成继承关系。</p>
<h2 id="4-面向对象-继承-子父类中成员变量的特点"><a href="#4-面向对象-继承-子父类中成员变量的特点" class="headerlink" title="4 面向对象-继承-子父类中成员变量的特点"></a>4 面向对象-继承-子父类中成员变量的特点</h2><p>当本类的成员和局部变量同名用this区分</p>
<p>当子父类中的成员变量同名用<strong>super</strong>区分父类</p>
<p>this和super的用法很相似。</p>
<p>this代表一个本类对象的引用</p>
<p>super代表一个父类空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.num + <span class="string">"..."</span> + <span class="keyword">super</span>.num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若调用show()，结果为4…5。</p>
<h2 id="5-面向对象-继承-子父类中成员变量的内存图解"><a href="#5-面向对象-继承-子父类中成员变量的内存图解" class="headerlink" title="5 面向对象-继承-子父类中成员变量的内存图解"></a>5 面向对象-继承-子父类中成员变量的内存图解</h2><p>主函数先进栈，然后先在方法区加载一个父类空间，其次加载子类空间。之后在堆内存中开辟空间，产生地址，创建对象，<strong>然后在该堆空间中，分别开辟空间存储子类和父类变量</strong>，然后进行初始化。然后将地址给z。然后进行show方法，进栈，将地址赋给this指向堆内存。父类成员变量已经随着子类建立已经存储在子类空间当中。打印super.num时，就直接找到那个空间的父类成员变量。</p>
<p>一般开发时，同名这种情况不多见，面试的时候比较常见。</p>
<p><strong>子类不能直接访问父类当中的私有内容</strong></p>
<h2 id="6-面向对象-继承-子父类中成员函数的特点-覆盖"><a href="#6-面向对象-继承-子父类中成员函数的特点-覆盖" class="headerlink" title="6 面向对象-继承-子父类中成员函数的特点-覆盖"></a>6 面向对象-继承-子父类中成员函数的特点-覆盖</h2><p>当子父类中出现成员函数一模一样的情况，会运行子类的函数</p>
<p>这种现象，称为<strong>覆盖操作</strong>，这是函数在子父类中的特性。</p>
<p>函数两个特性（只有函数有）：</p>
<p>1.重载，同一个类中</p>
<p>2.覆盖，子类中，覆盖也称为重写，覆写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"fu run"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"zi run"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：Zi show run。</p>
<p><strong>覆盖注意事项</strong>：</p>
<p>1.子类方法覆盖父类方法时，子类权限必须大于等于父类的权限，才可以引发覆盖。</p>
<p> 如果父类是权限为private，则就不称之为覆盖，因为父类就不能访问，故称不上覆盖。</p>
<p>2.静态只能覆盖静态，或被静态覆盖。</p>
<h2 id="7-面向对象-继承-子父类中成员函数的特点-覆盖的使用场景"><a href="#7-面向对象-继承-子父类中成员函数的特点-覆盖的使用场景" class="headerlink" title="7 面向对象-继承-子父类中成员函数的特点-覆盖的使用场景"></a>7 面向对象-继承-子父类中成员函数的特点-覆盖的使用场景</h2><p>什么时候使用覆盖操作</p>
<p>当对一个类进行子类的扩展时，子类需要保留父类的功能声明，</p>
<p>但是要定义子类中该功能的特有内容时，就使用覆盖操作完成。</p>
<h2 id="8-面向对象-继承-子父类中的构造函数-子类的实例化过程、细节"><a href="#8-面向对象-继承-子父类中的构造函数-子类的实例化过程、细节" class="headerlink" title="8 面向对象-继承-子父类中的构造函数-子类的实例化过程、细节"></a>8 面向对象-继承-子父类中的构造函数-子类的实例化过程、细节</h2><p>在子类构造对象时，发现访问子类构造函数时，父类也运行了。</p>
<p>原因是：在子类的构造函数中第一行有一个默认的隐式语句。super(){ };这会让父类中构造函数也运行。</p>
<p>super();//调用的就是父类中的空参数的构造函数。如果父类没有空参，则会编译失败，若父类是带参的，即Fu(int x)，那么就写成super(4);类型即可。</p>
<p>子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数。</p>
<p>为什么子类实例化的时候要访问父类中的构造函数？</p>
<p>因为子类继承了父类，获取到了父类中内容（属性），所以在使用父类内容之前，</p>
<p>要先看父类是如何对自己的内容进行初始化的。</p>
<p>所以子类在构造对象时，必须访问父类中的构造函数</p>
<p>为了完成这个必须的动作，就在子类的构造函数中加入了super()；语句。</p>
<p>如果父类没有定义空参数构造函数，那么子类的构造函数必须用super明确调用父类中的一个构造函数。</p>
<p><strong>注意</strong>：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成。</p>
<p>同时子类构造函数中如果使用this调用了本类构造函数时，super就没有了，因为super和this都只能定义在第一行，所以只能有一个。</p>
<p>但是可以保证的是，若使用的子类的构造函数中有this，那么创建对象时会使用子类中其他的构造函数访问父类的构造函数。</p>
<p>Java中有若干对象，他们有个最顶层的类，是Object，创建的任何对象都是Object的子类。class Demo extends Object，一般extends Object不写。</p>
<h2 id="9-面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解"><a href="#9-面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解" class="headerlink" title="9 面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解"></a>9 面向对象-继承-子父类中的构造函数-子类的实例化过程-内存图解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    Fu()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fu show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">8</span>;</span><br><span class="line">    Zi()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"zi show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：zi show…0<br>               zi show…8</p>
<p>先主函数进栈，出现z，要创建对象，加载Zi类，但是Zi类有继承Fu类，所以先加载Fu类，Fu就进内存中的方法区，然后加载Zi类。之后在堆中创建new Zi对象，赋予地址，对变量进行默认初始化，num=0。默认初始化结束后，Zi的构造函数进栈，里面有个super函数，Fu类构造函数进栈，然后运行show()函数，这里注意，这里的函数全写为this.show();所以先从this所指的对象中开始找show();发现在new Zi中有show()函数，所以就调用子类的show()函数。此时Fu类的构造结束，弹栈。然后才将8赋给num值，即显示初始化。之后Zi类构造函数弹栈。然后地址赋给z。</p>
<p><strong>总结</strong></p>
<p>一个对象实例化过程</p>
<p>Person p=new Person();</p>
<p>1.JVM会读取指定的路径下的Person.class 文件，并加载进内存</p>
<p>​    并会先加载Person的父类（如果有直接父类的情况下）</p>
<p>2.在堆内存中开辟空间，分配地址</p>
<p>3.并在对象空间中，对对象中的属性进行默认初始化</p>
<p>4.调用对应的构造函数进行初始化</p>
<p>5.在构造函数中，第一行会先到调用父类中构造函数中进行初始化</p>
<p><strong>6.父类初始化完毕后，再对子类的属性进行显示初始化。//这一块是分水岭。</strong></p>
<p>7.再进行自类构造函数的特定初始化</p>
<p>8.初始化完毕后，将地址值赋给引用变量。</p>
<h2 id="10-面向对象-final关键字"><a href="#10-面向对象-final关键字" class="headerlink" title="10 面向对象-final关键字"></a>10 面向对象-final关键字</h2><p>1.Final可以修饰类，方法，变量</p>
<p>2.Final修饰的类不可以被继承</p>
<p>3.Final修饰的方法不可以被覆盖</p>
<p>4.Final修饰的变量是一个常量。只能被赋值一次</p>
<p>为什么要用final修饰变量</p>
<p>其实在程序中，如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差</p>
<p>所以它该数据起个名称，而且这个变量名称的值不能变化，所以加上final固定。</p>
<p>写法规范：常见所有字母都大写，多个单词中间用下划线“_”连接，MY_NUM。</p>
<p>Final固定的是显示初始化值，不是默认初始化值。</p>
<p>public static为全局的意思</p>
<p>public static final double PI=3.14 全局常量。</p>
<p>5.内部类只能访问被final修饰的局部变量</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象3</title>
    <url>/2020/03/20/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13/</url>
    <content><![CDATA[<h1 id="面向对象3"><a href="#面向对象3" class="headerlink" title="面向对象3"></a>面向对象3</h1><h2 id="1-数组对象建立、数组工具类中静态的使用"><a href="#1-数组对象建立、数组工具类中静态的使用" class="headerlink" title="1 数组对象建立、数组工具类中静态的使用"></a>1 数组对象建立、数组工具类中静态的使用</h2><p>可以建立一个数组对象，将对数组的操作方法定义在类中。用到了面向对象的方法。</p>
<h2 id="2-文档注释"><a href="#2-文档注释" class="headerlink" title="2 文档注释"></a>2 文档注释</h2><p>Javadoc.exe可以提取文档注释，只能解析/** */的内容</p>
<p>提取操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -d. -author -version xxx.java</span><br></pre></td></tr></table></figure>

<p>-d指输出文件的目标目录， . 指在当前目录下， -***，指需要提取的目录。</p>
<p>要将文档用该程序提取注释，则需要将类公有化，否则无法执行</p>
<h2 id="3-面向对象-单例设计-概念-amp-体现"><a href="#3-面向对象-单例设计-概念-amp-体现" class="headerlink" title="3  面向对象-单例设计-概念&amp;体现"></a>3  面向对象-单例设计-概念&amp;体现</h2><p>设计模式：对问题行之有效的解决方式，其实它是一种思想。</p>
<p>1.单例设计模式</p>
<p>解决的问题：可以保证一个类在内存中的对象唯一性。</p>
 <a id="more"></a>

<p>比如对于多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性。</p>
<p>如何保证对象的唯一性：</p>
<p>1.不允许其他程序用new创建该类对象。这样可以避免产生更多对象</p>
<p>2.在该类中创建一个本类实例。</p>
<p>3.对外提供方法让其他程序可以获取该对象。</p>
<p>步骤：</p>
<p>1.私有化该类的构造函数</p>
<p>2.通过new在本类中创建一个本类并私有的对象</p>
<p>3.定义一个公有的方法将创建的对象返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//设置这个函数是为了可控因为可以在里面设置条件</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span>()</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Sinlge ss = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-单例设计-内存图解"><a href="#4-面向对象-单例设计-内存图解" class="headerlink" title="4 面向对象-单例设计-内存图解"></a>4 面向对象-单例设计-内存图解</h2><p>略</p>
<h2 id="5-面向对象-单例设计-饿汉式和懒汉式"><a href="#5-面向对象-单例设计-饿汉式和懒汉式" class="headerlink" title="5 面向对象-单例设计-饿汉式和懒汉式"></a>5 面向对象-单例设计-饿汉式和懒汉式</h2><p>饿汉式：类一加载，对象就已经存在，即上述3中的代码就是饿汉式</p>
<p>懒汉式：类加载进来，没有对象，只有调用了getInstance()方法时，才会创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) s = <span class="keyword">new</span> Single();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正式开发中饿汉式用的多，因为懒汉式后期被另外一种技术比如多线程技术操作时，可能会保证不了唯一性。</p>
<p><strong>面试几乎涉及懒汉式</strong>，里面涉及的知识点比较多。</p>
<p><strong>单例模式作为重点掌握</strong></p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象2</title>
    <url>/2020/03/19/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/</url>
    <content><![CDATA[<h1 id="面向对象2"><a href="#面向对象2" class="headerlink" title="面向对象2"></a>面向对象2</h1><h2 id="1-面向对象-构造函数-概述、默认构造函数"><a href="#1-面向对象-构造函数-概述、默认构造函数" class="headerlink" title="1 面向对象-构造函数-概述、默认构造函数"></a>1 面向对象-构造函数-概述、默认构造函数</h2><p>构造函数：构建创造对象时调用的函数。</p>
<p>作用：可以给对象进行初始化。</p>
<p>特点：</p>
<p>1.函数名与类名相同。</p>
<p>2.不用定义返回值。</p>
<p>3.没有具体的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	Person()&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象都必须要通过构造函数初始化。</p>
<a id="more"></a>

<p><strong>默认构造函数</strong></p>
<p>一个类中如果没有定义过构造函数，那么该类中会有一个默认的空参数构造函数。</p>
<p>如果在类中定义了指定的构造函数，那么类中的默认构造函数就没有了。</p>
<h2 id="2-面向对象-构造函数-构造函数和一般函数的区别"><a href="#2-面向对象-构造函数-构造函数和一般函数的区别" class="headerlink" title="2 面向对象-构造函数-构造函数和一般函数的区别"></a>2 面向对象-构造函数-构造函数和一般函数的区别</h2><p>一般函数和构造函数的区别</p>
<p>构造函数：对象创建时，就会调用与之对应的构造函数，对对象进行初始化</p>
<p>一般函数：对象创建后，需要函数功能时才调用。</p>
<p>构造函数：对象创建时，会调用只调用一次</p>
<p>一般函数：对象创建后，可以被调用多次。</p>
<h2 id="3-面向对象-构造函数-重载"><a href="#3-面向对象-构造函数-重载" class="headerlink" title="3 面向对象-构造函数-重载"></a>3 面向对象-构造函数-重载</h2><p>构造函数重载与一般函数重载相同：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。</p>
<p><strong>注意</strong>：小括号中，参数个数和参数类型相同，但顺序不同也可以重载，因为java是强类型语言，是十分严谨的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    Person(<span class="keyword">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">     Person(String n,<span class="keyword">int</span> a)&#123;</span><br><span class="line">		age = a;</span><br><span class="line">        name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-面向对象-构造函数-内存图解"><a href="#4-面向对象-构造函数-内存图解" class="headerlink" title="4 面向对象-构造函数-内存图解"></a>4 面向对象-构造函数-内存图解</h2><p>与之前不一样的是，中间多了一步构造函数初始化。图解略</p>
<h2 id="5-面向对象-构造函数-细节"><a href="#5-面向对象-构造函数-细节" class="headerlink" title="5 面向对象-构造函数-细节"></a>5 面向对象-构造函数-细节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.上述二者函数功能一样，但用法不同，所以第二种需要存在。</p>
<p>2.一般函数中不能调用构造函数，构造函数可以调用一般函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.上述这是可以的，虽然构造函数前面不能加返回值，但这图中，它不当作构造函数，当作是一般函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"aaa"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">    Person(String n)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.上述定义类的情况下， 在主函数中用下列语句创建对象</p>
<p>Person p = new Person();</p>
<p>编译是不行的。因为这种情况下，没有默认构造函数即空参构造函数，第二个Person函数是构造函数，故就没有默认构造函数，编译不成功。</p>
<p>5.构造函数中是可以有return的，但不多见。</p>
<h2 id="6-面向对象-this关键字-使用场景-amp-this原理"><a href="#6-面向对象-this关键字-使用场景-amp-this原理" class="headerlink" title="6 面向对象-this关键字-使用场景&amp;this原理"></a>6 面向对象-this关键字-使用场景&amp;this原理</h2><p>场景1：当成员变量和局部变量重名，可以用this关键字区分。</p>
<p>this ：代表对象，代表当前对象</p>
<p>​       this就是所在函数所属对象的引用。</p>
<p>​       <strong>简单说，哪个对象调用了this所在的函数，this就代表哪个对象，即拿到那个对象的地址。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(String n, <span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">		<span class="keyword">this</span>.age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入this关键字后，之前的内存图解重新解释：运行主函数，在栈里面划出内存给主函数，构建一个p对象，堆中也出现一块内存给这个对象，然后给这个空间赋予地址，内存存入两个变量，并对其进行默认初始化。然后调用构造函数，因此在栈中又划出内存给构造函数，然后出现this关键字，将堆中的内存地址与this绑定，这样就知道之后的变量赋值是赋给哪个内存的对应变量。然后将旺财赋给对应内存当中的name，赋值结束弹栈，地址赋给p。运行下一个指令，p.speak()。在栈内存中给出一块内存给speak函数，同样的在此中将调用的对象的相应地址与speak中的this绑定，输出语句，之后弹栈。</p>
<p><strong>这里注意</strong>：其实之前的写这些时都把this省去了，因为成员变量和局部变量没有重复。其实真正的写法是this.name，this.age。</p>
<p>场景2：一个类当中，所有的成员想要运行，就必须有对象调用。</p>
<p>想在构造函数中调用构造函数，也可以使用this，用this代替构造函数名，形式：this(…,…,…) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(String n)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(String n, <span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">this</span>(n);</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：凡是调用构造函数，this只能定义在构造函数的第一行，因为初始化动作要先执行。</p>
<h2 id="7-面向对象-this关键字-应用"><a href="#7-面向对象-this关键字-应用" class="headerlink" title="7 面向对象-this关键字-应用"></a>7 面向对象-this关键字-应用</h2><p>判断是否为同龄人</p>
<p>思路：对象是人，所以函数的参量是人。参量的个数可以是2，但是可以认为比较这个功能可以是人本身具备的，可以理解为一个人用这个功能来与另外一个人进行年龄的比较，只要调用即可，故这个函数的参量个数是一个。在函数里面，p1调用了这个函数，故this就代表着p1，p代表着p2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    Person(<span class="keyword">int</span> a)</span><br><span class="line">        <span class="keyword">this</span>.age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == p.age; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-面向对象-static关键字-数据共享、特点"><a href="#8-面向对象-static关键字-数据共享、特点" class="headerlink" title="8 面向对象-static关键字-数据共享、特点"></a>8 面向对象-static关键字-数据共享、特点</h2><p>static特点</p>
<p>1.static是一个修饰符，用于修饰成员</p>
<p>2.static修饰的成员被所有的对象共享</p>
<p>3.static优先于对象存在。因为static的成员随着类的加载就已经存在了</p>
<p>4.static修饰的成员多了一种调用方式，即可以直接被类名所调用。</p>
<p>调用方式：类名.静态成员</p>
<p>5.static修饰的数据是共享数据，对象中的存储的是特有数据</p>
<h2 id="9-面向对象-static关键字-成员变量和静态变量的区别"><a href="#9-面向对象-static关键字-成员变量和静态变量的区别" class="headerlink" title="9 面向对象-static关键字-成员变量和静态变量的区别"></a>9 面向对象-static关键字-成员变量和静态变量的区别</h2><p>成员变量和静态变量的区别</p>
<p>1.两个变量的生命周期不一样。</p>
<p>成员变量随着对象的创建而存在，随着对象的被回收而释放</p>
<p>静态变量随着类的加载而存在，随着类的消失而消失</p>
<p>2.调用方式不同</p>
<p>成员变量只能被对象调用</p>
<p>静态变量可以被对象调用，还可以被类名调用。一般建议用类名调用。</p>
<p>3.别名不同</p>
<p>成员变量也称为实例变量</p>
<p>静态变量也称为类变量</p>
<p>4.数据的存储位置不同</p>
<p>成员变量数据存储在堆内存的对象中，所有也叫对象的特有数据</p>
<p>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据</p>
<h2 id="10-面向对象-static关键字-注意事项"><a href="#10-面向对象-static关键字-注意事项" class="headerlink" title="10  面向对象-static关键字-注意事项"></a>10  面向对象-static关键字-注意事项</h2><p>1.静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）</p>
<p>2.静态方法中不可以使用this或super等关键字</p>
<p>3.主函数是静态的</p>
<h2 id="11-面向对象-static关键字-main函数解析"><a href="#11-面向对象-static关键字-main函数解析" class="headerlink" title="11  面向对象-static关键字-main函数解析"></a>11  面向对象-static关键字-main函数解析</h2><p>public static void main(String[ ] args)</p>
<p>主函数特殊之处：</p>
<p>1.格式是固定的，上述每个单词都不能换成其他的。</p>
<p>2.被JVM所识别和调用</p>
<p>public：因为权限必须是最大的。</p>
<p>static：虚拟机调用主函数的时候不需要对象，直接用主函数所属类名调用即可。</p>
<p>void：主函数没有具体的返回值。</p>
<p>main：函数名，不是关键字只是一个JVM识别的固定的名字</p>
<p>String[ ] args：这是主函数的参数列表，是一个数组类型的参数，而且元素都是字符串类型。</p>
<p>args可以用其他替代</p>
<h2 id="12-面向对象-static关键字-内存图解"><a href="#12-面向对象-static关键字-内存图解" class="headerlink" title="12 面向对象-static关键字-内存图解"></a>12 面向对象-static关键字-内存图解</h2><p>先划分一片空间出来给栈、堆、方法区等。当StaticDemo2被执行时，类进内存，开辟空间。在非静态区存储StaticDemo2(){ }，静态区存储Static main()。非静态区都用this来调用对象。然后在栈空间开辟一个main函数空间。运行第一句话，Peson类开始加载，它就开始找在classpath下找有没有Person.class文件，找到后加载进内存，静态类进去静态区，其他类进去非静态区。然后在内存中寻找method方法，因为是静态，所以到静态区找。找到后在栈中开辟空间给method。然后开始执行method方法，执行结束后，弹栈。执行第二句话，开始创建对象，在堆中开辟空间，然后这句话的执行与前述相同。执行第三句话，show方法进栈，将地址赋值给this，执行语句，country在静态区找，name和age到对象中找，执行结束弹栈。然后主函数弹栈，之后虚拟机也结束。</p>
<h2 id="13-面向对象-static关键字-什么时候用"><a href="#13-面向对象-static关键字-什么时候用" class="headerlink" title="13  面向对象-static关键字-什么时候用"></a>13  面向对象-static关键字-什么时候用</h2><p>1.静态变量</p>
<p>当分析对象中所具备的成员变量的值都是相同的这时这个成员可以被静态修饰</p>
<p>只要数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。</p>
<p>如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。</p>
<p>2.静态函数</p>
<p>函数是否用静态修饰，就参考一点：该函数功能是否需要访问到对象中的特有数据</p>
<p>简单点说，从源代码看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的。如果不需要，就可以将该功能定义成静态的。</p>
<p>当然，也可以定义成非静态，但是非静态需要被对象调用，而仅创建对象调用非静态的，没有访问特有数据的方法，该对象的创建是没有意义的。</p>
<h2 id="14-面向对象-static关键字-静态代码块"><a href="#14-面向对象-static关键字-静态代码块" class="headerlink" title="14 面向对象-static关键字-静态代码块"></a>14 面向对象-static关键字-静态代码块</h2><p>静态代码块</p>
<p> static{</p>
<p>}</p>
<p>随着类的加载而执行，而且只执行一次。</p>
<p>作用：用于给类进行初始化。如果没有对象，那么就可以用这种方法进行初始化。</p>
<p>在静态代码块中可以对静态变量进行运算等操作。</p>
<p>它也先于主函数执行。</p>
<h2 id="15-面向对象-static关键字-构造代码块"><a href="#15-面向对象-static关键字-构造代码块" class="headerlink" title="15 面向对象-static关键字-构造代码块"></a>15 面向对象-static关键字-构造代码块</h2><p>构造代码块</p>
<p>{</p>
<p>}</p>
<p>特点：可以给所有对象进行初始化。每次创建对象的时候都会提前调用一次构造代码块</p>
<p>构造函数</p>
<p>是给对应的对象进行针对性的初始化。</p>
<p>面试：静态代码块、构造代码块、构造函数操作执行顺序</p>
<p>静态代码块先执行，然后构造代码块执行，最后构造函数执行。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-面向对象</title>
    <url>/2020/03/18/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-面向对象-概述"><a href="#1-面向对象-概述" class="headerlink" title="1 面向对象-概述"></a>1 面向对象-概述</h2><p>有两个思想，面向过程和面向对象。</p>
<p>面向过程</p>
<p>举例：大象装进冰箱</p>
<p>打开冰箱</p>
<p>存储大象</p>
<p>关闭冰箱</p>
<p>对于面向过程思想，强调的是过程（动作），比如C语言就是面向过程。</p>
 <a id="more"></a>

<p>面向对象</p>
<p>举例：大象装进冰箱</p>
<p>冰箱打开</p>
<p>冰箱存储</p>
<p>冰箱关闭</p>
<p>只要找到冰箱这个实体就能完成后面的动作。</p>
<p>对于面向对象思想，强调的是对象（实体），比如java、C++、C#就是面向对象。</p>
<p>特点：</p>
<p>1.面向对象就是一种常见的思想，符合人们的思考习惯。</p>
<p>2.面向对象的出现，将复杂的问题简单化。</p>
<p>3.面向对象的出现，让曾经在过程中的执行者，变成了对象中的指挥者。</p>
<h2 id="2-面向对象-举例"><a href="#2-面向对象-举例" class="headerlink" title="2 面向对象-举例"></a>2 面向对象-举例</h2><p>Java中万物皆可作为对象。（这是一种境界，面试的时候不要说）</p>
<p>有对象用对象，没对象造对象，不断的去维护各个对象之间的关系。</p>
<p><strong>使用面向对象的三个特征：封装、继承、多态</strong></p>
<p>例子：人开门</p>
<p>对象：人和门，名词提炼法找对象</p>
<p>动作/功能赋予：开这个是门的功能，哪个对象最清楚动作就赋予给哪个对象</p>
<h2 id="3-类与对象的关系"><a href="#3-类与对象的关系" class="headerlink" title="3 类与对象的关系"></a>3 类与对象的关系</h2><p>类</p>
<p>Java通过类的形式来对现实生活中的事物进行描述。</p>
<p>对于事物描述通常只关注两方面：属性，行为。</p>
<p>只要明确该事物的属性和行为并定义在类中即可</p>
<p>对象</p>
<p>其实就是该类事物实实在在的个体。</p>
<p>类与对象之间的关系</p>
<p>类:事物的描述</p>
<p>对象：类的实例。在java中通过new来创建的</p>
<h3 id="4-类与对象的体现"><a href="#4-类与对象的体现" class="headerlink" title="4 类与对象的体现"></a>4 类与对象的体现</h3><p>描述小汽车</p>
<p>分析：</p>
<p>1.属性</p>
<p>轮胎数</p>
<p>颜色</p>
<p>2.行为</p>
<p>运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Car c = <span class="keyword">new</span> Car();</span><br><span class="line">		c.num = <span class="number">4</span>;</span><br><span class="line">		c.color = <span class="string">"red"</span>;</span><br><span class="line">		c.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义类其实就是在定义类中的成员</p>
<p>成员:成员变量、成员函数。前者对应变量，后者对应行为。</p>
<p>成员变量定义在类中，其作用范围是最大的。</p>
<p>Car类中没有定义主函数，它专门用来描述某一事物，不需要独立运行</p>
<p>如果被用到才需要独立运行。当然，也可以让其独立运行，在类中定义主函数即可。</p>
<p>要使用对象中的内容，可以通过 <strong>对象.成员</strong> 的形式完成调用。</p>
<h2 id="5-面向对象-对象的内存体现"><a href="#5-面向对象-对象的内存体现" class="headerlink" title="5 面向对象-对象的内存体现"></a><strong>5 面向对象-对象的内存体现</strong></h2><p>在主函数中创建car对象内存过程:<br>因为定义的c是局部变量，所以c在栈中会占用内存。然后定义的是对象，故打开堆内存，占用内存并赋予一个地址，在里面定义变量，同时进行默认初始化。接下来给变量赋予数值。找到c，然后根据地址找到堆内存中位置，并赋予数值。<br>一个对象封装着其所对应的数据，比如num、color。</p>
<h2 id="6-面向对象-成员变量和局部变量的区别"><a href="#6-面向对象-成员变量和局部变量的区别" class="headerlink" title="6 面向对象-成员变量和局部变量的区别"></a>6 面向对象-成员变量和局部变量的区别</h2><p>成员变量和局部变量的区别</p>
<p>1.成员变量定义在类中，整个类中都可以访问。</p>
<p>   局部变量定义在函数、语句、局部代码块中，只在所属的区域有效。</p>
<p>2.成员变量存在于堆内存的对象中</p>
<p>   局部变量存在于栈内存的方法中</p>
<p>3.成员变量随着对象的创建而存在，随着对象的消失而消失</p>
<p>   局部变量随着所属区域的执行而存在，随着所属区域的结束而释放</p>
<p>4.成员变量都有默认初始化值</p>
<p>   局部变量没有默认初始化值</p>
<h2 id="7-面向对象-成员变量和局部变量的同名-amp-显示初始化"><a href="#7-面向对象-成员变量和局部变量的同名-amp-显示初始化" class="headerlink" title="7 面向对象-成员变量和局部变量的同名&amp;显示初始化"></a>7 面向对象-成员变量和局部变量的同名&amp;显示初始化</h2><p>如果在类中描述时变量同名，则运行时先在哪个内存中找到这个变量就显示哪个。上述例子就是先打开是栈内存，并找到num。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Car c = <span class="keyword">new</span> Car();</span><br><span class="line">		c.color = <span class="string">"red"</span>;</span><br><span class="line">		c.run();</span><br><span class="line">		System.out.println(c.num + <span class="string">"..."</span> + c.color);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上述打印结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5...red</span><br><span class="line">6...red</span><br></pre></td></tr></table></figure>

<p>显示初始化</p>
<p>可以在类中的描述直接赋值，这与继承有关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(num + <span class="string">"..."</span> + color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-面向对象-类类型参数"><a href="#8-面向对象-类类型参数" class="headerlink" title="8 面向对象-类类型参数"></a>8 面向对象-类类型参数</h2><p> 类类型的变量一定指向对象，要不就是null。</p>
<h2 id="9-面向对象-匿名对象"><a href="#9-面向对象-匿名对象" class="headerlink" title="9 面向对象-匿名对象"></a>9 面向对象-匿名对象</h2><p>匿名对象：</p>
<p>没有名字的对象。</p>
<p>new Car();//匿名对象其实就是定义对象的简写格式。</p>
<p>使用方式：</p>
<p>1.当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。</p>
<p>new Car().run();</p>
<p>2.匿名对象可以作为实际参数进行传递。</p>
<p>show(new Car());</p>
<h2 id="10-基本数据类型和引用数据类型参数传递图解"><a href="#10-基本数据类型和引用数据类型参数传递图解" class="headerlink" title="10 基本数据类型和引用数据类型参数传递图解"></a>10 基本数据类型和引用数据类型参数传递图解</h2><p>基本数据类型参数传递不用涉及到堆，而引用数据类型涉及到堆。</p>
<p>图解略。</p>
<h2 id="11-面向对象-封装-代码实例、思想"><a href="#11-面向对象-封装-代码实例、思想" class="headerlink" title="11 面向对象-封装-代码实例、思想"></a>11 面向对象-封装-代码实例、思想</h2><p>封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
<p>Java中最小的封装体是函数。类，框架等都是封装体。</p>
<p>好处：</p>
<p>将变化隔离</p>
<p>便于使用</p>
<p>提高重用性</p>
<p>提高安全性</p>
<p>封装原则：</p>
<p>将不需要对外提供的内容都隐藏起来</p>
<p>把属性都隐藏，提供公共方法对其访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Person类中的age是私有的，所以在主函数中不能使用直接调用age，只能利用getAge函数来获得。</p>
<p><strong>Private（私有关键字）</strong>:是一个权限修饰符，用于修饰成员。私有的内容只在本类中有效。</p>
<p>常用之一：将成员变量私有化，对外提供对应的set，get。</p>
<p>​                   方法对其进行访问。提高数据访问的安全性。</p>
<p><strong>注意</strong>：私有仅仅是封装的一种体现而已。不私有也能进行封装。</p>
<p>​           私有是封装，但封装不是私有。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-二维数组</title>
    <url>/2020/03/18/JavaSE-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1.定义方式"></a>1.定义方式</h2><p>第一种命名格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[][] arr&#x3D;new int [3][2];</span><br></pre></td></tr></table></figure>

<p>二维数组可以理解为一个大箱子，里面有若干个小箱子。箱子里面又有若干个格子即元素。</p>
<a id="more"></a>

<p>二维数组定义过程如下：</p>
<p>首先在栈内存中开辟临时内存，定义一个arr。arr使得在堆内存中开辟内存来储存arr中的数组（这里数组指的是第一个中括号的数组），并赋予一个地址，进行初始化。因为这时候初始化的东西是引用类型的数据，所以初始化为null。然后继续为数组的第二个中括号开辟内存，也就是底下三个，并赋予各自的地址，初始化，这里初始化的内容是int类型的数，所以为0。然后这三个内存对应的地址填到刚刚的null对应的格子里，这样完成数组定义。</p>
<p>第二种命名格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[] [] arr&#x3D;new int [3][];</span><br></pre></td></tr></table></figure>

<p>这种定义过程与上述类似，只是它是只定义到二维数组，也就是第一个中括号处。如果要进行二维数组中的每一个维数组也就是第二个中括号的定义，则需要再输入定义语句。所以一开始，二维数组里面存的地址为null。</p>
<p>第三种定义方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int[][]arr &#x3D;&#123;&#123;2,3,1&#125;,&#123;2,5,2,1&#125;,&#123;5,7&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是直接输入数字。</p>
<p>打印二维数组的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(arr.length);<span class="comment">//打印二维数组的长度，相当于行数</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>].length);<span class="comment">//打印二维数组中角标为0的一维数组的长度，相当于列数</span></span><br></pre></td></tr></table></figure>

<p>二维数组遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = [<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-数组</title>
    <url>/2020/03/17/JavaSE-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>定义：同一种类型数据的集合。其实数组就是一个容器。<br>好处：可以自动给数组中的元素从0开始编号，方便操作这些元素。<br>格式：元素类型[ ] 数组名=new 元素类型[元素个数或数组长度]<br>数组索引从0开始，这里MySQL数据库索引是从1开始。</p>
<a id="more"></a>

<h2 id="2-内存空间的划分、栈内存、堆内存内存的划分"><a href="#2-内存空间的划分、栈内存、堆内存内存的划分" class="headerlink" title="2 内存空间的划分、栈内存、堆内存内存的划分"></a>2 内存空间的划分、栈内存、堆内存内存的划分</h2><p>1.寄存器：cpu处理</p>
<p>2.本地方法区：所在系统相关。</p>
<p>3.方法区：目前涉及不到</p>
<p>4.栈内存：</p>
<p>存储的都是局部变量</p>
<p>而且变量所属的作用域一旦结束，该变量就自动释放。</p>
<p>5.堆内存：</p>
<p>存储的是数组和对象（其实数组也是对象），凡是new建立的都在堆中。</p>
<p>堆里面存的都是实体。实体就是实实在在存储的个体，用于封装一个或多个数据。</p>
<p>只要看到new，就会在堆里面建立新的空间</p>
<p>特点</p>
<p>1.每一个实体都有一个首地址值</p>
<p>2.堆内存中的每一个变量都有默认初始化值，根据类型不同而不同，整数是0，小数是0.0或者0.0f，boolean是false，char是’\u0000’，字符串String类型是null。</p>
<p>3.释放方式为垃圾回收机制。</p>
<h2 id="3-内存图解（略）"><a href="#3-内存图解（略）" class="headerlink" title="3  内存图解（略）"></a>3  内存图解（略）</h2><h2 id="4-数组常见问题"><a href="#4-数组常见问题" class="headerlink" title="4  数组常见问题"></a>4  数组常见问题</h2><p>ArrayIndexOutOfBoundsException</p>
<p>NullPointerException</p>
<h2 id="5-数组其他定义格式"><a href="#5-数组其他定义格式" class="headerlink" title="5  数组其他定义格式"></a>5  数组其他定义格式</h2><p>格式2：元素类型[ ] 数组名=new 元素类型[ ]{元素，元素，…}；</p>
<p>​       int[ ] arr=new int[ ]{23,13,123,21};需要一个容器，存储已知的具体数据。</p>
<p>格式3：元素类型[ ] 数组名={元素，元素，…}；</p>
<p>​       int[ ] arr={12,21,31,12};</p>
<h2 id="6-常见操作-遍历"><a href="#6-常见操作-遍历" class="headerlink" title="6  常见操作-遍历"></a>6  常见操作-遍历</h2><p>对数组操作最基本的动作是存和取。</p>
<p>​       核心思想：对角标的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++)&#123;<span class="comment">//正向遍历</span></span><br><span class="line">    System.out.println(arr[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = arr.length - <span class="number">1</span>; x &gt;= <span class="number">0</span>; x--)&#123;<span class="comment">//反向遍历</span></span><br><span class="line">    System.out.println(arr[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-常见操作-最值"><a href="#7-常见操作-最值" class="headerlink" title="7  常见操作-最值"></a>7  常见操作-最值</h2><p>获取数组中的最大值</p>
<p>​    思路：</p>
<p>​    1.需要进行比较。并定义变量记录每次比较后较大值</p>
<p>​    2.对数组中的元素进行遍历取出，和变量中记录的元素进行比较。</p>
<p>​       如果遍历到的元素大于变量中记录的元素，就用变量记录住该大的值。</p>
<p>​    3.遍历结果，该变量记录就是最大值。</p>
<p>​    定义的函数中，初始化变量可以是数组中的元素，也可以是0.前者就是比较元素，后者是因为数组中存在角标，角标和数组中的数字是一一对应的，所以也可以用0来初始化，不会担心存在负数的情况。</p>
<p>代码略</p>
<h2 id="8-常见操作-选择排序"><a href="#8-常见操作-选择排序" class="headerlink" title="8 常见操作-选择排序"></a>8 常见操作-选择排序</h2><p>方法：第一轮，比较整个数组即N次，将最小的数放置在第一个位置。第二轮比较N-2次，将第二小的数放置在第二个位置，这样比较N轮完成排序。时间复杂度：O(N2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = arr[i];</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; arr[j])&#123;</span><br><span class="line">                num = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-常见操作-冒泡排序"><a href="#9-常见操作-冒泡排序" class="headerlink" title="9  常见操作-冒泡排序"></a>9  常见操作-冒泡排序</h2><p>方法：先将数组中第一个数和第二数比较，较大的在后面，接着第二个和第三个排序，较大的排在第三个，后面依次类推，直到最后一个，这样最后一个数就是最大的。紧接着用同样的方法将第二大的数排在倒数第二个位置。时间复杂度：O(N2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-查找、折半查找（略）"><a href="#10-查找、折半查找（略）" class="headerlink" title="10 查找、折半查找（略）"></a>10 查找、折半查找（略）</h2><h2 id="11进制转换、查表法"><a href="#11进制转换、查表法" class="headerlink" title="11进制转换、查表法"></a>11进制转换、查表法</h2><p>在计算机中完成10进制到16进制的转换，具体步骤如下：<br>在计算机中，表现形式为二进制，然后开始四个四个与1111进行“与”计算，因为“与”计算可以提取想要的位数。当最底的4位提取完毕后，进行下一步，就将其移4位，进行下一个4位数的提取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0000-0000 0000-0000 0000-0000 0011-1100  60</span><br><span class="line">&amp;0000-0000 0000-0000 0000-0000 0000-1111</span><br><span class="line">-----------------------------------------</span><br><span class="line"> 0000-0000 0000-0000 0000-0000 0000-1100  12即C</span><br><span class="line"> &gt;&gt;&gt;  0000-0000 0000-0000 0000-0000 0011-1100  60&gt;&gt;&gt;4</span><br><span class="line">&amp;0000-0000 0000-0000 0000-0000 0000-1111</span><br><span class="line">-----------------------------------------</span><br><span class="line"> 0000-0000 0000-0000 0000-0000 0000-0011  3</span><br><span class="line"> 最后得到3C</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> pos = arr.length;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num &amp; <span class="number">15</span>;</span><br><span class="line">        arr[--pos] = chs[temp];</span><br><span class="line">        num = num &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; arr.length; i++)&#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化成其他进制类似。</p>
<p>除了自己写之外，在Java中有对应的内置函数来实现，如Integer.toBinaryString(int num);</p>
<p>什么时候使用数组</p>
<p>​    如果数据出现了对应关系，而且对应关系的一方是有序的数字编号。并作为角标使用</p>
<p>​    这时就必须要想到数组的使用</p>
<p>​    就可以将这些数据存储在数组中</p>
<p>​    根据运算的结果作为角标直接去查数组中对应的元素即可。</p>
<p>​    这种方式：<strong>称为查表法</strong></p>
<p>该过程用到了一些思想，值得去回味。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-流程控制语句</title>
    <url>/2020/03/14/JavaSE-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>1.程序流程控制-语句if<br>程序流程控制有四种结构：顺序结构、判断结构、选择结构、循环结构。<br>判断结构-if语句<br>三种格式<br>第一种<br>if(条件表达式)<br>{<br>    执行语句;<br>    }</p>
<a id="more"></a>
<p><strong>注意</strong>：if语句要明确控制范围，用大括号来控制，但当if语句中控制语句是单条语句时大括号可以省略。如果if语句没写大括号，就只能控制离它最近的单条语句。</p>
<p>这里单条语句不是指单行语句。如下图中，红色方框可以看成一个单条语句，所以外面的两个红圈圈起来的大括号可以省略。</p>
<p>第二种<br>if(条件表达式)<br>{<br>    执行语句;<br>}else{<br>    执行语句;<br>}</p>
<p>注意：三运运算符就是if else 语句简写格式。简写格式是运算符，必须要有运算结果，否则不能运行。简写格式当ifesle运算后有一个具体的结果时，可以简化成三元运算符。<br>第三种<br>if(条件表达式)<br>{<br>    执行语句;<br>}else if(条件表达式){<br>    执行语句;<br>}<br>…<br>else{<br>    执行语句;<br>}<br>这里再来一个括号省略的例子</p>
<p>2.局部代码块<br>任何在大括号之间的叫做代码块，加了if，就是if代码块，还有主函数代码块，类代码块如：</p>
<p>如果前面什么也没有，就叫局部代码块。</p>
<p>局部代码块可以定义局部变量的生命周期，可以有效腾出内存空间。</p>
<p>3.语句-switch<br>选择结构-switch<br>switch(表达式)<br>{<br>    case 取值1:<br>    break;<br>    case 取值2:<br>    执行语句;<br>    break;<br>    …<br>    default:默认<br>    执行语句;<br>    break;<br>}<br><strong>Switch语句只支持byte、short、int、char四种类型值</strong>。<br>备选答案是无序的，不是某个选择一定要放在第几个，但是执行是有顺序的。必须先执行case再执行default。<br>Switch结束方式有两种，一种是break结束，一种是执行到大括号结束，所以在最后的选择中，break是可以省略的。</p>
<p>若是这种情况，default和case4没有break，运行过程是先case4、case1、case3判断，然后不属于就来到default，判断对了之后，由于没有break，就继续执行可执行的语句。因为case是执行过，不会再执行，所以就直接执行System.out.printIn，直到遇到break，所以最后结果是：</p>
<p>3.switch与if的区别<br>If：<br>1.对具体的值进行判断<br>2.对区间进行判断<br>3.对运算结果是boolean类型的表达式进行判断</p>
<p>Switch:<br>1.对具体的值进行判断<br>2.值的个数通常的是固定的<br>对于几个固定的值判断建议使用switch语句，因为switch语句会将具体的答案都加载进内存，效率相对高一些。</p>
<p>4.while、do while语句<br>循环结构-while、do while、for<br>While语句<br>while(条件表达式)<br>{<br>    执行语句;<br>}</p>
<p>Do while<br>do<br>{<br>    执行语句;<br>}<br>while(条件表达式);</p>
<p>do while语句特点：无论条件是否满足，循环体至少执行一次。</p>
<p>5.while练习-计数器思想<br>需求：求1~100中6的倍数有几个</p>
<p>6.for语句<br>for(初始化表达式;循环条件表达式;循环后的操作表达式)<br>{<br>    执行语句;(循环体)<br>}</p>
<p>其中需要明白for循环基本运行过程。</p>
<p>有时候也会有上述形式，需要注意不要固化思维。</p>
<p>7.for和while的区别<br>1.for和while可以互换。<br>2.格式上的不同，在使用上有点小区别。<br>如果需要通过变量来对循环进行控制，该变量只作为循环增量的存在，区别就体现出来。<br>即在for括号里面进行的初始化表达式只在for循环中使用，一旦for循环结束，这个量就从内存中移除。</p>
<p>有时候会用到无限循环，所以给出两者无限循环的最简单的表达式</p>
<p>for的三个表达式都可以不写。头尾两个不写就是没有，中间的不写就是默认为true。<br>使用循环结构的场景：<br>当对某些代码执行很多次时，使用循环结构完成。<br>当对一个条件进行一次判断时，可以使用if语句。<br>当对一个条件进行多次判断时，可以使用while语句。<br>注意：1.在使用循环时，一定要明确哪些语句要参与循环，哪些不需要。<br>    2.循环通常情况下需要定义条件和控制次数。</p>
<p>8.for循环嵌套练习</p>
<p>9.语句-break&amp;continue<br>break:跳出<br>break作用范围：要么是switch语句，要么是循环语句。<br>注意：当break语句单独存在时，下面不要定义其他语句，因为执行不到。<br>如：</p>
<p>这种情况并不是break控制if语句，因为break只能控制switch和循环。这里它只是作为if的一个执行，当循环到x=1时，就执行break。</p>
<p>break跳出所在的当前循环<br>如果出现了循环嵌套，break想要跳出指定的循环，可以通过标号来完成。</p>
<p>Continue:<br>continue:结束本次循环，继续下次循环<br>作用范围：循环结构。<br>如果continue单独存在时，下面不要有任何语句，因为执行不到。</p>
<p>这种情况与break类似，同样执行不到下面语句。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-运算</title>
    <url>/2020/03/14/JavaSE-%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>基本的运算，运算两端必须是同一类型数值。<br>1.类型提升和强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">x = x + b;</span><br></pre></td></tr></table></figure>

<p>如果两端是数值型，不是同一类型也可以计算。因为计算时会把不同类型转换成相同类型进行计算，以占用内存比较大的为主。占用内存较小的会进行自动类型提升，如从一个字节提升为四个字节，这个过程是自动进行，最后得结果类型与内存占用较大的一致。如上述情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">b = b + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>这种情况进行编译时会报错，说是缺少精度。因为4是默认为int型，在计算完b=b+4时，b的类型变为int型，而不是byte，所以会报错。如果非要是byte型，则进行强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">b = (<span class="keyword">byte</span>)(b + <span class="number">125</span>);</span><br></pre></td></tr></table></figure>

<p>上面b的结果是-126。它会将高位的字节略去不要，留下低位字节。如果计算完的数在高位字节中有占用，则计算出来的结果不会有高位字节，结果会出现错误。所以强制类型转换会有风险。</p>
<a id="more"></a>
<p>2.字符类型运算过程<br>(‘a’ + 1)<br>对于括号里面的运算，是可以进行编译的，且得出来的结果是98。这里要首先知道存在一个二进制的生活中文字的对应关系表，也就是编码表，简称ASCII。这个表里面只有英文字母，数字和一些符号与二进制的对应关系。其中对应的二进制就是01100001，十进制中也就是97。在上述的计算中，其过程是首先将a转化为编码表里对应的二进制数（占两个字节）然后1是默认为int类型，占4个字节，将a进行类型升级，二者再相加，得到结果98。若想得到字符，则在前面加char，进行强制转换。<br>(char)(‘a’ + 1)<br>A对应65，a对应97,0对应48。<br>中文和二进制也有一一对应的关系，其形成的表叫做GB2312。后期扩展成GBK，之后又扩展成GB18030。<br>存在一个Unicode码表，含有国际上各个文字的码表。基本上都是有国际标准码表来完成。</p>
<p>3.类型运算细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">7</span>;</span><br><span class="line">b = b1 + b2;</span><br></pre></td></tr></table></figure>

<p>这种情况下，编译器会报错，说是缺少精度，应该转成int类型，请问原因（<strong>面试题</strong>）<br>在一开始中，byte b=4，系统检测4，发现int型的4是可以用byte表示，于是默认将int型的4强制转换成byte型。但是在上述代码中b=b1+b2，b1和b2都是变量，就算前面赋值，系统也是检测是变量，变量的话就不知道值是什么，如果还是强行转换成byte类型的话，是有可能装不下的，所以要转换成int类型。<br>如果int运算中也超了，编译是可以的，但是结果是，本来int最多是32位，超出的话会到33位及以上，这是系统就会把33位及以上的位数舍弃，只剩下32位，所以只显示32位的结果。</p>
<p>4.算术运算符和赋值运算符<br>算术运算符有<br> ‘+’- * /    java是强位型语言，其中两个整数除法运算会自动转换，舍弃小数点后的数字。<br>%（取余，模运算）  模运算，5%2是1,-5%2是-1,5%-2是1，所以模运算最后结果的符号看被模数，被模数是负，结果就是负。<br>+（连接） 任何数据用+与字符串相加，都是相连接。</p>
<p>++（自增，在原有数据基础上+1，再赋值给原有数据）<br>a=3；b=a++；这时的运算过程是a要自增，在自增之前，若参与了其他运算，先进行了a自己值的保留值的动作，再自增，再将保留值进行运算。<br>int i=3;i=i++;这时i的值是3。<br>–同上<br>赋值运算符 =、+=、-=、/=、*=、%=<br>int a=4;a+=2;该意思为左边等于左右两边的和即a=4+2=6<br>+=也是赋值运算符，也有做转换动作，底层会自动做强转。</p>
<p>5.比较运算符&amp;逻辑运算符<br>比较运算符<br>比较运算符运算完必定有结果，它的运算结果要么是true，要么是false。<br>比较运算符有：==、!=、&lt;、&gt;、&lt;=、&gt;=、instanceof(检查是否是类的对象，”hello” instanceof String   true)</p>
<p>逻辑运算符<br>逻辑运算符用于连接两个boolean类型的表达式<br>例：<br>&amp;与</p>
<p>|或</p>
<p>^异或<br>和或有些不同，两边都是true或false结果的话，结果是false，即两边比较结果都是一样的话是false，不同则是true。</p>
<p>！非<br>判断事物的另一面<br>!true=false; !false=true; !!true=true<br>&amp;&amp;双与<br>运算结果和单与相同，过程不同，双与只要符号左边一旦为假，则不再执行右边的运算，运算为假。单与则是无论左边的运算结果是什么，右边都参与运算。（<strong>面试会涉及</strong>）<br>||双或<br>运算结果和单或相同，过程不同，双或只要符号左边一旦为真，则不再执行右边的运算，运算为真。单或则是无论左边的运算结果是什么，右边都参与运算。</p>
<p>6.位运算符<br>位运算符有：&lt;&lt;左移，&gt;&gt;右移，&gt;&gt;&gt;无符号右移，&amp;与运算，!或运算，^异或运算，~反码<br>位运算是直接对二进制进行运算<br>这里注意<br>与运算符可以保留想要的后几位数</p>
<p>或运算符可以保留有效位即1</p>
<p>异或运算符中，一个数异或同一个数两次，结果还是这个数，可以用来加密。</p>
<p>7.移位运算符<br>左移&lt;&lt;：<br>如3&lt;&lt;2，将3左移两位，先把3表示成二进制形式，然后左移两位，结果是12。同理3&lt;&lt;3，3左移三位，结果是24，可以发现左移几位就是该数据乘以2的几次方。左移可以完成2的次幂运算。<br>右移&gt;&gt;：<br><strong>注意</strong>：右移后高位出现的空位，原来高位是什么就用什么补这个空位。如负数前面是1则就用1来补充。然后右移几位，其实就是该数据除以2的几次幂。<br>无符号右移&gt;&gt;&gt;：<br>数据进行右移时，高位出现的空位，无论原高位是什么，空位都用0补。</p>
<p>8.位运算符练习<br>1.最有效的方式算出2乘以8等于几？<br>想要运算高效，一般选用位运算。直接对二进制位上的数据进行操作。<br>所以这道题我们观察到8是2的三次方，可以直接使用左移位运算，即2&lt;&lt;3，这样运算的效率更高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>2.对两个整数变量进行互换（不需要第三方变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c = a; a = b; b = c;</span><br></pre></td></tr></table></figure>

<p>这种用了第三方变量，一般在开发时都是使用这种方法，因为能够提高阅读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>


<p>但开发时不用，因为阅读性低</p>
<p>9.三元运算符<br>三个元素参与运算的符号。无论表达形式什么样，都是运算符。只要是运算符，肯定就有结果<br>格式<br>(条件表达式) ? 表达式1 : 表达式2；<br>条件为true 结果是表达式1；条件为false结果是表达式2；<br>例：获取两个整数中较大的整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>,y = <span class="number">4</span>, z;</span><br><span class="line">z = (x &gt; y) ? x : y;</span><br></pre></td></tr></table></figure>


<p>获取三个整数中较大的整数</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-函数</title>
    <url>/2020/03/13/JavaSE-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>1 函数-定义<br>定义：定义在类中的具有特定功能的一段独立小程序。函数也称方法。</p>
<p>2 函数-格式<br>定义函数的格式：<br>    修饰符 返回值类型 函数名（参数类型 形式参数1，参数类型 形式参数2，…）<br>    {<br>        执行语句；<br>        return 返回值；<br>    }</p>
<a id="more"></a>
<p>函数名若是用到多个单词，则第一个单词首字母小写，后面的单词首字母大写。<br>形式参数也可以没有。<br>Return除了返回值的作用还有结束函数的作用。</p>
<p>3 函数-细节-void<br>特殊情况：<br>    功能没有具体的返回值。<br>    这时return的后面直接用分号结束。<br>    返回值类型怎么体现？因为没有具体值，所以不可以写具体的数据类型。<br>    在JAVA中，只能用一个关键字来表示这种情况。关键字是：void<br>    总结：没有具体返回值时，返回值类型用void来表示<br>注意：如果返回值类型是void，那么函数中的return语句可以省略不写。</p>
<p>4、5 函数-细节-错误格式、定义思想错误<br>函数的特点：<br>定义函数可以将功能代码进行封装<br>便于对该功能进行复用<br>函数只有被调用才会被执行<br>函数的出现提高了代码的复用性<br><strong>注意</strong>：<br>(1)函数中只能调用函数，不可以在函数内部定义函数。如下述代码是不行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	myPrint();	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)定义函数时，函数的结果应该返回给调用者，交由调用者处理。<br>如果想要在System.out.println(函数)中有结果，则函数不能是void类型，因为void类型没有返回值，没有输出结果。</p>
<p>6、7 、8函数-两个明确、练习<br>通过两个明确来完成<br>    明确1：这个功能的结果是什么？<br>    是和。是功能的结果，所以该功能的返回值类型是int。<br>    其实就是在明确函数的返回类型。<br>    明确2：这个功能实现过程中是否需要未知内容参与运算？<br>    有，加数和被加数。这就是函数的参数列表（参数的个数、参数类型）<br>    其实就是在明确参数列表<br><strong>注意</strong>：返回值类型和参数类型没有直接关系。</p>
<p>9 函数-内存加载过程<br>Java虚拟机先运行main函数，当遇到新函数或方法时，调用其，开始占用内存空间。等函数或方法调用结束，就不再占用内存，继续main函数，知道main函数执行完毕，也移出内存。<br>在这里提到栈的概念<br>特点：先进后出，先进来的放在栈底。</p>
<p>10 函数-重载<br>概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。<br>特点：与返回值类型无关，只看参数列表。如下述代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java是严谨性语言，如果出现的调用的不确定性，会编译失败。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-语言基础</title>
    <url>/2020/03/13/JavaSE-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>任何高级语言的基础组成<br>关键字、运算符、标识符、语句、注释、函数、常量与变量、数组</p>
<p>01 关键字</p>
<p>被赋予特殊java含义的单词<br>用于定义数据类型的关键字<br>class、interface、byte、short、int、long、float、double、char、boolean、void<br>用于定义数据类型值的关键字<br>true、false、null<br>用于定义流程控制的关键字<br>if、else、swich、case、default、while、do、for、break、continue、return<br>一般情况下，关键字全部是小写</p>
<a id="more"></a>
<p>02 标识符<br>在程序中自定义的一些名称。<br>由26个英文字母大小写，数字：0-9，符号：_$组成<br>定义符合标识符规则：<br>1.数字不可以开头<br>2.不可以使用关键字<br>Java中严格区分大小写。凡是名称都可以算是标识符，比如main函数中的main。</p>
<p>03 注释<br>用于注解说明程序中的文字。<br>单行注释：//说明文字。<br>多行注释：/*<br>          说明<br>          文字。<br>          <em>/<br>文档注释：java特有注释<br>/**<br>文档注释。<br><em>/<br>文档注释可以被javadoc提取，将文字和代码生成一个网页，形成程序说明书。<br>单行注释里面可以嵌套单行注释，即//asd//asd<br>单行注释里面可以嵌套多行注释，即//asd/</em>asd</em>/asd<br>多行注释里面可以嵌套单行注释，即/<em>asd//asd <em>/<br>多行注释里面可以嵌套多行注释，即/</em>asd/*asd</em>/，这里注意后面只有一个*/。<br>注释文字在编译时不编译进去。</p>
<p>04 注释的应用<br>工作或者面试时写代码，一定要添加注释。<br>以后一开始写程序时先写多行注释。</p>
<p>05 常量<br>表示不能改变的数值<br>分类：</p>
<ol>
<li>整数常量。所有整数 如2</li>
<li>小数常量。所有小数 如1.2</li>
<li>布尔（boolean）型常量。较为特殊，只有两个数值：true false</li>
<li>字符常量。将一个数字字母或者符号用单引号(‘’)标识 如‘2’‘a’</li>
<li>字符串常量。将一个或者过个字符用双引号(“”)标识 如“212”“asd”</li>
<li>null常量（空常量）。只有一种数值就是null。</li>
</ol>
<p>06 进制的由来<br>对于整数有四种表现形式<br>二进制：0.1，满2进1<br>八进制：0-7，满8进1，用0开头表示<br>十进制：0-9，满10进1<br>十六进制：0-9，A-F，满16进1.用0x开头表示</p>
<p>将八个二进制位成一个数据存储最小单元，称之为byte字节<br>每一个二进制位叫做bit位<br>1k=1024字节；<br>由于这样8个表示太麻烦，于是让三个bit位为一组，为八进制，四个为一组为16进制</p>
<p>07 进制转换<br>由于这样8个表示太麻烦，于是让三个bit位为一组，为八进制，四个为一组为16进制<br>这也是二进制转换成八进制和十六进制的比较快速的转换方法，例如<br>二进制10101110<br>转换成八进制，先以三个为一组，个数不够前面加0。再分别算出每组二进制对应的十进制，然后便得出八进制，如<br>010-101-110<br> 2   5   6即八进制表示就是0256<br>转换成十六进制<br>1010-1110<br> 10   14  即十六进制表示就是0xAE<br>结论：<br>八进制数，其实就是二进制位，3个二进制位为一个八进制<br>十六进制，其实就是二进制位，4个二进制位为一个十六进制</p>
<p>十进制转化成二进制<br>用2除取余数的方法，再从下往上看。</p>
<p>08 负数的进制<br>负数的二进制就是这个数的正数的二进制取反，加1<br>如-6<br>0000-0110 取反 1111-1001 加1即+0000-0001<br>等于1111-1010<br><strong>凡是负数，其二进制的最高位是1</strong></p>
<p>09 变量的介绍<br>概念：变量是内存中的一个存储区域，用来存储不确定的数据。当数据不确定时就要使用变量。<br>      该区域有自己的名称（变量名）和类型（数据类型），不同类型的数据不能放在同一区域<br>      该区域的数据可以在同一类型范围内不断变化<br>目的：用来不断地存放同一类型的常量，并可以重复使用。<br><strong>注意</strong>：变量的作用范围<br>      初始化值<br>定义变量的格式：<br>数据类型 变量名=初始化值<br>注：格式是固定的，记住格式，以不变应万变<br>Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。<br>数据类型分为基本数据类型和引用数据类型<br>基本数据类型分为数值型、字符型和布尔型<br>数值型有整数类型（byte,short,int,long）<br>Byte：字节，内存中占一个八位，-27到27-1，即-128至127<br>Short：短整型，内存从占两个字节即16个比特位，-215到215-1<br>Int：内存占4个字节，-2^31到2^31-1<br>Long：长整型，内存占8个字节<br>一般情况下，整数默认为int类型。<br>浮点类型（float,double）<br>Float：单精度，由4个字节表示<br>Double：双精度，由8个字节表示<br>一般情况下，小数默认为double类型。<br>字符型（char）：取值范围0到65535，即两个字节。‘12’不能存放，但是一个中文比如你好的你，可以存放。<br>布尔型（boolean）：<br>以上8个都是关键字。</p>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的一些基本操作</title>
    <url>/2020/03/06/hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="创建新文章并部署到远端"><a href="#创建新文章并部署到远端" class="headerlink" title="创建新文章并部署到远端"></a>创建新文章并部署到远端</h2><p>1.执行 hexo new[layout] 文章名 即可<br>layout为布局，Hexo有三种默认布局：post、page和draft，默认为post，可以在_config.yml中的default_layout 参数来指定默认布局</p>
<p>2.文章写完后保存文件，执行 hexo generate 或 hexo g 生成静态文件</p>
<p>3.执行 hexo deploy 将文件部署到远端</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/03/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这是我的第一个技术博客<br>希望能坚持下去，见证接下来的变化！</p>
<a id="more"></a>
<h2 id="639"><a href="#639" class="headerlink" title="639"></a>639</h2><p>639天下第一，不接受反驳</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
