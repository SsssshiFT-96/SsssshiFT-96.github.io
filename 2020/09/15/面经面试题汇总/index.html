<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*��������ɫ*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*��Ӱ��ɫ*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*�ϱ߿���ɫ*/
        border-left-color: #1E92FB;    /*��߿���ɫ*/
    }
</style>
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Z_Letter.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Z_Letter.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ssssshift-96.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JavaSE讲一下java的三个特性、多态*2、封装有什么用封装、继承、多态封装就是将对象的属性和方法封装起来，隐藏对象属性和方法实现细节，仅提供公共访问方式。好处就是可以信息隐藏和模块化，提高安全性。 继承就是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。可以在父类的基础上更改方法或者添加方法属性。提高代码的复用性同">
<meta property="og:type" content="article">
<meta property="og:title" content="面经面试题汇总">
<meta property="og:url" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="SsssshiFT-96">
<meta property="og:description" content="JavaSE讲一下java的三个特性、多态*2、封装有什么用封装、继承、多态封装就是将对象的属性和方法封装起来，隐藏对象属性和方法实现细节，仅提供公共访问方式。好处就是可以信息隐藏和模块化，提高安全性。 继承就是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。可以在父类的基础上更改方法或者添加方法属性。提高代码的复用性同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%5C64.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%5C65.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%5C66.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C67.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C17.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C18.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C19.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C20.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C21.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C16.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C11.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C12.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C13.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C14.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C15.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F.webp">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C31.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C22.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C23.png">
<meta property="og:image" content="c:%5CUsers%5CZHAN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200812164959345.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C25.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C26.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C27.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C28.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C29.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C30.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C57.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C63.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/%E5%9B%BE%E7%89%87/10.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C58.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C59.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C60.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C61.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C62.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C1.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C2.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C3.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C4.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C5.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C6.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C8.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C7.png">
<meta property="og:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/.%5C%E5%9B%BE%E7%89%87%5C9.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C32.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C33.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C34.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C35.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C36.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C37.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C38.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C41.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C39.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C40.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C42.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C43.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C44.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C45.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C46.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C47.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C48.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C49.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C50.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C51.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C52.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C53.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C54.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C55.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C56.png">
<meta property="og:image" content="h:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5CTCPIP%E5%8D%8F%E8%AE%AE.gif">
<meta property="article:published_time" content="2020-09-15T11:12:16.799Z">
<meta property="article:modified_time" content="2020-09-21T02:43:22.041Z">
<meta property="article:author" content="詹智健">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%5C64.png">

<link rel="canonical" href="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>面经面试题汇总 | SsssshiFT-96</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SsssshiFT-96</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">51</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ssssshift-96.github.io/2020/09/15/%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/A%20lemon.jpg">
      <meta itemprop="name" content="詹智健">
      <meta itemprop="description" content="今天也是很多个开心日子里开心的一天呀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SsssshiFT-96">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经面试题汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-15 19:12:16" itemprop="dateCreated datePublished" datetime="2020-09-15T19:12:16+08:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-21 10:43:22" itemprop="dateModified" datetime="2020-09-21T10:43:22+08:00">2020-09-21</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="讲一下java的三个特性、多态-2、封装有什么用"><a href="#讲一下java的三个特性、多态-2、封装有什么用" class="headerlink" title="讲一下java的三个特性、多态*2、封装有什么用"></a>讲一下java的三个特性、多态*2、封装有什么用</h2><p>封装、继承、多态<br><strong>封装</strong>就是将对象的属性和方法封装起来，隐藏对象属性和方法实现细节，仅提供公共访问方式。好处就是可以信息隐藏和模块化，提高安全性。</p>
<p><strong>继承</strong>就是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。可以在父类的基础上更改方法或者添加方法属性。提高代码的复用性<br>同时在使用继承时需要记住三句话：<br>1、子类拥有父类非private的属性和方法。<br>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>3、子类可以用自己的方式实现父类的方法。</p>
<p><strong>多态</strong>就是程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是程序运行时期才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中的实现方法，必须由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样不用修改源程序代码，就可以让引用变量绑定到不同的类的实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。</p>
<a id="more"></a>

<h2 id="int和Integer区别"><a href="#int和Integer区别" class="headerlink" title="int和Integer区别"></a>int和Integer区别</h2><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0<br>二者比较：<br>1.两个通过new生成的Integer变量是永远不相等的<br>2.Integer和int比较时，Integer会自动拆箱为int，自动拆箱的代码为i.intValue()，所以只要值相同，这两个就相同<br>3.非new生成的Integer和new生成的Integer不会相等<br>4.两个非new生成的Integer对象比较，如果变量的值在区间-128到127之间，则会为true。如果不是则为false。因为非new生成的Integer会自动装箱，即Integer i= 100；就会变成 Integer i= Integer.valueOf(100)；这个方法在-128到127之间是从常量池中取值，而不在这个范围的则是通过new来取值。</p>
<h2 id="i-i-、i-、i-i、-i"><a href="#i-i-、i-、i-i、-i" class="headerlink" title="i = i++、i++、i=++i、++i"></a>i = i++、i++、i=++i、++i</h2><p>i++在字节码文件中的过程是先将局部变量i的值压入操作数栈，然后自增，最后将压入操作数栈的值赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">20</span>;</span><br><span class="line">j = i++;</span><br><span class="line"><span class="comment">/*具体过程：</span></span><br><span class="line"><span class="comment">1.将参数20压入操作数栈</span></span><br><span class="line"><span class="comment">2.从栈中弹出一个数赋值给局部变量i</span></span><br><span class="line"><span class="comment">3.将局部变量i的值压入栈中</span></span><br><span class="line"><span class="comment">4.局部变量i自增，i变为21</span></span><br><span class="line"><span class="comment">5.从栈中弹出一个数赋值给局部变量j</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">若为i=i++</span></span><br><span class="line"><span class="comment">那么就是最后一步变为从栈中弹出一个数赋值给局部变量i，即i的值又变回了20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">--i则就是先自增再将值压入栈中。</span><br></pre></td></tr></table></figure>

<p><a href="https://zhuanlan.zhihu.com/p/40645506" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40645506</a></p>
<h2 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h2><p>深拷贝和浅拷贝均为对一个对象的复制，被复制的对象需要实现cloneable接口并重写clone()方法<br>区别：对于基本数据类型是进行了值的传递，复制后中的对象对基本数据类型修改，被复制的对象对应的变量值不会改变。而对于引用数据类型，浅拷贝是复制了对象地址，所以复制后的对象中对引用数据类型修改，被复制对象中的对应的变量的值也会改变。而深拷贝则不会。<br>深拷贝需要被复制对象中的引用数据类型的类也要实现cloneable()接口，然后在被复制对象的clone()方法中不仅执行本类的clone方法，也要执行成员变量的clone方法。</p>
<p><a href="https://www.jianshu.com/p/94dbef2de298" target="_blank" rel="noopener">https://www.jianshu.com/p/94dbef2de298</a></p>
<h3 id="接口和抽象类有什么区别"><a href="#接口和抽象类有什么区别" class="headerlink" title="接口和抽象类有什么区别"></a>接口和抽象类有什么区别</h3><p>区别：<br>1.<br>抽象类需要被继承，而且只能单继承<br>接口需要被实现，而且可以多实现</p>
<p>2.<br>抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法<br>接口中只能定义抽象方法，必须有子类去实现。除了抽象方法，还只能定义常量</p>
<p>3.<br>抽象类的继承是is a 关系，所属关系，在定义该体系的基本共性内容<br>接口的实现时like a关系，像关系，在定义体系额外功能</p>
<h2 id="讲一下String三个类的区别"><a href="#讲一下String三个类的区别" class="headerlink" title="讲一下String三个类的区别"></a>讲一下String三个类的区别</h2><p>String、StringBuffer、StringBuilder三者都是由final修饰的，故不能被继承</p>
<p>StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder。</p>
<p><strong>String 声明的是不可变的对象</strong>，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 <strong>StringBuffer、StringBuilder 存储数据的字符数组没有被final修饰，说明值可以改变，且也是可变长度的，</strong>抽象类AbstractStringBuilder内部都提供了一个自动扩容机制，当发现长度不够的时候(初始默认长度是16)，会自动进行扩容工作，扩展为原数组长度的2倍加2，创建一个新的数组，并将数组的数据复制到新数组，所以对于拼接字符串效率要比String要高。</p>
<p>线程安全性：StringBuffer由于很多方法都被 synchronized 修饰了所以线程安全，但是当多线程访问时，加锁和释放锁的过程很平凡，所以效率相比StringBuilder要低。StringBuilder相反执行效率高，但是线程不安全。所以单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<p>执行速度:StringBuilder &gt; StringBuffer &gt; String。</p>
<h2 id="String拼接怎么做到的"><a href="#String拼接怎么做到的" class="headerlink" title="String拼接怎么做到的"></a>String拼接怎么做到的</h2><p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303" target="_blank" rel="noopener">https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303</a></p>
<p>1.如果是字面量常值拼接，即 s = “abc” + “qwer”; 则就是在常量池中进行，在字符串常量池中查找需要的字符串，如果找到，则指向给String引用，找不到则新建所需字符串，将地址指向给String引用。因为字符串常量池中不能存在相同字符串，每次拼接都要新建字符串，不能在原有字符串上进行修改。<br>2.如果拼接中带有变量，即 s = s + “abc”; 则会转成StringBuilder，然后使用append完成拼接，运算完成后转成String类型返回，该String是存放在堆中。<br><strong>字符串拼接原理：</strong>运行时， 两个字符串str1, str2的拼接首先会调用 String.valueOf(obj)，这个Obj为str1，而String.valueOf(Obj)中的实现是return obj == null ? “null” : obj.toString(), 然后产生StringBuilder， 调用的StringBuilder(str1)构造方法， 把StringBuilder初始化，长度为str1.length()+16，并且调用append(str1)！ 接下来调用StringBuilder.append(str2), 把第二个字符串拼接进去， 然后调用StringBuilder.toString()返回结果！</p>
<h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p>数组：增删改慢，查询快<br>链表：查询慢，增删改快</p>
<h2 id="Arraylist和LinkedList区别，ArrayList的初始大小"><a href="#Arraylist和LinkedList区别，ArrayList的初始大小" class="headerlink" title="Arraylist和LinkedList区别，ArrayList的初始大小"></a>Arraylist和LinkedList区别，ArrayList的初始大小</h2><p>区别同上</p>
<p>Arraylist调动无参构造时，底层数组的容量为0；</p>
<p>之前是10<br><a href="https://blog.csdn.net/huhahuha_/article/details/84329524" target="_blank" rel="noopener">https://blog.csdn.net/huhahuha_/article/details/84329524</a></p>
<p>ArrayList的扩容：核心方法为grow();</p>
<ol>
<li>当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。而后的数组扩容才是<strong>按照当前容量的1.5倍进行扩容；</strong></li>
<li>当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都 +1，在第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。</li>
<li>当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的31次方减1）</li>
</ol>
<p><a href="https://www.cnblogs.com/lingshang/p/10897912.htm" target="_blank" rel="noopener">https://www.cnblogs.com/lingshang/p/10897912.htm</a></p>
<p>LinkedList由链表实现，不存在扩容的操作。</p>
<h2 id="Java泛型机制了解吗"><a href="#Java泛型机制了解吗" class="headerlink" title="Java泛型机制了解吗"></a>Java泛型机制了解吗</h2><p>泛型带来的好处：在编辑期间就能判断出类型是否异常，提高安全性，以及还有更好的可读性</p>
<p><a href="https://www.jianshu.com/p/72ffcbf439fd" target="_blank" rel="noopener">https://www.jianshu.com/p/72ffcbf439fd</a></p>
<h2 id="JDK源码看过哪些-2"><a href="#JDK源码看过哪些-2" class="headerlink" title="JDK源码看过哪些*2"></a>JDK源码看过哪些*2</h2><h2 id="HashMap遍历键值对的方法，哪种方式速度最快？"><a href="#HashMap遍历键值对的方法，哪种方式速度最快？" class="headerlink" title="HashMap遍历键值对的方法，哪种方式速度最快？"></a>HashMap遍历键值对的方法，哪种方式速度最快？</h2><h2 id="HashMap的键如果是自定义类，会有什么问题？"><a href="#HashMap的键如果是自定义类，会有什么问题？" class="headerlink" title="HashMap的键如果是自定义类，会有什么问题？"></a><strong>HashMap的键如果是自定义类，会有什么问题？</strong></h2><p>当Map的key是自定义的对象类型时，要在自定义类中，重载Object类的两个方法，hashCode()和equals()，使得满足自己定义的“相同”的含义，这样才能用“相同”的key取到合适的value。</p>
<h2 id="HashMap底层实现原理，如何进行put的"><a href="#HashMap底层实现原理，如何进行put的" class="headerlink" title="HashMap底层实现原理，如何进行put的"></a>HashMap底层实现原理，如何进行put的</h2><p><a href="https://zhuanlan.zhihu.com/p/28501879" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28501879</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//首先判断是否有存放Node的数组，没有就初始化一个大小为16的数组</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过之前算出来的Hash值，算出在数组中存放的位置，判断该位置是否有结点。没有就在该位置新建一个结点存放指定的key-value</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//底层元素匹配成功，赋值给e</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果是树，则放到树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//若数组中存放的位置处有节点且不是树节点以及和要存放的不一样，则在位置链表的最后一个节点，然后将要存放的接到该节点后面。若链表的节点数超过了8，则转换成红黑树</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用新的value替换旧的value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="如何计算Hash值"><a href="#如何计算Hash值" class="headerlink" title="如何计算Hash值"></a>如何计算Hash值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先用本类的hashcode方法计算出一个值，再h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)。因为后面计算数组中位置时，(n-1)&amp;h 可能用不到哈希值的高位信息，因为n会比较小，而这里我们通过再次计算，可以在后面计算的数组中位置时用到高位信息。</p>
<h2 id="HashMap线程安全吗？为什么不安全？"><a href="#HashMap线程安全吗？为什么不安全？" class="headerlink" title="HashMap线程安全吗？为什么不安全？"></a>HashMap线程安全吗？为什么不安全？</h2><p>不安全。因为高并发时，进行HashMap中数组扩容时会出现死循环。<br><a href="https://www.cnblogs.com/williamjie/p/11089522.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/11089522.html</a></p>
<p>JDK7 存在死循环和数据丢失问题。</p>
<p><strong>数据丢失：</strong></p>
<ul>
<li><strong>并发赋值被覆盖：</strong> 在 <code>createEntry</code> 方法中，新添加的元素直接放在头部，使元素之后可以被更快访问，但如果两个线程同时执行到此处，会导致其中一个线程的赋值被覆盖。</li>
<li><strong>已遍历区间新增元素丢失：</strong> 当某个线程在 <code>transfer</code> 方法迁移时，其他线程新增的元素可能落在已遍历过的哈希槽上。遍历完成后，table 数组引用指向了 newTable，新增元素丢失。</li>
<li><strong>新表被覆盖：</strong> 如果 <code>resize</code> 完成，执行了 <code>table = newTable</code>，则后续元素就可以在新表上进行插入。但如果多线程同时 <code>resize</code> ，每个线程都会 new 一个数组，这是线程内的局部对象，线程之间不可见。迁移完成后<code>resize</code> 的线程会赋值给 table 线程共享变量，可能会覆盖其他线程的操作，在新表中插入的对象都会被丢弃。</li>
</ul>
<p><strong>死循环：</strong> 扩容时 <code>resize</code> 调用 <code>transfer</code> 使用头插法迁移元素，虽然 newTable 是局部变量，但原先 table 中的 Entry 链表是共享的，问题根源是 Entry 的 next 指针并发修改，某线程还没有将 table 设为 newTable 时用完了 CPU 时间片，导致数据丢失或死循环。</p>
<p>JDK8 在 <code>resize</code> 方法中完成扩容，并改用尾插法，不会产生死循环，但并发下仍可能丢失数据。可用 ConcurrentHashMap 或 <code>Collections.synchronizedMap</code> 包装成同步集合。</p>
<h2 id="HashMap内部是怎么实现的（数组-红黑树-链表）-2"><a href="#HashMap内部是怎么实现的（数组-红黑树-链表）-2" class="headerlink" title="HashMap内部是怎么实现的（数组+红黑树/链表）*2"></a>HashMap内部是怎么实现的（数组+红黑树/链表）*2</h2><h2 id="哈希冲突怎么办？为什么都用链地址法？"><a href="#哈希冲突怎么办？为什么都用链地址法？" class="headerlink" title="哈希冲突怎么办？为什么都用链地址法？"></a>哈希冲突怎么办？为什么都用链地址法？</h2><p><a href="https://blog.csdn.net/zhangvalue/article/details/83784716" target="_blank" rel="noopener">https://blog.csdn.net/zhangvalue/article/details/83784716</a></p>
<p><a href="https://www.jianshu.com/p/4d3cb99d7580" target="_blank" rel="noopener">https://www.jianshu.com/p/4d3cb99d7580</a></p>
<p>1.开放地址方法</p>
<p>　　（1）线性探测</p>
<p>　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上往后加一个单位，直至不发生哈希冲突。　</p>
<p>　　（2）再平方探测</p>
<p>　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则减1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。</p>
<p>　　（3）伪随机探测</p>
<p>　　　按顺序决定值时，如果某数据已经存在，通过随机函数随机生成一个数，在原来值的基础上加上随机数，直至不发生哈希冲突。</p>
<p>2.链式地址法（HashMap的哈希冲突解决方法）</p>
<p>　　对于相同的值，使用链表进行连接。使用数组存储每一个链表。</p>
<p>　　优点：</p>
<p>　　（1）拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p>
<p>　　（2）由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</p>
<p>　　（3）开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p>
<p>　　（4）在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。<br>　　缺点：</p>
<p>　　指针占用较大空间时，会造成空间浪费，若空间用于增大散列表规模进而提高开放地址法的效率。</p>
<p>3.建立公共溢出区</p>
<p>　　建立公共溢出区存储所有哈希冲突的数据。</p>
<p>4.再哈希法</p>
<p>　　对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。</p>
<h2 id="HashMap底层扩容（扩容因子为什么是0-75？扩容之后的数组落在哪？为啥容量一定是2的倍数？为什么引入红黑树？红黑树的参数？并发的时候怎么处理）-2"><a href="#HashMap底层扩容（扩容因子为什么是0-75？扩容之后的数组落在哪？为啥容量一定是2的倍数？为什么引入红黑树？红黑树的参数？并发的时候怎么处理）-2" class="headerlink" title="HashMap底层扩容（扩容因子为什么是0.75？扩容之后的数组落在哪？为啥容量一定是2的倍数？为什么引入红黑树？红黑树的参数？并发的时候怎么处理）*2"></a>HashMap底层扩容（扩容因子为什么是0.75？扩容之后的数组落在哪？为啥容量一定是2的倍数？为什么引入红黑树？红黑树的参数？并发的时候怎么处理）*2</h2><p><a href="https://blog.csdn.net/lkforce/article/details/89521318#HashMap%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">https://blog.csdn.net/lkforce/article/details/89521318#HashMap%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
<p>JDK1.8以前，扩容后，原来的元素需要用新的数组长度来重新计算插入的位置，然后使用头插法将原来数组中的节点插入到新数组。因为使用的是头插法，所以新表中链表的顺序是和原来是相反的。</p>
<p>JDK1.8，正常情况下，计算节点在table中的下标的方法是：hash&amp;(oldTable.length-1)，扩容之后，table长度翻倍，计算table下标的方法是hash&amp;(newTable.length-1)，也就是hash&amp;(oldTable.length<em>2-1)，于是我们有了这样的结论：*</em>这新旧两次计算下标的结果，要不然就相同，要不然就是新下标等于旧下标加上旧数组的长度**。其实1.8以前算新的位置也是与上新的长度-1。然后就会根据新旧两次计算下标的结果判定位置有无发生变化。如果没有发生变化，则使用前面定义的loHead和loTail节点，使用尾插法插入；若发生变化，则使用hiHead和hiTail节点，使用尾插法插入。最后将liHead和hiHead放入新表的指定位置</p>
<p><strong>容量是2的幂次的原因</strong>是后面计算元素放在数组哪个位置时，用的是map的长度-1和hashcode进行与运算。如果是2的倍数，则二进制都是1111 1111….的形式，如果不是2的幂次，比如为15，那么进行与运算就是1110，这样0位置永远就是0，那么就用不到该位置为1的数组位置造成了浪费。</p>
<p><strong>扩容因子是0.75</strong>，原因是若扩容因子为1，则会出现较多的哈希冲突，导致链表或者红黑树结构复杂，查询效率低。而扩容因子为0.5的话，则会有一半的空间用不到，浪费。扩容因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p>
<p><strong>链表长度到达8才转变成红黑树的原因：</strong>首先红黑树树节点所占据的空间大小是普通节点的两倍，所以一开始时间复杂度不高时，就不用红黑树。选8作为转变的原因，源码上说，为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点遵循泊松分布，而且根据统计，链表中节点数是8的概率已经接近千分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。<br><strong>注意：</strong>但也不是只要到8链表就转变成红黑树，在链表转变为红黑树方法中，有这样一个判断，数组长度小于MIN_TREEIFY_CAPACITY（64），就会扩容，而不是直接转变为红黑树，可不是什么链表长度为8就变为红黑树，要仔细看代码，还有别的条件，</p>
<h2 id="想获得线程安全的HashMap有哪些方式"><a href="#想获得线程安全的HashMap有哪些方式" class="headerlink" title="想获得线程安全的HashMap有哪些方式"></a>想获得线程安全的HashMap有哪些方式</h2><p>使用HashTable<br>使用ConcurrentHashMap<br>使用synchronizedMap()方法包装HashMap</p>
<h2 id="ConcurrentHashMap如何保证线程安全，如何分段，锁粒度，扩容rehash的过程，size如何计算-3"><a href="#ConcurrentHashMap如何保证线程安全，如何分段，锁粒度，扩容rehash的过程，size如何计算-3" class="headerlink" title="ConcurrentHashMap如何保证线程安全，如何分段，锁粒度，扩容rehash的过程，size如何计算*3"></a>ConcurrentHashMap如何保证线程安全，如何分段，锁粒度，扩容rehash的过程，size如何计算*3</h2><p><a href="https://juejin.im/post/6844903813892014087" target="_blank" rel="noopener">https://juejin.im/post/6844903813892014087</a></p>
<p><a href="https://blog.csdn.net/qq_41737716/article/details/90549847" target="_blank" rel="noopener">https://blog.csdn.net/qq_41737716/article/details/90549847</a></p>
<p>在JDK1.7中<strong>使用分段锁即Segment保证线程安全。</strong>每个Segment可以看做是一个HashMap，Segment继承了ReentrantLock，本身就是一个锁。在Segment中通过HashEntry数组来维护其内部的hash表。每个HashEntry就代表了map中的一个K-V，用HashEntry可以组成一个链表结构，通过next字段引用到其下一个元素。当进行put的时候，就将该segment锁住，此时其他线程无法对此segment进行操作，但可以对其他segment操作，所以锁粒度是一个链表。扩容的时候，ConcurrentHashMap只针对每个segment中的HashEntry数组进行扩容，在rehash的过程中，对该segment加锁，其他线程无法操作。</p>
<p>在JDK1.8中ConcurrentHashMap结构与HashMap类型，table的初始化采用了延迟初始化策略，会在第一次执行put的时候初始化table。<strong>通过Unsafe、CAS和锁的机制保证高并发下的线程安全。</strong>在put的时候，通过Unsafe操作获取table上对应index上的元素，如果是空的，则尝试用cas的方式在table指定index处创建一个新的Node。若发生哈希冲突，则直接用链表的头节点作为锁进行put操作，<strong>所以锁粒度为一个链表的节点</strong>。put方法的最后一步是统计hash表中元素的个数，如果超过sizeCtl的值，触发扩容。对ConcurrentHashMap是如何解决扩容的并发问题这一疑问进行简要说明。</p>
<ul>
<li>首先new一个新的hash表(nextTable)出来，大小是原来的2倍。后面的rehash都是针对这个新的hash表操作，不涉及原hash表(table)。</li>
<li>然后会对原hash表(table)中的每个链表进行rehash，此时会尝试获取头节点的锁。这一步就保证了在rehash的过程中不能对这个链表执行put操作。</li>
<li>通过sizeCtl控制，使扩容过程中不会new出多个新hash表来。</li>
<li>最后，将所有键值对重新rehash到新表(nextTable)中后，用nextTable将table替换。这就避免了HashMap中get和扩容并发时，可能get到null的问题。</li>
<li>在整个过程中，共享变量的存储和读取全部通过volatile或CAS的方式，保证了线程安全。</li>
</ul>
<h2 id="HashMap和concurrentHashMap分别的应用场景，区别？"><a href="#HashMap和concurrentHashMap分别的应用场景，区别？" class="headerlink" title="HashMap和concurrentHashMap分别的应用场景，区别？"></a>HashMap和concurrentHashMap分别的应用场景，区别？</h2><p>后者多用于高并发的场景下。因为ConcurrentHashMap是线程安全的</p>
<h2 id="LinkedHashMap底层，以及对时间复杂度是否有变慢"><a href="#LinkedHashMap底层，以及对时间复杂度是否有变慢" class="headerlink" title="LinkedHashMap底层，以及对时间复杂度是否有变慢"></a>LinkedHashMap底层，以及对时间复杂度是否有变慢</h2><p><a href="https://segmentfault.com/a/1190000012964859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012964859</a></p>
<h2 id="WeakHashMap的使用场景，实现原理"><a href="#WeakHashMap的使用场景，实现原理" class="headerlink" title="WeakHashMap的使用场景，实现原理"></a>WeakHashMap的使用场景，实现原理</h2><h2 id="反射了解吗"><a href="#反射了解吗" class="headerlink" title="反射了解吗"></a>反射了解吗</h2><p>就是动态的获取类的信息。<br>通过Class.forName();可以获取某个类的class对象，通过该对象可以使用newInstance的方法创建实例对象。也可以通过getConstructor()方法获取构造器，在newInstance()方法创建实例对象</p>
<h2 id="阐述一下java-jar-main的整个运行过程"><a href="#阐述一下java-jar-main的整个运行过程" class="headerlink" title="阐述一下java jar main的整个运行过程"></a>阐述一下java jar main的整个运行过程</h2><h2 id="如何读入文档最后N行？"><a href="#如何读入文档最后N行？" class="headerlink" title="如何读入文档最后N行？"></a>如何读入文档最后N行？</h2><p><a href="https://blog.csdn.net/qq_27724109/article/details/97630428?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-1&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">https://blog.csdn.net/qq_27724109/article/details/97630428?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-1&amp;spm=1001.2101.3001.4242</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件最后几行 &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 相当于Linux系统中的tail命令 读取大小限制是2GB</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filename 文件名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset  文件编码格式,传null默认使用defaultCharset</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rows     读取行数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readLastRows</span><span class="params">(String filename, Charset charset, <span class="keyword">int</span> rows)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	charset = charset == <span class="keyword">null</span> ? Charset.defaultCharset() : charset;</span><br><span class="line">	String lineSeparator = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">	<span class="keyword">try</span> (RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(filename, <span class="string">"r"</span>)) &#123;</span><br><span class="line">		<span class="comment">// 每次读取的字节数要和系统换行符大小一致</span></span><br><span class="line">		<span class="keyword">byte</span>[] c = <span class="keyword">new</span> <span class="keyword">byte</span>[lineSeparator.getBytes().length];</span><br><span class="line">		<span class="comment">// 在获取到指定行数和读完文档之前,从文档末尾向前移动指针,遍历文档每一个字节</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> pointer = rf.length(), lineSeparatorNum = <span class="number">0</span>; pointer &gt;= <span class="number">0</span> &amp;&amp; lineSeparatorNum &lt; rows;) &#123;</span><br><span class="line">			<span class="comment">// 移动指针</span></span><br><span class="line">			rf.seek(pointer--);</span><br><span class="line">			<span class="comment">// 读取数据</span></span><br><span class="line">			<span class="keyword">int</span> readLength = rf.read(c);</span><br><span class="line">			<span class="keyword">if</span> (readLength != -<span class="number">1</span> &amp;&amp; <span class="keyword">new</span> String(c, <span class="number">0</span>, readLength).equals(lineSeparator)) &#123;</span><br><span class="line">				lineSeparatorNum++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//扫描完依然没有找到足够的行数,将指针归0</span></span><br><span class="line">			<span class="keyword">if</span> (pointer == -<span class="number">1</span> &amp;&amp; lineSeparatorNum &lt; rows) &#123;</span><br><span class="line">				rf.seek(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">byte</span>[] tempbytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) (rf.length() - rf.getFilePointer())];</span><br><span class="line">		rf.readFully(tempbytes);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(tempbytes, charset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h2><p>Thorwable类（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系：</p>
<p>1、Error与Exception<br>  Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。<br>  Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。<br>2、运行时异常和非运行时异常<br>  运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException、ClassCastException、ArithmeticException 、SecurityException 等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>  非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h2 id="static关键字的作用（在类上、方法上、变量上）"><a href="#static关键字的作用（在类上、方法上、变量上）" class="headerlink" title="static关键字的作用（在类上、方法上、变量上）"></a>static关键字的作用（在类上、方法上、变量上）</h2><p><strong>static存在的意义:</strong><br>创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法。<br>static块可以置于类中的任何地方，类中可以有很多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。所以将一些只需要进行一次的初始化操作都放在static代码块中进行，这样可以优化程序性能</p>
<p><strong>static的特点:</strong></p>
<p>被static修饰的成员或者方法是独立于该类的任何对象，也就是说这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。<br>在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在第一次使用时加载并进行初始化，这是第一次用就要初始化，后面根据需要可以再次赋值。<br>static变量值在类加载的时候分配空间，以后创建对象的时候不会重新分配。赋值的话是可以任意赋值的<br>被static修饰的变量或者方法是优先于对象存在的，当一个类加载完毕，即便没有创建对象，也可以去访问。<br>被static修饰的其生命周期属于类级别，从JVM加载开始到JVM结束。</p>
<p><strong>static的应用场景:</strong><br>因为static是被类的实例对象所共享，因此如果某个成员变量被所有对象对象共享，那么这个成员变量就应该被定义为静态变量<br>1.修饰成员变量；2.修饰成员方法；3.静态代码块；4.修饰类（只能修饰内部类也就是静态内部类）；5.静态导包</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>将一个类定义在另一个类的里面，对里面那个类就称为内部类<br>内部类可以直接访问外部类中的成员，因为内部类持有了外部类的引用，即外部类.this。<br>外部类想要访问内部类，必须建立内部类的对象</p>
<p><strong>内部类分为静态内部类和非静态内部类</strong><br>如果内部类是静态的，相当于一个外部类。如果内部类中定义了静态成员，该内部类也必须是静态成员。<br>静态内部类不需要有指向外部类的引用，但非静态内部类需要持有对外部类的引用<br>非静态内部类能够访问外部类的静态和非静态成员，静态类内部类不能访问外部类的非静态成员，它只能访问外部类的静态成员<br>一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。<br>静态内部类不用先创建外部类，静态内部类可以看做外部类的静态变量，使用就不用外部类的实例，而非静态就必须先实例化</p>
<p><strong>局部内部类</strong><br>内部类可以放在局部位置上局部位置上只能访问局部中被final修饰的局部变量</p>
<p><strong>匿名内部类</strong><br>匿名内部类就是内部类的简写格式<br>必须有前提<br>内部类必须继承或者实现一个外部类或者接口<br>匿名内部类其实就是一个匿名子类对象<br>格式：new 父类or接口名(){子类内容};</p>
<h2 id="重写equals方法"><a href="#重写equals方法" class="headerlink" title="重写equals方法"></a>重写equals方法</h2><p><strong>原则</strong><br>1.自反性，跟自己比较是相等的<br>2.对称性，x.equals(y)的结果要和y.equals(x)的结果一致<br>3.传递性，x与y相等，y与z相等，那么x与z通过equals的结果也应该是相等<br>4  一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变<br>5  非空性：任何非空的引用值X，x.equals(null)的返回值一定为false</p>
<p><strong>重写equals时也要同时重写hashcode</strong><br>这一点主要是考虑和集合类协同工作的需要。一般集合为加快存取速度，通常使用类hashtable的方式存取对象，hashCode() &amp;&amp; equals() 则是判断待查找元素与集合中某个元素相等的依据。 而java中默认的hashCode是由对象的内存地址生成的, 如果重写了equals 而 重写 hashCode， 则会造成“A和B相等，A加入集合后，用B查询集合却查不到”的悖论。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM的组成-内存结构？-3"><a href="#JVM的组成-内存结构？-3" class="headerlink" title="JVM的组成/内存结构？*3"></a>JVM的组成/内存结构？*3</h2><p>PC寄存器：当前线程所执行的字节码的行号指示器<br>虚拟机栈：以栈帧为单位，有局部变量区、操作数栈、方法出口、动态连接。每个方法执行的时候都会创建一个栈帧，从方法调用到结束，经历入栈和出栈的过程。<br>堆：用来存放对象实例，各个线程共享的区域。<br>方法区：各个线程共享的区域。用于存放已经被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等数据。<br>本地方法栈：为虚拟机使用到的本地方法服务</p>
<h2 id="对象创建的内存分配"><a href="#对象创建的内存分配" class="headerlink" title="对象创建的内存分配"></a>对象创建的内存分配</h2><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有就必须先执行类的加载过程。随后虚拟机<strong>为新生对象分配内存</strong><br>为对象分配空间的任务实际上是等同于把一块确定大小的内存块从Java堆中划分出来。这时有两种分配方式：<br><strong>指针碰撞</strong><br>如果Java堆中的内存是绝对规整的，所有被用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离<br><strong>空闲列表</strong><br>如果Java堆中的内存并不是规整的，已被使用的内存与空闲内存是互相交错在一起，虚拟机这是必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。<br>选择哪种分配方式由Java堆是否规整决定，Java堆是否规整又由所采用的的垃圾收集器是否带有空间压缩整理的能力决定。如使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞；当使用CMS这种基于标记-清除算法的垃圾收集器时，理论上就只能使用空闲列表</p>
<p><strong>分配内存的线程安全问题</strong><br>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能会出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况<br>解决方案两种<br>1.对分配内存空间的动作进行同步处理——实际上虚拟机时采用CAS配上失败重试的方式保证更新操作的原子性。<br>2.把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓存(Thread Local Allocation Buffer, TLAB)。哪个线程要分配内存，就在哪个线程的本地缓冲区分配。只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</p>
<p><strong>内存分配完毕后</strong>，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头、实例数据和对齐填充</strong></p>
<p><strong>对象头</strong><br>包含两类信息<br><strong>第一类</strong>是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。<br><strong>第二类</strong>是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针。如果对象是个<strong>Java数组</strong>，在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p>
<p>在32位的HotSpot虚拟机中，如果对象处于<strong>未被锁定的状态下</strong>，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志，1bit固定为0<br><img src="%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%5C64.png" alt=""></p>


<p>在32位系统下，存放Class指针的空间大小是4字节，Mark Word空间大小也是4字节，因此头部就是8字节，如果是数组就需要再加4字节表示数组的长度<br><img src="%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%5C65.png" alt=""></p>
<p>在64位系统及64位JVM下，开启指针压缩，那么头部存放Class指针的空间大小还是4字节，而Mark Word区域会变大，变成8字节，也就是头部最少为12字节<br><img src="%E9%9D%A2%E7%BB%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%5C66.png" alt=""></p>
<p><strong>压缩指针：</strong>开启指针压缩使用算法开销带来内存节约，Java 对象都是以 8 字节对齐的，也就是以 8 字节为内存访问的基本单元，那么在地理处理上，就有 3 个位是空闲的，这 3 个位可以用来虚拟，利用 32 位的地址指针原本最多只能寻址 4GB，但是加上 3 个位的 8 种内部运算，就可以变化出 32GB 的寻址。</p>
<p><strong>实例数据</strong><br>实例数据部分是对象真正存储的有效信息，即我们在程序中代码里面所定义的各种类型的字段内容，无论是从父类继承下来，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省一点点空间。</p>
<p><strong>对齐填充</strong><br>对齐填充不是必然存在的，仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数，因此如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<p><strong>估算对象大小</strong><br>32 位系统下，当使用 new Object() 时，JVM 将会分配 8（Mark Word+类型指针） 字节的空间，128 个 Object 对象将占用 1KB 的空间。如果是 new Integer()，那么对象里还有一个 int 值，其占用 4 字节，这个对象也就是 8+4=12 字节，对齐后，该对象就是 16 字节。</p>
<p>以上只是一些简单的对象，那么对象的内部属性是怎么排布的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    int i;</span><br><span class="line">    byte b;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中对象头部占用 ‘Mark Word’4 + ‘类型指针’4 = 8 字节；byte 8 位长，占用 1 字节；int 32 位长，占用 4 字节；String 只有引用，占用 4 字节；<br>那么对象 A 一共占用了 8+1+4+4=17 字节，按照 8 字节对齐原则，对象大小也就是 24 字节。</p>
<p>这个计算看起来是没有问题的，对象的大小也确实是 24 字节，但是对齐（padding）的位置并不对：</p>
<p>在 HotSpot VM 中，对象排布时，间隙是在 4 字节基础上的（在 32 位和 64 位压缩模式下），上述例子中，int 后面的 byte，空隙只剩下 3 字节，接下来的 String 对象引用需要 4 字节来存放，因此 byte 和对象引用之间就会有 3 字节对齐，对象引用排布后，最后会有 4 字节对齐，因此结果上依然是 7 字节对齐。此时对象的结构示意图，如下图所示：<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C67.png" alt=""></p>
<h2 id="常量池存在的意义"><a href="#常量池存在的意义" class="headerlink" title="常量池存在的意义"></a>常量池存在的意义</h2><h2 id="CPU过高的原因有哪些？"><a href="#CPU过高的原因有哪些？" class="headerlink" title="CPU过高的原因有哪些？"></a>CPU过高的原因有哪些？</h2><p>一直在GC，比如存在内存泄露，导致一直在Full GC。<br>某处造成了死循环，比如JDK1.7之前的HashMap在高并发的情况下会造成死循环<br>CAS操作，可能某一个操作在线程竞争激烈的情况下会一直进行CAS操作，占用CPU</p>
<h2 id="哪些区域会出现OOM？遇见OOM该如何分析？"><a href="#哪些区域会出现OOM？遇见OOM该如何分析？" class="headerlink" title="哪些区域会出现OOM？遇见OOM该如何分析？"></a>哪些区域会出现OOM？遇见OOM该如何分析？</h2><p>JVM内存结构中除了PC寄存器不会发生OOM，其余区域均有可能出现OOM。<br><strong>堆内存溢出：</strong><br>出现Java堆内存溢出时，会报异常堆栈的信息”java.lang.OutOfMemoryError”，然后在该信息后面紧跟提示”Java heap space”。<br>常规的处理方法为首先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析。第一步首先确认内存中导致OOM的对象是否是必要，也就是先确定是出现了内存泄露还是内存溢出。若为内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链，找到泄露对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄露对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的对象。<br>如果不是内存泄露，也就是内存中的对象都是必须存在的，那么就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，看看是否还有向上调整的空间，再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</p>
<p><strong>虚拟机栈和本地方法栈溢出：</strong><br>如果线程请求的栈深度大于虚拟机所允许的最大深度，将会抛出StackOverflowError异常<br>如果虚拟机内存的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将会抛出OutOfMemoryError异常<br>一般来说， 在单线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。<br>程序在不断的创建线程，这可能会产生OutOfMemoryError异常，但是此种情况与栈空间是否足够大并没有任何关系所以要先判断是栈溢出还是内存溢出<br>栈溢出的话还有明确错误堆栈可供分析<br>如果是内存溢出，则只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
<p><strong>方法区和运行时常量池溢出：</strong><br>运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述外，还有一项信息是常量池（Constant Pool TABLE），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。方法区限定大小后，就间接的限制其中常量池的容量。<br>1、常量池中存放大量的String对象，并保持对这些对象的引用，避免Full GC回收常量池，就会产生OutOfMemoryError异常，后面跟的提示信息是“PermGen space”,说明运行时常量池属于方法区。<br>2、方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当产生大量的类去填充满方法区，就会溢出</p>
<p><strong>本机直接内存溢出（-MaxDirectMemorySize）：</strong><br>DirectMemory容量可通过MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值一样。虽然DirectMemory内存溢出时也会抛出内存溢出异常，但它抛出的异常时并没有真正向操作系统申请内存分配，于是手动抛出异常。一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而且程序中又直接或者间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>
<h2 id="JVM的调优工具有哪些？"><a href="#JVM的调优工具有哪些？" class="headerlink" title="JVM的调优工具有哪些？"></a>JVM的调优工具有哪些？</h2><p><strong>可视化工具</strong></p>
<p><a href="http://www.ityouknow.com/jvm/2017/09/22/jvm-tool.html" target="_blank" rel="noopener">http://www.ityouknow.com/jvm/2017/09/22/jvm-tool.html</a></p>
<p><strong>JConsole</strong>：是JDK自带的java监视和管理控制台，用于对JVM中内存，线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监测工具。<br><strong>VisualVM</strong>：是功能强大的运行监视和故障处理程序之一。它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。它除了常规的运行监视，故障处理之外，还提供其他方面的能力，譬如性能分析。还有一个优点：不需要被监视的程序基于特殊地agent去运行，因此它的通用性较强，对应用程序实际的影响也较小。<br><strong>JHSDB</strong>：是一款基于服务性代理实现的进程外调试工具。服务型代理是HotSpot虚拟机中一组用于映射java虚拟机运行信息的、主要基于java语言实现的API集合。可以自一个独立的java虚拟机的进程里分析其他HotSpot虚拟机的内部数据，或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节。<br><strong>Java Mission Control</strong>：可持续在线的监控工具。</p>
<p><strong>命令行工具</strong></p>
<p><a href="http://www.ityouknow.com/jvm/2017/09/03/jvm-command.html" target="_blank" rel="noopener">http://www.ityouknow.com/jvm/2017/09/03/jvm-command.html</a></p>
<p><strong>jps</strong>：虚拟机进程状况工具，显示指定系统内所有HotSpot虚拟机进程<br>命令格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>

<p><strong>jstat</strong>：虚拟机统计信息监视工具，用于监视虚拟机各种运行状态信息的命令行工具，可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。<br>命令格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jstat [option vmid [interval[s|ms] [count]]]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">[option] : 操作参数</span><br><span class="line">VMID : 虚拟机进程ID，如果是本地虚拟机进程VMID与LVMID是一致的；如果是远程虚拟机进程，VMI格式为</span><br><span class="line">[protocol:][&#x2F;&#x2F;]lvmid[@hostname[:port]&#x2F;servername]</span><br><span class="line">[interval] : 连续输出的时间间隔</span><br><span class="line">[count] : 连续输出的次数</span><br></pre></td></tr></table></figure>

<p><strong>jinfo</strong>：Java配置信息工具，用于实时查看和调整虚拟机各项参数。之前jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo命令。<br>命令格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] [args] VMID</span><br></pre></td></tr></table></figure>

<p><strong>jmap</strong>：Java内存映像工具，用于生成堆转储快照（一般称为heapdump或dump文件）。如果不使用该命令，还可用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候自动生成dump文件。jmap不仅能生成dump文件，还可以查询finalize执行队列、java堆和永久代的详细信息，如当前使用率、当前使用的垃圾收集器。<br>命令格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] VMID</span><br></pre></td></tr></table></figure>

<p><strong>jhat</strong>：虚拟机堆转储快照分析工具，该命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。<br>命令格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat [dumpfile]</span><br></pre></td></tr></table></figure>

<p><strong>jstack</strong>：java堆栈跟踪工具，命令用于生成虚拟机当前时刻的线程快照（一般称之为threaddump或者javacore文件）。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。<br>命令格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] vmid</span><br></pre></td></tr></table></figure>



<h2 id="内存泄漏是什么？怎么解决？内存泄漏的场景有哪些？如何处理内存泄漏的场景？-2"><a href="#内存泄漏是什么？怎么解决？内存泄漏的场景有哪些？如何处理内存泄漏的场景？-2" class="headerlink" title="内存泄漏是什么？怎么解决？内存泄漏的场景有哪些？如何处理内存泄漏的场景？*2"></a>内存泄漏是什么？怎么解决？内存泄漏的场景有哪些？如何处理内存泄漏的场景？*2</h2><p><a href="http://www.ityouknow.com/java/2019/05/23/memory-leak.html" target="_blank" rel="noopener">http://www.ityouknow.com/java/2019/05/23/memory-leak.html</a></p>
<p><a href="https://blog.csdn.net/weter_drop/article/details/89387564" target="_blank" rel="noopener">https://blog.csdn.net/weter_drop/article/details/89387564</a></p>
<p>内存泄漏就是指一个不再被程序使用的对象或者变量一直占据在内存中，有可能此对象已经不使用了，但是还有其它对象保持着此对象的引用，就会导致 GC 不能回收此对象，这种情况下就会出现内存泄漏。<br>所以内存泄漏对象的两个特点：<br>1.这些对象的可达的<br>2.这些对象是无用的</p>
<p><strong>内存泄漏场景</strong><br>1.长生命周期的对象持有短生命周期对象的引用就很可能发生泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span>&#123;</span><br><span class="line">    Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的 object 实例，其实我们期望它只作用于 method1() 方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，object 对象所分配的内存不会马上被认为是可以被释放的对象，只有在 Simple 类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。</span></span><br></pre></td></tr></table></figure>

<p>2.集合中的内存泄漏，比如HashMap、ArrayList等，这些对象经常会发生内存泄漏。比如当它们被声明为静态对象时，它们的生命周期会跟应用程序的生命周期一样长，很容器造成内存不足。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</span></span><br></pre></td></tr></table></figure>

<p>3.监听器，如XXXListener()等方法，最后忘记删除<br>4.各种连接，如数据库连接、io连接、网络连接等，最后忘记使用close将其关闭<br>5.内部类和外部模块的引用<br>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：<br>public void registerMsg(Object b);<br>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。<br>也就是说<strong>内部类持有外部类</strong>，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。<br>6.单例模式<br>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">B.getInstance().setA(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B类采用单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> A a;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> B instance=<span class="keyword">new</span> B();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getter...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况</span></span><br></pre></td></tr></table></figure>

<p>7.改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>,<span class="string">"pwd1"</span>,<span class="number">25</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="string">"pwd2"</span>,<span class="number">26</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>,<span class="string">"pwd3"</span>,<span class="number">27</span>);</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:3 个元素!</span></span><br><span class="line">p3.setAge(<span class="number">2</span>); <span class="comment">//修改p3的年龄,此时p3元素对应的hashcode值发生改变</span></span><br><span class="line">set.remove(p3); <span class="comment">//此时remove不掉，造成内存泄漏</span></span><br><span class="line">set.add(p3); <span class="comment">//重新添加，居然添加成功</span></span><br><span class="line">System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:4 个元素!</span></span><br><span class="line"><span class="keyword">for</span> (Person person : set) &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内存溢出 out of memory</strong>，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；</p>
<p><strong>内存泄露 memory leak</strong>，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>
<p>所以内存泄漏可能会导致内存溢出，但内存溢出并不完全都是因为内存泄漏，也有可能使用了太多的大对象导致。</p>
<p><strong>出现内存泄漏</strong>使用内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析。第一步首先确认内存中导致OOM的对象是否是必要，也就是先确定是出现了内存泄露还是内存溢出。若为内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄露对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的对象。然后检查代码更改代码。</p>
<h2 id="如何判断对象需要被回收"><a href="#如何判断对象需要被回收" class="headerlink" title="如何判断对象需要被回收"></a>如何判断对象需要被回收</h2><p><strong>1.引用计数算法</strong><br>在对象中添加一个计数器，每当有个地方引用一次，就增加1，引用失效就减1。当计数器为0时，则代表该对象没有被引用，将会被垃圾回收。但有个缺点就是若存在循环引用，则这两个对象的计数器始终大于1，这样无法完成垃圾回收。</p>
<p><strong>2.可达性分析算法</strong></p>
<p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<br><strong>可以作为GC Roots的对象包括：</strong><br>1.在虚拟栈中引用的对象，比如各个线程的被调用的方法堆栈中使用到的参数、局部变量、临时变量等。<br>2.在方法区中类静态属性引用的对象，比如Java类的引用类型静态变量<br>3.在方法去中常量引用的对象，比如字符串常量池里的引用<br>4.在本地方法栈中JNI(Native方法)引用的对象<br>5.Java虚拟机内部的引用，比如基本数据类型对象的Class对象，一些常驻的异常对象，系统类加载器<br>6.所有被同步锁持有的对象<br>7.反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
<p>要真正判定一个对象可被回收至少要经历两次标记过程。如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。finalize()方法是对象逃脱死亡命运的最后一次机会。</p>
<h2 id="垃圾收集算法-2"><a href="#垃圾收集算法-2" class="headerlink" title="垃圾收集算法*2"></a>垃圾收集算法*2</h2><p><strong>标记-清除算法：</strong>标记无用的对象，标记完成后统一回收；也可以标记有用的对象，标记完成后回收未被标记的对象。<br>优点：实现简单，不需要对象进行移动<br>缺点：效率不稳定；产生内存空间碎片化问题。</p>
<p><strong>标记-复制算法：</strong>将内存分成两块大小一样的区域，每次使用都只使用一块区域。当一块区域内存用完后，将还存活的对象复制到另一块内存上，然后将这个内存的全部清空。<br>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片<br>缺点：空间利用率不高。<br>优化：针对新生代区域，因为新生代中的对象有98%熬不过第一轮的收集，因此不需要1:1的划分新生代的内存空间。而是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。垃圾回收时将Eden和Survivor中仍然存活的对象一次性复制到另一块Survivor空间上。虚拟机默认Eden和Survivor的大小比例是8:1。</p>
<p><strong>标记-整理算法：</strong>在标记可回收的对象后，将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。<br>优点：不存在内存碎片问题<br>缺点：需要对对象进行局部移动，一定程度上降低了效率</p>
<h2 id="为什么分为新生代和老年代"><a href="#为什么分为新生代和老年代" class="headerlink" title="为什么分为新生代和老年代"></a>为什么分为新生代和老年代</h2><p>弱分代假说：绝大多数对象都是朝生夕灭的。强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。分为新生代和老年代是因为，若一个区域内的对象大多数都是朝生夕灭的，则把它们集中在一起，每次回收只用关注如何保留少量存活就能以较低代价回收到大量空间。如果是难以消亡的对象集中在一起，那么虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<h2 id="对象何时晋升到老年代"><a href="#对象何时晋升到老年代" class="headerlink" title="对象何时晋升到老年代"></a>对象何时晋升到老年代</h2><p>1.Eden区满时，进行Minor GC，当Eden和一个Survivor区中依然存活的对象无法放入另一个Survivor中，则通过分配担保机制提前转移到老年代中<br>2.若对象体积太大，新生代无法容纳这个对象，即对象的大小大于 -XX：PretenureSizeThreshold设定的值，就会绕过新生代，直接在老年代分配。此参数只对Serial及ParNew两款收集器有效<br>3.长期存活的对象将进入老年代。JVM对每个对象定义了一个对象年龄计数器，当年龄增加到一定值时，就会晋升到老年代。该值由-XX：MaxTenuringThreshold来设置。如果对象在Eden出生并在第一次发生MinorGC时仍然存活，并且能够被Survivor中所容纳的话，则该对象会被移动到Survivor区，并设置Age = 1；以后每经历一次Minor GC，该对象还存活就Age++。<br>4.动态对象年龄判定。虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄的对象所有大小和超过Survivor区空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</p>
<h2 id="为什么不在新生代使用标记整理算法？或者在老年代使用复制算法？"><a href="#为什么不在新生代使用标记整理算法？或者在老年代使用复制算法？" class="headerlink" title="为什么不在新生代使用标记整理算法？或者在老年代使用复制算法？"></a>为什么不在新生代使用标记整理算法？或者在老年代使用复制算法？</h2><p>新生代中要回收的对象很多，每次将存活对象插到待清理对象之前需要大量移动操作，时间复杂度很高；反观复制算法，不需要移动待回收对象的操作，直接将存活对象复制到另一块空闲内存区域中，大大减小了时间复杂度。</p>
<p>老年代不使用复制算法是因为当老年代存活的对象多，每次复制的开销大，效率不高。</p>
<h2 id="新生代中为什么要分为Eden和Survivor？区域的比例？为什么要设置两个Survivor区？"><a href="#新生代中为什么要分为Eden和Survivor？区域的比例？为什么要设置两个Survivor区？" class="headerlink" title="新生代中为什么要分为Eden和Survivor？区域的比例？为什么要设置两个Survivor区？"></a>新生代中为什么要分为Eden和Survivor？区域的比例？为什么要设置两个Survivor区？</h2><h2 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h2><p>三色标记：<br>白色：表示对象尚未被垃圾收集器访问过，若在分析结束阶段仍然是白色，即代表不可达<br>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色对象代表已经扫描过，它是安全存活的。<br>灰色：表示对象已经被垃圾收集器访问过，但这个对象至少存在一个引用还没有被扫描过</p>
<p>若用户线程和收集器并发工作，则可能会造成两种情况：<br>1.原本消亡的对象错误标记为存活。<br>2.原本存活的对象错误标记为消亡，这是非常危险的。</p>
<p>当且仅当一下两个条件同时满足时，会产生“对象消失“问题，即原本应该是黑色的对象被误标为白色：<br>1.赋值器插入了一条或多条从黑色对象到白色对象的新引用。<br>2.赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p>
<p>解决方案：<br><strong>1.增量更新：</strong>破坏第一个条件。当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发结束后，以该黑色对象为根重新扫描。CMS使用<br><strong>2.原始快照：</strong>破坏第二个条件。当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。G1、Shenandoah使用</p>
<h2 id="何时会触发full-gc"><a href="#何时会触发full-gc" class="headerlink" title="何时会触发full gc"></a>何时会触发full gc</h2><p>1.旧生代空间不足<br>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：<br>java.lang.OutOfMemoryError: Java heap space<br>为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。<br>2.Permanet Generation空间满<br>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<br>java.lang.OutOfMemoryError: PermGen space<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。<br>3.CMS GC时出现promotion failed和concurrent mode failure<br>对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。<br>promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。<br>应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。<br>4.统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间<br>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。<br>例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。<br>5.G1收集器中，若回收速度赶不上内存分配的对象，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生Stop The World。</p>
<h2 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h2><p>CMS基于标记-清除算法实现。整个过程为：<br>初始标记<br>并发标记<br>重新标记<br>并发清除</p>
<p>缺点：<br>1.对处理器资源非常敏感。因为在并发标记阶段，会因为占用了一部分线程而导致应用程序变慢，降低吞吐量<br>2.会产生浮动垃圾，有可能出现“Concurrent Mode Failure”失败导致启用Serial Old进行Full GC，这个过程是十分缓慢的。浮动垃圾就是在并发标记和并发清除的时候，用户程序仍在运行，就会伴随着新的垃圾产生，但是标记阶段已经过去，CMS无法处理，从而产生浮动垃圾。因为产生了浮动垃圾，所以需要预留空间给这个浮动垃圾。CMS在老年代使用了68%空间后就会被激活。但是若是预留的空间无法满足程序分配新对象，则就会出现“Concurrent Mode Failure”。<br>3.产生大量空间碎片，若空间还有很多，但是无法找到一个连续的内存空间来存放大对象，那么仍会触发Full GC。</p>
<h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><p>简称G1，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。它面向的是堆内存任何一个部分来组成回收集，衡量的标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。<br>G1将堆分为大小相等的独立的区域（Region），每个区域可以扮演不同的角色。G1还有一类特殊的Humongous区域，专门存放大对象，G1认为只要超过整个region容量一半的对象可以认为是大对象。<br><strong>垃圾处理思路：</strong>让G1收集器去跟踪各个Region里面的垃圾堆积的价值大小，价值即回收所获的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的那些Region。</p>
<p><strong>关键细节问题</strong><br>1.Region里面存在跨Region引用对象，如何解决？<br>使用记忆集，G1使用的记忆集在存储结构上本质是一种哈希表。比原来的卡表实现复杂。所以G1收集器比其它传统的收集器有着更高的内存占用负担。<br>2.并发标记阶段如何保证收集线程与用户线程互不干扰地运行？<br>使用原始快照的方法。此外垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上。G1为每个Region设计两个名为TAMPS指针，把Region中的一部分空间划出来用于并发回收过程中的新对象分配，并发回收时，新分配的对象地址必须都在这两个指针上。若内存回收速度赶不上内存分配速度，<strong>也会导致Full GC</strong><br>3.怎样建立可靠的停顿预测模型？<br>通过以衰减均值为理论基础来实现，在回收过程中，G1会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费成本，并分析出平均值、标准偏差、置信度等统计信息。</p>
<p><strong>G1收集器运作过程：</strong><br>1.初始标记<br>2.并发标记<br>3.最终标记<br>4.筛选回收：根据各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间（使用参数-XX：MaxGCPauseMillis指定）来制定计划，把决定回收的那一部分Region存活的对象复制到空的Region中，再清理掉整个旧Region的全部空间。</p>
<p><strong>G1与CMS对比：</strong></p>
<p>G1可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集。G1不会产生内存空间碎片。<br>G1为了垃圾收集产生的内存占用和程序运行时的额外执行负载都要比CMS高。G1的记忆集更为复杂，导致会占用很多空间，而CMS的记忆集则比较简单，且只需要处理老年代到新生代的引用<br>G1使用原始快照，相比增量更新能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生有跟踪引用变化带来的额外负担。</p>
<h2 id="什么是Java的内存模型？"><a href="#什么是Java的内存模型？" class="headerlink" title="什么是Java的内存模型？"></a>什么是Java的内存模型？</h2><p><a href="https://www.cnblogs.com/lfs2640666960/p/11019798.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfs2640666960/p/11019798.html</a></p>
<p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>
<p><strong>Java内存模型（Java Memory Model，JMM）</strong>就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了JAVA程序在各种平台下对内存访问都能保证效果一致的机制及规范。<br>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存内保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p>
<p>主内存和工作内存之间的交互通过以下8个操作完成：<br>lock、unlock、read、load、use、assign、store、write</p>
<h2 id="Java如何做到并发三要素的？"><a href="#Java如何做到并发三要素的？" class="headerlink" title="Java如何做到并发三要素的？"></a>Java如何做到并发三要素的？</h2><p>这里应该讲的就是Java内存模型的三个特征：原子性、可见性、有序性</p>
<p><strong>原子性</strong>：指一个操作要么全部完成，要么全部不完成，不可能停滞在中间某个环节。由Java内存模型定义的8种操作：read、load、assign、use、store、write、lock、unlock保证。基本数据类型的访问、读写都是具备原子性的（除了long和double的非原子性协定）使用synchronized也能保证原子性</p>
<p><strong>可见性</strong>：指当一个线程改变了共享变量的值时，其他线程能够立即得知这个修改。volatile修饰的变量可以保证可见性，因为它能保证新值能够立即同步到主内存中，以及每次使用前立即从主内存刷新，而普通变量不能保证，因为不知道何时将修改后的变量写入主存中。synchronized和final变量也能保证可见性。同步块可见性是由对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）这条规则获得。final可见性指被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去（this的引用逃逸是一件比较危险的事）那么在其他线程中就能看见final字段的值。</p>
<p><strong>有序性</strong>：指如果在本线程内观察，所有的操作，代码执行是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。通过volatile和synchronized来保证线程之间操作的有序性。volatile本身包含了禁止指令重排序的语义。synchronized是由一个变量在同一个时刻只允许一条线程对其进行lock操作这条规格获得。</p>
<h2 id="有了解过Volatile么？谈谈你对Volatile的理解"><a href="#有了解过Volatile么？谈谈你对Volatile的理解" class="headerlink" title="有了解过Volatile么？谈谈你对Volatile的理解"></a>有了解过Volatile么？谈谈你对Volatile的理解</h2><p>volatile是一个轻量级的同步机制。一个变量被volatile修饰后拥有两个特性：<br>第一个是可见性。当一个线程对volatile修饰的变量进行操作时，操作后的变化其他线程能够及时得知，而普通变量做不到。volatile修饰的变量在各个线程中是一致的，但是不能保证基于volatile变量的运算在并发在是安全的。如变量的自增运算，其代码只有一条指令，但是编译成字节码文件后，这个指令就变成了4条字节码指令构成。所以在执行这4条字节码指令时，容易出现并发安全问题。<br>由于volatile只能保证可见性，在不符合一下两条规则的运算场景中，仍然要加锁来保证原子性：<br>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。<br>2.变量不需要与其他的状态变量共同参与不变约束</p>
<p>第二个是禁止指令重排序优化，普通变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。Volatile关键字通过内存屏障禁止了指令的重排序。</p>
<h2 id="Volatile如何保证可见性的？以及如何实现可见性的机制。"><a href="#Volatile如何保证可见性的？以及如何实现可见性的机制。" class="headerlink" title="Volatile如何保证可见性的？以及如何实现可见性的机制。"></a>Volatile如何保证可见性的？以及如何实现可见性的机制。</h2><p>被volatile关键字修饰的共享变量在转换成汇编语言时，会加上一个以lock为前缀的指令，该lock前缀指令相当于一个内存屏障：<br>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>2）它会强制将对缓存的修改操作立即写入主存；<br>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。<br>当CPU发现这个指令时，立即做两件事：<br>1.将当前内核高速缓存行的数据立即回写到内存<br>2.使在其他内核里缓存了该内存地址的数据无效<br>第二步通过MESI（缓存一致性）协议来做到。该解决缓存一致性的大致思路是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，那么他会发出信号通知其他CPU将该变量的缓存行设置为无效状态。当其他CPU使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量。</p>
<p> <strong>MESI（缓存一致性协议）是一种保持一致性的协议。</strong>它的方法是在CPU缓存中保存一个标记位，这个标记位有四种状态：</p>
<ul>
<li>M：Modify，修改缓存，当前CPU的缓存已经被修改了，即与内存中数据已经不一致了</li>
<li>E：Exclusive，独占缓存，当前CPU的缓存和内存中数据保持一致，而且其他处理器并没有可使用的缓存数据</li>
<li>S：Share，共享缓存，和内存保持一致的一份拷贝，多组缓存可以同时拥有针对同一内存地址的共享缓存段</li>
<li>I：Invalid，实效缓存，这个说明CPU中的缓存已经不能使用了</li>
</ul>
<p>​    CPU的读取遵循下面几点：</p>
<ul>
<li>如果缓存状态是I，那么就从内存中读取，否则就从缓存中直接读取。</li>
<li>如果缓存处于M或E的CPU读取到其他CPU有读操作，就把自己的缓存写入到内存中，并将自己的状态设置为S。</li>
<li>只有缓存状态是M或E的时候，CPU才可以修改缓存中的数据，修改后，缓存状态变为M。</li>
</ul>
<h2 id="如果大量的使用Volatile存在什么问题？"><a href="#如果大量的使用Volatile存在什么问题？" class="headerlink" title="如果大量的使用Volatile存在什么问题？"></a>如果大量的使用Volatile存在什么问题？</h2><p>可能会增大CPU的开销。</p>
<h2 id="有人说JVM拖累了java效率，你是怎么理解的，JVM的设计理念有哪里让你感觉比较惊艳，感触比较深？（面试官说JVM的推出是为了跨平台，JVM何去何从，怎么演变，及变化趋势）"><a href="#有人说JVM拖累了java效率，你是怎么理解的，JVM的设计理念有哪里让你感觉比较惊艳，感触比较深？（面试官说JVM的推出是为了跨平台，JVM何去何从，怎么演变，及变化趋势）" class="headerlink" title="有人说JVM拖累了java效率，你是怎么理解的，JVM的设计理念有哪里让你感觉比较惊艳，感触比较深？（面试官说JVM的推出是为了跨平台，JVM何去何从，怎么演变，及变化趋势）"></a>有人说JVM拖累了java效率，你是怎么理解的，JVM的设计理念有哪里让你感觉比较惊艳，感触比较深？（面试官说JVM的推出是为了跨平台，JVM何去何从，怎么演变，及变化趋势）</h2><p>JVM的设计理念为平台无关性 和 语言无关性</p>
<h2 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制"></a>如何打破双亲委派机制</h2><p>此时需要自定义一个类加载器，继承ClassLoader类，然后重写父类的findClass方法和loadClass方法。即</p>
<p>1、自定义一个类加载器，继承ClassLoader类</p>
<p>2、重写findClass方法和loadClass方法</p>
<p>这里最主要的是重写loadclass方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了<br><a href="https://www.jianshu.com/p/a03668aaf5a5" target="_blank" rel="noopener">https://www.jianshu.com/p/a03668aaf5a5</a></p>
<h2 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h2><p>强软弱虚引用<br><strong>强引用：</strong>是最传统的引用，指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系，其中obj有一个强引用指向new Object()。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。<br><strong>软引用：</strong>当一个对象被一个软引用所指向的时候，只有系统内存不够用的时候才会被回收，java中有SoftReference类。使用场景：缓存，如在缓存中存放了一个数据，用完后不再使用。当缓存满时，就可以将其清除。<br><strong>弱引用：</strong>只要遇到gc就会被回收，java中有WeakReference类。作用：当有一个强引用指向这个弱引用，那么只要强引用被回收这个弱引用也会被回收，所以只要这个强引用消失，就不会再去管这个弱引用，因为整个弱引用也肯定会被回收。这种引用一般用在容器中。<br><strong>虚引用：</strong>它就做一件事，就是管理堆外内存，java中有PhantomReference类。加假如有一个虚引用指向堆外内存中的对象，当这个虚引用消失了，要对堆外内存的对象回收，但是java中的GC不能去回收堆外内存，所以虚引用的作用就是没有引用了就发出一个通知，调用者去处理回收堆外内存。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="synchronized的底层原理"><a href="#synchronized的底层原理" class="headerlink" title="synchronized的底层原理"></a>synchronized的底层原理</h2><p><a href="https://blog.csdn.net/javazejian/article/details/72828483#synchronized底层语义原理" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483#synchronized%E5%BA%95%E5%B1%82%E8%AF%AD%E4%B9%89%E5%8E%9F%E7%90%86</a></p>
<p><a href="https://www.cnblogs.com/aspirant/p/11470858.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/11470858.html</a></p>
<p><strong>首先要理解Java对象头与Monitor</strong><br>在JVM中，Java对象在内存中布局分为3个部分：对象头、实体数据、对齐填充。这里主要关注对象头，它是实现synchronized的基础。一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit）来存储对象头(如果对象是数组则会分配3个机器码，多出来的1个机器码记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下表：</p>
<table>
<thead>
<tr>
<th>虚拟机位数</th>
<th>头对象结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32/64bit</td>
<td>Mark Word</td>
<td>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Class Metadata Address</td>
<td>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</td>
</tr>
</tbody></table>
<p>其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>4bit</th>
<th>1bit是否是偏向锁</th>
<th>2bit 锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁状态</td>
<td>对象HashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table>
<p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构：<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C17.png" alt=""><br>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C18.png" alt=""></p>
<p>不同锁状态对应的对象头存储的信息不同。这里的重量级锁也就是通常说的synchronized的对象锁，锁标识位为10。<strong>其指向互斥量的指针指向的是monitor对象的起始地址。</strong>每个对象都存在着一个monitor与之关联，当一个monitor被某个线程池持有后，便处于锁定状态。在Java虚拟机中，monitor是由ObjectMonitor实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ObjectMonitor中有两个队列，<strong>_WaitSet</strong> 和 <strong>_EntryList</strong>，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，<strong>_owner</strong>指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C19.png" alt=""></p>
<p>由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因</p>
<p><strong>synchronized代码块底层原理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//同步代码库</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码使用javap反编译得到字节码，部分字节码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===========主要看看syncTask方法实现================</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter  <span class="comment">//注意此处，进入同步方法</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: dup</span><br><span class="line">         6: getfield      #2             // Field i:I</span><br><span class="line">         <span class="number">9</span>: iconst_1</span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        11: putfield      #2            // Field i:I</span><br><span class="line">        <span class="number">14</span>: aload_1</span><br><span class="line">        <span class="number">15</span>: monitorexit   <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">        <span class="number">19</span>: astore_2</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">22</span>: aload_2</span><br><span class="line">        <span class="number">23</span>: athrow</span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">      <span class="comment">//省略其他字节码.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字节码中可以看出同步语句块的实现使用的是<strong>monitorenter 和 monitorexit 指令</strong>，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 <strong>objectref</strong>(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入<strong>计数器</strong>为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令</p>
<p><strong>synchronized方法底层原理</strong><br>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">           i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap反编译，部分结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略没必要的字节码</span></span><br><span class="line">  <span class="comment">//==================syncTask方法======================</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    <span class="comment">//方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field i:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field i:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字节码中可以看出，synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>在Java早期版本中，synchronized属于重量级锁，效率低下，<strong>因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁。</p>
<h2 id="synchronized锁状态的转换"><a href="#synchronized锁状态的转换" class="headerlink" title="synchronized锁状态的转换"></a>synchronized锁状态的转换</h2><p><a href="https://www.cnblogs.com/jhxxb/p/10983788.html以及深入理解Java虚拟机P481-P484" target="_blank" rel="noopener">https://www.cnblogs.com/jhxxb/p/10983788.html以及深入理解Java虚拟机P481-P484</a></p>
<p>锁的状态有4中：无锁状态、偏向锁、轻量级锁和重量级锁，锁可以升级不能降级。</p>
<p><strong>一个线程来访问一个对象时，首先判断是否偏向锁可不可用</strong>，若可用，则该对象会被虚拟机将对象头中的标志位设为01，把偏向模式设为1表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（如加锁，解锁，Mark Word更新等）。</p>
<p>当出现另外一个线程去尝试获取这个锁时，偏向模式就立马结束，根据锁对象是否处于被锁定状态来决定将对象头设置成无锁状态（01）还是轻量级锁状态（00）。若处于轻量级锁状态，说明以及执行轻量级加锁流程，若处于无锁状态，那么<strong>接下来就要进行轻量级加锁流程</strong></p>
<p>这时虚拟机首先会在当前栈帧中建立一个Lock Record用于存储锁对象目前的Mark Word拷贝。然后JVM使用CAS尝试将锁对象Mark Word更新为指向Lock Record的指针，如果更新成功，即代表该线程拥有该对象的锁，对象的Mark Word中的锁标志位将会改为00，执行代码内容。若更新失败，则会检查对象的Mark Word是否指向当前线程，若指向当前线程，则说明该线程已获得锁，直接指定代码，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁，则轻量级锁不再有效，<strong>膨胀为重量级锁</strong>，锁标记变为10，Mark Word指针指向重量级锁。</p>
<p>释放轻量级锁也是通过 CAS 操作来进行，如果对象的 Mark Word 仍然指向着线程的 Lock Record，那就用 CAS 操作把当前线程栈中的 Displaced Mark Word 拷贝回对象的 Mark Word 中。替换成功，即释放锁完成，整个同步过程也就完成了。替换失败，说明有其它线程（此时线程数 &gt; 2）尝试过获取该锁（此时已经膨胀为重量级锁），那就直接释放锁，并唤醒被挂起（阻塞）的线程。<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C20.png" alt=""></p>
<h2 id="一般创建线程的几种方式"><a href="#一般创建线程的几种方式" class="headerlink" title="一般创建线程的几种方式"></a>一般创建线程的几种方式</h2><p><strong>1.创建Thread类的子类</strong>，复写run方法，然后在主函数中创建该类。调用start方法<br><strong>2.实现Runnable接口</strong>，复写run方法。在主函数中创建Thread对象并传入实现该接口的对象。<br><strong>3.实现Callable接口创建线程</strong>，复写call方法。相较于实现Runnable接口的方式，方法可以有返回值，并且可以抛出异常。执行Callable方式，需要FutureTask实现类的支持用于接收运算结果。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一、创建执行线程的方式三：实现Callable接口。相较于实现Runnable接口的方式，方法可以有返回值，并且可以抛出异常</span></span><br><span class="line"><span class="comment">* 二、执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果         </span></span><br><span class="line">        FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.接收线程运算后的结果</span></span><br><span class="line">        Integer sum;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等所有线程执行完，获取值，因此FutureTask 可用于 闭锁</span></span><br><span class="line">            sum = result.get();</span><br><span class="line">            System.out.println(<span class="string">"-----------------------------"</span>);</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Future模式：Future模式是非阻塞的，客户端请求服务端后，服务端只需要创建一个工作线程，然后马上返回了，而这个过程耗时很短，不会阻塞client，client在这期间可以去处理其他任务，当需要的时候向工作进程获取结果。在JDK中的Future模式中，最重要的是FutureTask类，它实现了Runnable接口，可以作为单独的线程运行。在其run()方法中，通过Sync内部类，调用Callable接口，并维护Callable接口的返回对象。当使用FutureTask.get()时，将返回Callable接口的返回对象。FutureTask还可以对任务本身进行其他控制操作。</p>
<p><strong>4.使用线程池创建线程</strong></p>
<h2 id="介绍一下线程池"><a href="#介绍一下线程池" class="headerlink" title="介绍一下线程池"></a>介绍一下线程池</h2><p> 为了避免系统频繁地创建和销毁线程，我们可以让创建的线程复用。因为花费在创建和销毁新线程上的时间和资源比花在处理实际用户请求上的时间和资源更多。所以为了解决线程生命周期开销问题和系统资源不足的问题，通过对多个任务重用线程，线程创建的开销就分摊到多个任务上，而且由于在请求到达时线程已经存在，所以消除了创建线程带来的延迟。</p>
<p>线程池的优势：<br>1.降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；<br>2.提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；<br>3.方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。<br>4.提供更强大的功能，延时定时线程池</p>
<h2 id="线程池创建的方法有哪些（线程池的主要参数），如果没有达到设定最大线程数，等待队列满了如何进行操作"><a href="#线程池创建的方法有哪些（线程池的主要参数），如果没有达到设定最大线程数，等待队列满了如何进行操作" class="headerlink" title="线程池创建的方法有哪些（线程池的主要参数），如果没有达到设定最大线程数，等待队列满了如何进行操作"></a>线程池创建的方法有哪些（线程池的主要参数），如果没有达到设定最大线程数，等待队列满了如何进行操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在Executors类中，提供了以下创建线程池的方法</span><br><span class="line"><span class="comment">//返回一个固定线程数量的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个只有一个线程的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个可根据实际情况调整线程数量的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个ScheduledExecutorService对象，线程池大小为1。ScheduledExecutorService接口在ExecutorService接口之上，扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个ScheduledExecutorService对象，但该线程池可以指定线程数量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledTreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>

<p>线程池的主要参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">corePoolSize:指定线程池中的线程数量</span></span></span><br><span class="line"><span class="function"><span class="comment">maximumPoolSize:线程池中最大线程数量</span></span></span><br><span class="line"><span class="function"><span class="comment">keepAliveTime:线程存活时间。当线程池数量超过corePoolSize时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</span></span></span><br><span class="line"><span class="function"><span class="comment">unit:keepAliveTime的单位</span></span></span><br><span class="line"><span class="function"><span class="comment">workQueue:任务队列，被提交但尚未被执行的任务。</span></span></span><br><span class="line"><span class="function"><span class="comment">threadFactory:线程工厂，用于创建线程，一般用默认的即可threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</span></span></span><br><span class="line"><span class="function"><span class="comment">handler:拒绝策略，当任务太多来不及处理时，如何拒绝任务。</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure>

<p><strong>如果没有达到设定最大线程数，等待队列满了如何进行操作</strong></p>
<p>如果是有界队列，则会在线程池中直接创建线程执行任务。<br>如果是无界队列，则会执行拒绝策略，此时系统内存已经耗尽。</p>
<p>==但需要注意的是，在线程池刚创建时，里面并没有建好的线程，只有当有任务来的时候才会创建==</p>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p><a href="https://blog.csdn.net/he90227/article/details/52576452" target="_blank" rel="noopener">https://blog.csdn.net/he90227/article/details/52576452</a></p>
<p><strong>线程池的状态</strong><br>在ThreadPoolExecutor中定义了一个Volatile变量 runState 表示线程池的当前状态，使用volatile保证线程之间的可见性，另外定义了几个static final变量表示线程池的各个状态。<br>当创建线程池后，初始时，线程池处于<strong>RUNNING状态</strong>；<br>如果<strong>调用了shutdown()方法，则线程池处于SHUTDOWN状态</strong>，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br>如果<strong>调用了shutdownNow()方法，则线程池处于STOP状态</strong>，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<strong>TERMINATED状态。</strong></p>
<p><strong>任务执行</strong><br>任务执行主要的方法是execute()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//判断当前线程数量是否大于核心线程数或者加入新请求时，线程数是否小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="comment">//判断线程池的状态是否是RUNNING状态以及判断是否能够成功加入等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">//这里判断是防止在将此任务添加进等待队列时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池</span></span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否添加时小于最大线程数量。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br>1）首先，要清楚corePoolSize和maximumPoolSize的含义；<br>2）其次，要知道Worker是用来起到什么作用的；<br>3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</p>
<ul>
<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>
<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>
</ul>
<p><strong>线程池中的线程初始化</strong><br>默认情况下，创建线程后线程池中是没有线程的，需要提交任务之后才会创建线程<br>如果需要创建线程池之后立即创建线程，可以通过prestartCoreThread()初始化一个核心线程和prestartAllCoreThreads()初始化所有核心线程来完成</p>
<p><strong>配置线程池的大小</strong><br>如果是计算密集型的，则参考值为CPU数量+1<br>如果是IO密集型的，则参考值为CPU数量*2<br>计算密集型需要尽量少的线程，因为这样会减少上下文切换等比较消耗时间的操作，使得计算速度加快。IO密集型容易出现较多的空闲CPU，所以可以增加线程数量使CPU不那么空闲<br>也可以根据公式：((线程等待时间/线程运行时间)+1) * CPU数量</p>
<h2 id="最大空闲时间是用来做什么的？"><a href="#最大空闲时间是用来做什么的？" class="headerlink" title="最大空闲时间是用来做什么的？"></a>最大空闲时间是用来做什么的？</h2><p>见上面对keepAliveTime的解释</p>
<h2 id="阻塞队列有哪些"><a href="#阻塞队列有哪些" class="headerlink" title="阻塞队列有哪些"></a>阻塞队列有哪些</h2><h2 id="线程池的submit策略操作如何实现"><a href="#线程池的submit策略操作如何实现" class="headerlink" title="线程池的submit策略操作如何实现"></a>线程池的submit策略操作如何实现</h2><p><a href="https://www.cnblogs.com/by-my-blog/p/10779333.html" target="_blank" rel="noopener">https://www.cnblogs.com/by-my-blog/p/10779333.html</a></p>
<p>线程池的submit方法是将任务作为参数传入，线程执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>前两个方法均可以获得返回值，最后一个方法不能获得返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于Callable通过submit提交后，通过newTaskFor方法会被包装成RunnableFuture，其中RunnableFuture接口继承了Runnable和Future接口。然后将ftask作为参数传入execute方法执行，这里面会调用ftask的run方法。然后这对象的run方法会调用其call方法。最后submit方法返回ftask。调用RunnableFuture类型ftask的get方法可以得到返回值。</p>
<h2 id="线程池的饱和策略（拒绝策略）"><a href="#线程池的饱和策略（拒绝策略）" class="headerlink" title="线程池的饱和策略（拒绝策略）"></a>线程池的饱和策略（拒绝策略）</h2><p>当线程池的等待队列已经排满，且线程池数量达到设置的最大值，则会进行拒绝策略也就是饱和策略。<br>AbortPolicy：该策略会直接抛出异常，阻止系统正常工作。<br>CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是任务提交线程的性能极有可能会急剧下降<br>DiscardOldestPolicy：该策略将丢弃最老的一个请求，也就是即将诶执行的一个任务，并尝试再次提交当前任务<br>DiscardPolicy：该策略默默丢弃无法处理的任务，不予任何处理。</p>
<h2 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h2><p>悲观锁：就是每次对数据进行操作时总是以最坏的情况去考虑。所以每次拿数据都要加上锁，这样其他线程想要去拿这个数据就会被阻塞。<br>乐观锁：就是每次对数据进行操作时总是以最好的情况去考虑。在最后提交的时候会判断一下在修改期间是否有别的线程进行了改动，如果没有就成功提交，如果有则驳回操作，重新修改。多适用于读的环境</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><a href="https://blog.csdn.net/mulinsen77/article/details/84583716" target="_blank" rel="noopener">https://blog.csdn.net/mulinsen77/article/details/84583716</a><br><a href="https://www.jianshu.com/p/0f876ead2846" target="_blank" rel="noopener">https://www.jianshu.com/p/0f876ead2846</a><br><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017372067</a></p>
<p><strong>AQS指的是AbstractQueueSynchronizer（抽象的队列式同步器）</strong>，它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p>
<p><strong>AQS的核心思想是</strong>：如果被请求的共享资源空间空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，<strong>这个机制AQS是用CLH队列锁实现的</strong>，即将暂时获取不到锁的线程加入到队列中，这个队列是双向链表。<strong>AQS是用CAS去操作队列的head和tail，用CAS操作代替了锁整条双链链表的操作</strong><br>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p>
<p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
<p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p>
<p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong><br>AQS实现的具体方式如下：<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C21.png" alt=""></p>
<p>如图所示，AQS维护了一个<strong>volatile int state</strong>和<strong>一个FIFO线程等待队列</strong>，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：<br><strong>getState();setState();compareAndSetState();</strong></p>
<p><strong>AQS 定义了两种资源共享方式：</strong><br>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p>
<p>不同的自定义的同步器争用共享资源的方式也不同。</p>
<h5 id="AQS底层使用了模板方法模式"><a href="#AQS底层使用了模板方法模式" class="headerlink" title="AQS底层使用了模板方法模式"></a>AQS底层使用了模板方法模式</h5><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</li>
</ol>
<p>自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：<br><strong>isHeldExclusively()：</strong>该线程是否正在独占资源。只有用到condition才需要去实现它。<br><strong>tryAcquire(int)：</strong>独占方式。尝试获取资源，成功则返回true，失败则返回false。<br><strong>tryRelease(int)：</strong>独占方式。尝试释放资源，成功则返回true，失败则返回false。<br><strong>tryAcquireShared(int)：</strong>共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br><strong>tryReleaseShared(int)：</strong>共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
<p><strong>ReentrantLock</strong>为例，（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。<br>注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。</p>
<p>以<strong>CountDownLatch</strong>为例，任务分N个子线程去执行，state就初始化 为N，N个线程并行执行，每个线程执行完之后countDown（）一次，state就会CAS减一。当N子线程全部执行完毕，state=0，会unpark()主调用线程，主调用线程就会从await()函数返回，继续之后的动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时<strong>实现独占和共享两种方式，如ReentrantReadWriteLock。</strong><br>　在acquire() acquireShared()两种方式下，线程在等待队列中都是忽略中断的，<strong>acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断</strong>的。</p>
<h2 id="讲一下ThreadLocal"><a href="#讲一下ThreadLocal" class="headerlink" title="讲一下ThreadLocal"></a>讲一下ThreadLocal</h2><p><a href="https://www.jianshu.com/p/3c5d7f09dfbd" target="_blank" rel="noopener">https://www.jianshu.com/p/3c5d7f09dfbd</a></p>
<p><a href="https://www.jianshu.com/p/a1cd61fa22da" target="_blank" rel="noopener">https://www.jianshu.com/p/a1cd61fa22da</a></p>
<p>ThreadLcoal是线程本地的意思。一个线程的ThreadLocal只有该线程本身可以访问到ThreadLocal里面的存放的对象，其他线程是无法访问的，且其他线程也只能访问自己的ThreadLocal。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>使用set方法将对象存入，通过源码发现，这里会通过当前线程拿到一个容器，即ThreadLocalMap，这是一个键值对容器，key设置的是当前的ThreadLocal，value就是要存入的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>点进去getMap(t)方法，发现返回的是一个t.threadLocals，说明ThreadLocalMap属于当前线程t的。所以是只有线程自己可以访问到这个ThreadLocalMap，也就意味着存在这个ThreadLocalMap里的对象只有当前线程可以访问。<br>ThreadLocalMap里面存放的table是一个Entry类型的数组，Entry是一个键值对类，是ThreadLocalMap的静态内部类，对ThreadLocal的弱引用。在实例化ThreadLocalMap时创建了一个长度为16的Entry数组。通过ThreadLocal对象的hashcode与数组长度 - 1的位运算得到该ThreadLocal存放的数组的位置索引，以ThreadLocal为键，要存入的值为值存入。<br>对于某一个ThreadLocal来讲，它的索引值i是确定的，在不同线程之间访问时访问的是不同的table数组的同一位置即都为table[i]，只不过这个不同线程之间的table是独立的<br>对于同一线程的不同ThreadLocal来讲， 这些ThreadLocal实例共享同一个table数组，然后每个ThreadLocal实例在table中的索引i是不同的。</p>
<p>使用ThreadLocal中的ThreadLocalMap存储对象需要注意如果不再使用这个对象，则需要及时使用remove方法回收，不然可能会造成内存泄露。<br>也可以将对ThreadLocal的引用设为null回收，如一开始是ThreadLocal tl = new ThreadLocal()；然后写为tl = null，即可将ThreadLocalMap中Entry键为该ThreadLocal回收，使得该键变为null。因为ThreadLocalMap中Entry键的引用实现使用的是弱引用，当ThreadLocal外部强引用被回收时，ThreadLocalMap中的key值就会变成null。但是key变为null，该key还是存在的，对应的value也是存在的，只是再也无法访问到。所以也必须要对该key进行回收，否则就会造成内存泄露。所以要用remove方法对key移除。</p>
<h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><h2 id="读写锁介绍一下？并手写一个读写锁"><a href="#读写锁介绍一下？并手写一个读写锁" class="headerlink" title="读写锁介绍一下？并手写一个读写锁"></a>读写锁介绍一下？并手写一个读写锁</h2><h2 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h2><p><a href="https://blog.csdn.net/weixin_39910081/article/details/80147754" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39910081/article/details/80147754</a><br><a href="https://www.jianshu.com/p/f47250702ee7" target="_blank" rel="noopener">https://www.jianshu.com/p/f47250702ee7</a><br><a href="https://www.jianshu.com/p/22312267fefe" target="_blank" rel="noopener">https://www.jianshu.com/p/22312267fefe</a></p>
<p>ReentrantLock实现了Lock接口，内部有三个内部类，Sync、NonfairSync、FairSync，Sync是一个抽象类型，它继承AbstractQueuedSynchronizer，这个AbstractQueuedSynchronizer是一个模板类，它实现了许多和锁相关的功能，并提供了钩子方法供用户实现，比如tryAcquire，tryRelease等。Sync实现了AbstractQueuedSynchronizer的tryRelease方法。NonfairSync和FairSync两个类继承自Sync，实现了lock方法，然后分别公平抢占和非公平抢占针对tryAcquire有不同的实现。</p>
<p><strong>非公平锁lock方法详细描述</strong><br>1.在初始化ReentrantLock的时候，不传参数是否公平则默认使用非公平锁，也就是NonfairSync。<br>2.当调用ReentrantLock的lock方法时，实际上是调用了NonfairSync的lock方法，这个方法<strong>先用CAS操作去尝试抢占该锁</strong>。如果成功，就把当前线程设置在这个锁上，表示抢占成功。如果失败，则调用acquire模板方法，等待抢占<br>3.调用acquire(1)实际上使用的是AbstractQueuedSynchronizer的acquire方法，它是一套锁抢占的模板，<strong>总体原理</strong>是先去尝试获取锁，如果没有获取成功，就在CHL队列中增加一个当前线程的节点，表示等待抢占。然后进入CLH队列的抢占模式，进入的时候也会去执行一次获取锁的操作，如果还是获取不到，就调用LockSupport.park将当前线程挂起。那么当前线程什么时候会被唤醒呢？当持有锁的那个线程调用unlock的时候，会将CLH队列的头节点的下一个节点上的线程唤醒，调用的是LockSupport.unpark方法。acquire代码比较简单，具体如下：<br>    3.1 acquire方法内部先使用<strong>tryAcquire这个钩子方法</strong>去尝试再次获取锁，这个方法在NonfairSync这个类中其实就是使用了nonfairTryAcquire，<strong>具体实现原理</strong>是先比较当前锁的状态是否是0，如果是0，则尝试去原子抢占这个锁（设置状态为1，然后把当前线程设置成独占线程），如果当前锁的状态不是0，就去比较当前线程和占用锁的线程是不是一个线程，如果是，会去增加状态变量的值，从这里可以看出可重入锁就是同一个线程可以反复使用它占用的锁，如果以上两种情况都不通过，则返回失败false。<br>    3.2 tryAcquire一旦返回false，就会则进入<strong>acquireQueued</strong>流程，也就是基于CLH队列的抢占模式<br>        3.2.1 首先，在CLH锁队列尾部增加一个等待节点，这个节点保存了当前线程，通过调用addWaiter实现，这里<strong>需要考虑初始化的情                  况</strong>，在第一个等待节点进入的时候，需要初始化一个头节点然后把当前节点加入到尾部，后续则直接在尾部加入节点就行了。<br>        3.2.2 将节点增加到CLH队列后，进入acquireQueued方法。首先，外层是一个无限for循环，如果当前节点是头节点的下个节点，并                 且通过tryAcquire获取到了锁，说明头节点已经释放了锁，当前线程是被头节点那个线程唤醒的，这时候就可以将当前节点设置                 成头节点，并且将failed标记设置成false，然后返回。至于上一个节点，它的next变量被设置为null，在下次GC的时候会清理                 掉。如果本次循环没有获取到锁，就进入线程挂起阶段，也就是<strong>shouldParkAfterFailedAcquire</strong>这个方法。<br>        3.2.3 如果尝试获取锁失败，就会进入shouldParkAfterFailedAcquire方法，会判断当前线程是否挂起，如果前一个节点已经是                 SIGNAL状态，则当前线程需要挂起。如果前一个节点是取消状态，则需要将取消节点从队列移除。如果前一个节点状态是其他                 状态，则尝试设置成SIGNAL状态，并返回不需要挂起，从而进行第二次抢占。完成上面的事后进入挂起阶段。<br>        3.2.4 当进入挂起阶段，会进入parkAndCheckInterrupt方法，则会调用LockSupport.park(this)将当前线程挂起。</p>
<p><strong>非公平锁的unlock方法</strong><br>1.调用unlock方法，其实就是直接调用AbstractQueuedSynchronizer的release操作<br>2.进入release方法，内部先尝试tryRelease操作，主要是去除锁的独占线程，然后将状态减一，这里减一主要是考虑可重入锁可能自身会多次占用锁，只有当状态变成0，才表示完全释放了锁<br>3.一旦tryRelease成功，则将CHL队列的头节点的状态设置为0，然后唤醒下一个非取消的节点线程<br>4.一旦下一个节点的线程被唤醒，被唤醒的线程就会进入到acquireQueued代码流程中，去获取锁</p>
<p><strong>公平锁和非公平锁的区别</strong><br>公平锁和非公平锁在CHL队列抢占模式上都是一致的，也就是在进入acquireQueued这个方法之后都一样，他们的区别在初次抢占上有区别，也就是tryAcquire上的区别，下面是两者内部调用关系的简图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NonfairSync</span><br><span class="line">lock —&gt; compareAndSetState</span><br><span class="line">                | —&gt; setExclusiveOwnerThread</span><br><span class="line">      —&gt; accquire</span><br><span class="line">             | —&gt; tryAcquire</span><br><span class="line">                           |—&gt;nonfairTryAcquire</span><br><span class="line">                |—&gt; acquireQueued</span><br><span class="line"></span><br><span class="line">FairSync</span><br><span class="line">lock —&gt; acquire</span><br><span class="line">               | —&gt; tryAcquire</span><br><span class="line">                           |—&gt;!hasQueuePredecessors</span><br><span class="line">                           |—&gt;compareAndSetState</span><br><span class="line">                           |—&gt;setExclusiveOwnerThread</span><br><span class="line">               |—&gt; acquireQueued</span><br></pre></td></tr></table></figure>

<p>区别就是公平锁多了hasQueuePredecessors这个方法，这个方法用于判断CHL队列中是否有节点，对于公平锁，如果CHL队列有节点，则新进入竞争的线程一定要在CHL上排队，而非公平锁则是无视CHL队列中的节点，直接进行竞争抢占，这就有可能导致CHL队列上的节点永远获取不到锁。</p>
<h2 id="synchronized和重入锁的区别"><a href="#synchronized和重入锁的区别" class="headerlink" title="synchronized和重入锁的区别"></a>synchronized和重入锁的区别</h2><p><a href="https://blog.csdn.net/hefenglian/article/details/82383569" target="_blank" rel="noopener">https://blog.csdn.net/hefenglian/article/details/82383569</a></p>
<p>1.synchronized是java的一个关键字，synchronized是在jvm层面上。lock是一个接口<br>2.<strong>锁的释放：</strong>获取synchronized锁的线程执行完同步代码会释放锁，或者线程执行发生异常，jvm会让线程释放锁。lock发生异常时不会主动释放锁，必须手动unlock来释放锁，可能引起死锁的发生，所以在finally中必须释放锁。<br>3.<strong>是否响应中断：</strong>lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断。<br>4.<strong>锁的获取：</strong>synchronized中，假设A线程获取了锁，B线程等待。如果A线程阻塞，B线程就会一直等待。而对于lock来说，B线程中断自己或者别的线程去中断它，但是ReentrantLock不去响应，继续让B线程等待；也可以ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。<br>5.是否知道获取锁：Lock可以通过trylock来知道有没有获取锁，而synchronized不能<br>6.synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度<br>7.<strong>synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。</strong>独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。<br><strong>而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作</strong>（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。<br>现代的CPU提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。<br>8.Synchronized就是<strong>内置锁</strong>，是java语言特性提供的内置锁，其获得锁和释放锁是<strong>隐式</strong>的（进入代码块就是获得锁，走出代码就是释放锁）。java.util.concurrent.locks 包中的锁是<strong>显式锁</strong>，需要进行lock和unlock。</p>
<h2 id="实现线程同步的方法"><a href="#实现线程同步的方法" class="headerlink" title="实现线程同步的方法"></a>实现线程同步的方法</h2><p>使用synchronized关键字，可以修饰方法、代码块<br>使用ReentrantLock<br>使用volatile轻量级同步机制<br>使用ThreadLocal<br>使用原子变量，java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL的整体结构"><a href="#MySQL的整体结构" class="headerlink" title="MySQL的整体结构"></a>MySQL的整体结构</h2><p>连接池、缓存、接口、解析器、优化器、执行引擎</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C16.png" alt=""></p>
<h2 id="inner-join、right-join、left-join的区别"><a href="#inner-join、right-join、left-join的区别" class="headerlink" title="inner join、right join、left join的区别"></a>inner join、right join、left join的区别</h2><p>inner join是内连接，得到的结果是两张表的并集<br>right join是右连接，得到的结果是右表的全部以及左表中符合条件的内容，不符合的显示为null<br>left join是左连接，得到的结果是左表的全部以及右表中符合条件的内容，不符合的显示为null</p>
<h2 id="MySQL的底层索引结构，InnoDB里面的B-Tree？"><a href="#MySQL的底层索引结构，InnoDB里面的B-Tree？" class="headerlink" title="MySQL的底层索引结构，InnoDB里面的B+Tree？"></a>MySQL的底层索引结构，InnoDB里面的B+Tree？</h2><p>MySQL底层索引结构是B+树。B+树是一个多路二叉树。其非叶子节点不存储数据，只保存索引和指针。<br>叶子节点包含所有索引字段；<br>叶子节点比b树增加了指针连接；<br>叶子节点有双向指针链接(首尾子节点还通过指针连接)，提高区间访问的性能，范围查找；</p>
<h2 id="InnoDB和MyISAM区别"><a href="#InnoDB和MyISAM区别" class="headerlink" title="InnoDB和MyISAM区别"></a>InnoDB和MyISAM区别</h2><p>MyISAM不支持外键，不支持事务。采用表锁，并发性能不好。只缓存索引，不缓存数据<br>InnoDB支持外键，支持事务。采用行锁，并发性能好。不仅缓存索引，还缓存数据，对内存要求高。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MyISAM</th>
<th align="center">Innodb</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储结构</td>
<td align="center">每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td align="center">所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td align="center">存储空间</td>
<td align="center">MyISAM可被压缩，存储空间较小</td>
<td align="center">InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td align="center">可移植性、备份及恢复</td>
<td align="center">由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td align="center">免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td align="center">文件格式</td>
<td align="center">数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td align="center">数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td align="center">记录存储顺序</td>
<td align="center">按记录插入顺序保存</td>
<td align="center">按主键大小有序插入</td>
</tr>
<tr>
<td align="center">外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">事务</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td align="center">表级锁定</td>
<td align="center">行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td align="center">SELECT</td>
<td align="center">MyISAM更优</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">INSERT、UPDATE、DELETE</td>
<td align="center"></td>
<td align="center">InnoDB更优</td>
</tr>
<tr>
<td align="center">select count(*)</td>
<td align="center">myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">索引的实现方式</td>
<td align="center">B+树索引，myisam 是堆表</td>
<td align="center">B+树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td align="center">哈希索引</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
</tbody></table>
<h2 id="InnoDB是通过什么支持事务的？"><a href="#InnoDB是通过什么支持事务的？" class="headerlink" title="InnoDB是通过什么支持事务的？"></a>InnoDB是通过什么支持事务的？</h2><h2 id="B-Tree-和-B-Tree的区别-3"><a href="#B-Tree-和-B-Tree的区别-3" class="headerlink" title="B Tree 和 B+ Tree的区别*3"></a>B Tree 和 B+ Tree的区别*3</h2><p>B Tree非叶子节点包含数据和指针，叶子节点指针为空<br>B+ Tree非叶子节点不包含数据，只包含指针，叶子节点包含数据以及双向指针，方便数据范围查找。</p>
<h2 id="数据库表删除数据，B-树的空洞问题。"><a href="#数据库表删除数据，B-树的空洞问题。" class="headerlink" title="数据库表删除数据，B+树的空洞问题。"></a>数据库表删除数据，B+树的空洞问题。</h2><h2 id="如何用select语句创建索引（可能记错，是如何用SQL语句创建）？"><a href="#如何用select语句创建索引（可能记错，是如何用SQL语句创建）？" class="headerlink" title="如何用select语句创建索引（可能记错，是如何用SQL语句创建）？"></a>如何用select语句创建索引（可能记错，是如何用SQL语句创建）？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1.使用create index创建索引</span><br><span class="line">create [unique] index idxname on tablename(colname1,colname2...);</span><br><span class="line">#2.创建表时创建索引</span><br><span class="line">create table tablename(</span><br><span class="line">id INT auto_increment PRIMARY KEY,#主键索引</span><br><span class="line">	first_name VARCHAR (16),</span><br><span class="line">	last_name VARCHAR (16),</span><br><span class="line">	id_card VARCHAR (18),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),#符合索引</span><br><span class="line">	FULLTEXT KEY (information),#全文索引</span><br><span class="line">	UNIQUE KEY (id_card)#唯一索引</span><br><span class="line">);</span><br><span class="line">#3.使用alter添加索引</span><br><span class="line">alter table tablename add primary key&#x2F;unique&#x2F;index&#x2F;fulltext idxname(colname);</span><br></pre></td></tr></table></figure>

<h2 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h2><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<p>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）<br>然后删除其中无用数据（此过程需要不到两分钟）<br>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。<br>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</p>
<h2 id="联合索引、联合查询"><a href="#联合索引、联合查询" class="headerlink" title="联合索引、联合查询"></a>联合索引、联合查询</h2><p>MySQL可以使用多个字段建立一个索引，若完全使用上联合索引就要满足最左前缀法则。</p>
<h2 id="主键索引和非主键索引有什么区别"><a href="#主键索引和非主键索引有什么区别" class="headerlink" title="主键索引和非主键索引有什么区别"></a>主键索引和非主键索引有什么区别</h2><h2 id="聊聊MySQL索引的发展过程？是一来就是B-Tree的么？从-没有索引、hash、二叉排序树、AVL树、B树、B-树-聊。"><a href="#聊聊MySQL索引的发展过程？是一来就是B-Tree的么？从-没有索引、hash、二叉排序树、AVL树、B树、B-树-聊。" class="headerlink" title="聊聊MySQL索引的发展过程？是一来就是B+Tree的么？从 没有索引、hash、二叉排序树、AVL树、B树、B+树 聊。"></a>聊聊MySQL索引的发展过程？是一来就是B+Tree的么？从 没有索引、hash、二叉排序树、AVL树、B树、B+树 聊。</h2><p>先是没有索引，只能全表遍历。如果要查一个数据的话，运气好只用查一次，运气不好就要查全表。但数据有上百万时，是非常耗时的。</p>
<p>然后便引入了二叉树。每个节点最多有两个根节点，且左节点小于右节点。这样查询数据就会快一些。但是这也存在一个问题，就是在构建二叉树时，碰到id递增构建，这个二叉树就相当于变成了一个链表。这样查询数据就跟没有索引是一样的。</p>
<p>这里便引入了红黑树。红黑树在构建时，会自动的调整二叉树的结构，使之平衡。但这也会存在问题就是每次都要检查规则，再把树平衡，这是非常耗时的；数据量大的话，红黑树深度就会比较深，树的深度深就代表要I/O多次。</p>
<p>引入了B树。B树的特点是每个节点可以含有多个子节点。所有的叶子节点在同一层，每个节点的子节点都是从左到右排序好的。每个节点中都保存有数据以及指针。这样就把树的高度降低。</p>
<p>为了使每个节点能够包含更多的子节点，使用了B+树。也就是非叶子节点不再包含数据，只存放指针。叶子节点存放数据，以及还有双向的指针用于范围查询。这样树的高度又一次的降低。</p>
<h2 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h2><p>推荐使用自增ID，不要使用UUID。</p>
<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
<h2 id="MySQL中如果使用like进行模糊匹配的时候，是否会使用索引？一定不会用么？"><a href="#MySQL中如果使用like进行模糊匹配的时候，是否会使用索引？一定不会用么？" class="headerlink" title="MySQL中如果使用like进行模糊匹配的时候，是否会使用索引？一定不会用么？"></a>MySQL中如果使用like进行模糊匹配的时候，是否会使用索引？一定不会用么？</h2><p>不一定，当模糊查询是以%开头时，就不会用到索引。</p>
<h2 id="MySQL-的having，order-by如何走索引"><a href="#MySQL-的having，order-by如何走索引" class="headerlink" title="MySQL 的having，order by如何走索引"></a>MySQL 的having，order by如何走索引</h2><h2 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h2><p>首先要知道Hash索引和B+树索引的底层实现原理：</p>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>
<p>那么可以看出他们有以下的不同：</p>
<p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。<br>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<p>hash索引不支持使用索引进行排序，原理同上。<br>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。<br>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。<br>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。<br>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p>
<h2 id="谈谈MySQL里面的事务，说说什么是事务？"><a href="#谈谈MySQL里面的事务，说说什么是事务？" class="headerlink" title="谈谈MySQL里面的事务，说说什么是事务？"></a>谈谈MySQL里面的事务，说说什么是事务？</h2><p>事务就是多个sql语句组成的一个执行单元，每个SQL语句互相依赖，整个单元不可分割。</p>
<h2 id="事务四大特性ACID讲一讲-2"><a href="#事务四大特性ACID讲一讲-2" class="headerlink" title="事务四大特性ACID讲一讲*2"></a>事务四大特性ACID讲一讲*2</h2><p><strong>原子性</strong>：事务是最小的执行单位，是不可分割的。事务的原子性保证动作要么全部执行要么完全不起作用</p>
<p><strong>一致性</strong>：一致性是指系统从一个正确的状态,迁移到另一个正确的状态。什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程.C是目的,AID都是手段.</p>
<p><strong>隔离性</strong>：并发访问数据时，事务的执行不受其他事务的影响。</p>
<p><strong>持久性</strong>：事务执行对数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
<h2 id="ACID如何实现"><a href="#ACID如何实现" class="headerlink" title="ACID如何实现"></a>ACID如何实现</h2><p><strong>原子性</strong>：利用Innodb的<code>undo log</code>日志文件。<code>undo log</code>名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。<br>例如</p>
<ul>
<li>(1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li>
<li>(2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li>
<li>(3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作</li>
</ul>
<p><code>undo log</code>记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
<p><strong>一致性</strong>：从数据库层面来讲，一致性是通过AID来实现的。ACID中，C是目的，AID是手段。但是如果自己在事务中写出违反约束的代码，一致性仍无法保证。所以需要在应用层上来考虑，即通过代码判断事务执行之后的数据库数据是否有效，然后决定回滚还是提交。</p>
<p><strong>隔离性</strong>：利用的是行锁或表锁和MVCC机制。</p>
<p>至于MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在<code>undo log</code>中。<br>如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。<br>由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同，就不赘述了。<br>但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。</p>
<p><strong>持久性</strong>：利用Innodb的<code>red log</code>。正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。<br><strong>怎么解决这个问题</strong>？<br>简单啊，事务提交前直接把数据写入磁盘就行啊。<br><strong>这么做有什么问题</strong></p>
<ul>
<li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</li>
<li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li>
</ul>
<p>于是，决定采用<code>redo log</code>解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在<code>redo log</code>中记录这次操作。当事务提交的时候，会将<code>redo log</code>日志进行刷盘(<code>redo log</code>一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将<code>redo log</code>中的内容恢复到数据库中，再根据<code>undo log</code>和<code>binlog</code>内容决定回滚数据还是提交数据。</p>
<p><strong>采用redo log的好处？</strong><br>其实好处就是将<code>redo log</code>进行刷盘比对数据页刷盘效率高，具体表现如下</p>
<ul>
<li><code>redo log</code>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li>
<li><code>redo log</code>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li>
</ul>
<p><a href="https://www.cnblogs.com/rjzheng/p/10841031.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/10841031.html</a></p>
<h2 id="MySQL里面有哪些事务级别，并且不同的事务级别会出现什么问题？-2"><a href="#MySQL里面有哪些事务级别，并且不同的事务级别会出现什么问题？-2" class="headerlink" title="MySQL里面有哪些事务级别，并且不同的事务级别会出现什么问题？*2"></a>MySQL里面有哪些事务级别，并且不同的事务级别会出现什么问题？*2</h2><p>事务级别有读未提交、读已提交、可重复读、串行化</p>
<p>读未提交会出现脏读、不可重复读和幻读<br>读已提交会出现不可重复读和幻读<br>可重复读会出现幻读<br>串行化会不会出现问题</p>
<h2 id="事务并发有哪些问题？"><a href="#事务并发有哪些问题？" class="headerlink" title="事务并发有哪些问题？"></a>事务并发有哪些问题？</h2><p>脏读：事务1修改了数据未提交，但是事务2可以读到该未提交的数据</p>
<p>不可重复读：事务1读某个数据，事务2修改了这个数据并提交，事务1再读时值不一样</p>
<p>幻读：事务1读某段数据，事务2在这段数据内添加一个数据，事务1再读时就多了一行</p>
<h2 id="谈谈可重复读和幻读的区别？"><a href="#谈谈可重复读和幻读的区别？" class="headerlink" title="谈谈可重复读和幻读的区别？"></a>谈谈可重复读和幻读的区别？</h2><p>见上</p>
<h2 id="事务通过什么回滚删除插入失败的数据"><a href="#事务通过什么回滚删除插入失败的数据" class="headerlink" title="事务通过什么回滚删除插入失败的数据"></a>事务通过什么回滚删除插入失败的数据</h2><h2 id="数据库有哪些锁？"><a href="#数据库有哪些锁？" class="headerlink" title="数据库有哪些锁？"></a>数据库有哪些锁？</h2><p>从对数据的操作：<br>读锁（共享锁）、写锁（排它锁）</p>
<p>从对数据操作的粒度：<br>表锁、行锁、页锁</p>
<p>InnoDB引擎的行锁如何实现？<br>select * from tableID where ID = 1 for update;<br>for update可以根据条件完成行锁锁定，并且id是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p>
<p>加共享锁<br>SELECT * from tableID LOCK IN SHARE MODE</p>
<p>加表锁<br>lock table tableID read/write;<br>释放表锁<br>unlock tables;</p>
<h2 id="mysql的锁，什么情况下会锁住整张表？"><a href="#mysql的锁，什么情况下会锁住整张表？" class="headerlink" title="mysql的锁，什么情况下会锁住整张表？"></a>mysql的锁，什么情况下会锁住整张表？</h2><p>当查询的字段不是索引字段时，就会使用表锁。</p>
<h2 id="什么是页锁？"><a href="#什么是页锁？" class="headerlink" title="什么是页锁？"></a>什么是页锁？</h2><p>页锁值锁定粒度介于表锁与行锁之间的锁。表锁速度快但冲突小，行锁冲突小但速度慢，所以取了折中的页级，一次锁定相邻的一组记录</p>
<h2 id="数据库MVCC的实现"><a href="#数据库MVCC的实现" class="headerlink" title="数据库MVCC的实现"></a>数据库MVCC的实现</h2><p>MySQL的innodb会为每一行添加两个字段，分别表示该行<strong>创建的版本</strong>和<strong>删除的版本</strong>，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别(一致性，隔离性，原子性，永久性)下，具体各种数据库操作的实现：</p>
<p>select：满足以下两个条件innodb会返回该行数据：（1）该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。（2）该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</p>
<p>​    insert：将新插入的行的创建版本号设置为当前系统的版本号。</p>
<p>​    delete：将要删除的行的删除版本号设置为当前系统的版本号。</p>
<p>​    update：不执行原地update，而是转换成delete + insert。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</p>
<p>​    其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p>
<p>​    由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p>
<p>​    通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p>
<p><a href="https://www.jianshu.com/p/d67f0329d3bf" target="_blank" rel="noopener">https://www.jianshu.com/p/d67f0329d3bf</a></p>
<h2 id="快照发生在什么时候？"><a href="#快照发生在什么时候？" class="headerlink" title="快照发生在什么时候？"></a>快照发生在什么时候？</h2><h2 id="怎么保证update的正确性？"><a href="#怎么保证update的正确性？" class="headerlink" title="怎么保证update的正确性？"></a>怎么保证update的正确性？</h2><h2 id="什么是间隙锁"><a href="#什么是间隙锁" class="headerlink" title="什么是间隙锁"></a>什么是间隙锁</h2><p><a href="https://www.jianshu.com/p/d1aba64b5c03" target="_blank" rel="noopener">https://www.jianshu.com/p/d1aba64b5c03</a></p>
<h2 id="可重复读是怎么解决幻读的问题的"><a href="#可重复读是怎么解决幻读的问题的" class="headerlink" title="可重复读是怎么解决幻读的问题的"></a>可重复读是怎么解决幻读的问题的</h2><h2 id="聊聊索引，我给你写个表，看看下面的查询语句，走了那些索引？"><a href="#聊聊索引，我给你写个表，看看下面的查询语句，走了那些索引？" class="headerlink" title="聊聊索引，我给你写个表，看看下面的查询语句，走了那些索引？"></a>聊聊索引，我给你写个表，看看下面的查询语句，走了那些索引？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'tb'</span> (</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line">   <span class="keyword">status</span> <span class="built_in">int</span>,</span><br><span class="line">   createtime <span class="built_in">timestamp</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 创建了三个普通索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  index_status <span class="keyword">on</span> <span class="keyword">table</span>(<span class="string">'status'</span>)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  index_createtime <span class="keyword">on</span> <span class="keyword">table</span>(<span class="string">'createtime'</span>)</span><br><span class="line"><span class="comment">-- 给定SQL语句，判断下面查询会用到几个索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  tb <span class="keyword">where</span> <span class="keyword">status</span> = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">name</span> = <span class="string">"zhangsan"</span></span><br></pre></td></tr></table></figure>

<p>上述SQL用到了几个索引？分别是那几个？</p>
<p>通过两个索引查询出来的结果，会进行什么要的操作？交集，并集？</p>
<h2 id="如果你在MySQL中遇到一些慢查询，有什么解决方法么？"><a href="#如果你在MySQL中遇到一些慢查询，有什么解决方法么？" class="headerlink" title="如果你在MySQL中遇到一些慢查询，有什么解决方法么？"></a>如果你在MySQL中遇到一些慢查询，有什么解决方法么？</h2><p>开启慢查询日志：<br>配置项：slow_query_log<br>show variables like ‘slow_query_log’查看是否开启 。如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p>
<p>设置临界时间<br>配置项：long_query_time<br>查看：show VARIABLES like ‘long_query_time’，单位秒<br>设置：set long_query_time=0.5<br>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉<br>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中</p>
<p><strong>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</strong></p>
<p>所以优化也是针对这三个方向来的，</p>
<p>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。<br>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。<br>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p>
<h2 id="谈谈explain即执行计划？执行的explain后，出现的哪些字段，能够帮助我们呢？"><a href="#谈谈explain即执行计划？执行的explain后，出现的哪些字段，能够帮助我们呢？" class="headerlink" title="谈谈explain即执行计划？执行的explain后，出现的哪些字段，能够帮助我们呢？"></a>谈谈explain即执行计划？执行的explain后，出现的哪些字段，能够帮助我们呢？</h2><p>字段：id,select_type,table,partitions,type,possible_keys,key,key_len,ref,rows,filtered,Extra</p>
<p>执行计划包含的信息 <strong>id</strong> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>
<p>id相同执行顺序由上至下。<br>id不同，id值越大优先级越高，越先被执行。<br>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</p>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。<br>id    select_type    description<br>1    SIMPLE    不包含任何子查询或union等查询<br>2    PRIMARY    包含子查询最外层查询就显示为 PRIMARY<br>3    SUBQUERY    在select或 where字句中包含的查询<br>4    DERIVED    from字句中包含的查询<br>5    UNION    出现在union后的查询语句中<br>6    UNION RESULT    从UNION中获取结果集，例如上文的第三个例子</p>
<p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id partitions 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">engine</span> = <span class="keyword">innodb</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">partitions</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>partitions</strong> 代表分区表中的命中情况，非分区表，该项为null</p>
<p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型<br>ALL 扫描全表数据<br>index 遍历索引<br>range 索引范围查找<br>index_subquery 在子查询中使用 ref<br>unique_subquery 在子查询中使用 eq_ref<br>ref_or_null 对Null进行索引的优化的 ref<br>fulltext 使用全文索引<br>ref 使用非唯一索引查找数据<br>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。<br>system 表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计<br>const 表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快<br>如将主键置于where列表中，MySQL就能将该查询转换为一个常量<br>从最好到最差依次是：<br>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p>
<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>
<p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>
<p>TIPS:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p>
<p><strong>key_length</strong> 索引长度</p>
<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>
<p><strong>filtered</strong> 这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数</p>
<p><strong>extra</strong> 的信息非常丰富，常见的有：<br>Using index 使用覆盖索引<br>Using where 使用了用where子句来过滤结果集<br>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。<br>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册<br>Using join buffer 使用了连接缓存</p>
<p>SQL语句编写</p>
<p>取出表中语文及格而数学不及格的同学的学号（要判断同学是不是同时拥有这两门成绩）</p>
<p>给出很多不同时间戳的记录，找出一小时内的记录数</p>
<p>Sql注入</p>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h2 id="JTA事务和普通事务"><a href="#JTA事务和普通事务" class="headerlink" title="JTA事务和普通事务"></a>JTA事务和普通事务</h2><p>JTA（Java Transaction API）可以进行跨库连接，而普通事务只能单库连接。</p>
<h2 id="MySQL一条语句的执行过程，解析过程？查询缓存？怎么判断是否命中？"><a href="#MySQL一条语句的执行过程，解析过程？查询缓存？怎么判断是否命中？" class="headerlink" title="MySQL一条语句的执行过程，解析过程？查询缓存？怎么判断是否命中？"></a>MySQL一条语句的执行过程，解析过程？查询缓存？怎么判断是否命中？</h2><h2 id="MySQL的执行计划"><a href="#MySQL的执行计划" class="headerlink" title="MySQL的执行计划"></a>MySQL的执行计划</h2><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><p><a href="http://wangzhenkai.com/article/12" target="_blank" rel="noopener">http://wangzhenkai.com/article/12</a></p>
<p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。<br>1.第一范式，<strong>确保每列保持原子性</strong><br>第一范式是最基本的范式。如果数据库表中所有字段值都是不可分解的原子值，就说明该数据库表满足了第一个范式。比如地址属性，一般填写地址时会再分为省份、城市、详细地址等多个部分，所以光是地址是不满足第一范式的，需要拆分为省份、城市、详细地址等</p>
<p>2.第二范式，<strong>确保表中的每列都和主键相关</strong><br>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分（这里主要针对联合索引）相关。</p>
<p>3.第三范式，<strong>确保每列都和主键列直接相关，而不是间接相关</strong><br>所有非主属性对任何候选关键字都不存在传递依赖。即每个属性都跟主键有直接关系而不是间接关系。如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 –&gt; (院校地址，院校电话)。我们应该拆开来，如下：<br>（学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</p>
<p><strong>使用三大范式目的</strong><br>数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。</p>
<h2 id="Java与数据库的连接"><a href="#Java与数据库的连接" class="headerlink" title="Java与数据库的连接"></a>Java与数据库的连接</h2><p><strong>JDBC</strong><br>使用JDBC进行连接。<br>基本过程：<br>1.加载驱动；<br>2.获取连接(connection)；<br>3.编写sql语句，获取statement类对象，执行增删改查。或者获取preStatement类对象执行增删改查。<br>二者区别：statement是直接写入sql语句，这可能会有sql注入的危险。而preStatement则是编写sql语句时先使用？代替位置，然后再对每个问号进行赋值替换，安全<br>4.关闭连接</p>
<p><strong>Spring中连接数据库</strong></p>
<p><a href="https://www.jianshu.com/p/414ef5b49a69" target="_blank" rel="noopener">https://www.jianshu.com/p/414ef5b49a69</a></p>
<p>1.通过JdbcTemplate来访问数据库，Spring boot提供了如下的starter来支撑：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.通过JPA，对POJO类增加Entity的注解，并指定表名（如果不指定，默认的表名为author），然后指定ID的及其生成策略，这些都是JPA的知识，与Spring boot无关</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入JPA --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.与MyBatis集成</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入Mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置数据库</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/community?serverTimezone=UTC</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#采用druid数据源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mybatis配置</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.zzj.miaosha.domain</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#将mapper的xml与接口放在一起</span></span><br><span class="line"><span class="meta">mybatis.mapperLocations</span>=<span class="string">classpath:com/zzj/miaosha/dao/*.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#druid</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/miaosha?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.datasource.validationQuery</span>=<span class="string">select'x'</span></span><br><span class="line"><span class="meta">spring.datasource.maxActive</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">spring.datasource.initialSize</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">spring.datasource.maxWait</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.minIdle</span>=<span class="string">500</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot默认的数据库连接池：<br>1.x版本中默认连接池是Tomcat的连接池，在2.x版本中更换为HikariCP数据库连接池HikariCP速度快的原因</p>
<ol>
<li>字节码级别优化（很多⽅法通过 JavaAssist ⽣成）</li>
<li>⼤量⼩改进<br> • ⽤ FastStatementList 代替 ArrayList<br> • ⽆锁集合 ConcurrentBag<br> • 代理类的优化（⽐如，⽤ invokestatic 代替了 invokevirtual）</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a href="https://zhuanlan.zhihu.com/p/112944545?utm_source=qq" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112944545?utm_source=qq</a></p>
<h2 id="关系型数据库和非关系型数据库的区别，有哪些非关系型数据库？"><a href="#关系型数据库和非关系型数据库的区别，有哪些非关系型数据库？" class="headerlink" title="关系型数据库和非关系型数据库的区别，有哪些非关系型数据库？"></a>关系型数据库和非关系型数据库的区别，有哪些非关系型数据库？</h2><p>关系型数据库基于ACID，非关系型数据库基于CAP理论<br><strong>数据存储结构：</strong>关系型数据库一般都有固定的表结构，并且需要通过DDL语句来修改表结构，不是很容易进行扩展，而非关系型数据库的存储机制就有很多了，<strong>比如基于文档的，K-V键值对的，还有基于列族的，基于图的等</strong>，对于数据的格式十分灵活没有固定的表结构，方便扩展<br><strong>可扩展性：</strong>关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。非关系型数据库基于键值对，数据之间没有耦合性，所以非常容易水平扩展。<br><strong>数据一致性：</strong>非关系型数据库一般强调的是数据最终一致性，不像关系型数据库一样强调数据的强一致性。从非关系型数据库读到的有可能还是处于一个中间态的数据。<br><strong>查询速度：</strong>非关系型数据库将数据存储于内存之中，而且不需要经过SQL层的解析，关系型数据库将数据存储在硬盘之中，查询需要进行IO操作，所以查询速度不如非关系型数据库</p>
<p><strong>主流的非关系型数据库</strong><br>MongoDB：是一个面向文档的开源NoSQL数据库。MongoDB使用JSON之类的文档来存储任何数据。它是用c++写的。</p>
<p>Cassandra：是Facebook为收件箱搜索开发的。Cassandra是一个用于处理大量结构化数据的分布式数据存储系统。</p>
<p>Redis：是最著名的键值存储。Redis是用C语言编写的。它是根据BSD授权的。</p>
<p>HBase：是谷歌为BigTable数据库设计的分布式非关系数据库。</p>
<p>Neo4j：称为原生图数据库，因为它有效地实现了属性图模型，一直到存储层。</p>
<p>Oracle NoSQL：实现了从用户定义的键到不透明数据项的映射。</p>
<p>Amazon DynamoDB：使用了一个NoSQL数据库模型，它是非关系型的，允许文档、图形和列在它的数据模型之间。</p>
<p>Couchbase：是一个用于交互式web应用程序的NoSQL文档数据库。它具有灵活的数据模型，易于扩展，提供一致的高性能。</p>
<p>Memcached：是一个开源、高性能、分布式内存缓存系统，旨在通过减少数据库负载来加速动态web应用程序。</p>
<p>CouchDB：是一个开源的NoSQL数据库，使用JSON存储信息，JavaScript作为查询语言。</p>
<h2 id="Redis的应用场景有哪些"><a href="#Redis的应用场景有哪些" class="headerlink" title="Redis的应用场景有哪些"></a>Redis的应用场景有哪些</h2><p><strong>1、缓存</strong><br>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。（推荐：《Redis视频教程》）</p>
<p><strong>2、排行榜</strong><br>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p>
<p><strong>3、计数器</strong><br>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p>
<p><strong>4、分布式会话</strong><br>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p>
<p><strong>5、分布式锁</strong><br>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p>
<p><strong>6、 社交网络</strong><br>点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。</p>
<p><strong>7、最新列表</strong><br>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p>
<p><strong>8、消息系统</strong><br>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p>
<h2 id="Redis为什么采用单线程而不是多线程以及为什么Redis这么快"><a href="#Redis为什么采用单线程而不是多线程以及为什么Redis这么快" class="headerlink" title="Redis为什么采用单线程而不是多线程以及为什么Redis这么快"></a>Redis为什么采用单线程而不是多线程以及为什么Redis这么快</h2><p><a href="https://blog.csdn.net/chenyao1994/article/details/79491337" target="_blank" rel="noopener">https://blog.csdn.net/chenyao1994/article/details/79491337</a><br><a href="https://zhuanlan.zhihu.com/p/87233515" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/87233515</a></p>
<p><strong>为什么采用单线程</strong><br>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最可能是机器内存的大小或者网络带宽。对于一个内存的系统来说，它没有上下文切换就是效率最高的。从内存中连续读取1MB的连续数据耗时大约为250μs。假设1MB的数据由多个线程读取了1000次，那么就有1000次上下文切换。一次CPU上下文切换大概在1500ns左右，那么就有1500ns * 1000 = 1500μs时间用来切换上下文，远大于之前的250μs。所以使用单线程可以更快</p>
<p><strong>为什么那么快</strong><br>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；<br>2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；<br>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；<br>4、使用多路I/O复用模型，非阻塞IO；<br>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<p><strong>多核下，单线程浪费其他cpu</strong><br>可以在多核环境下启动多个Redis实例，组成master-master或者master-slave的形式。一些读命令就可以在slave上进行。</p>
<p><strong>注意</strong><br>1.这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行<br>2.从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作。比如在后台删除对象，以及阻止通过Redis模块实现的命令</p>
<h2 id="String类型的底层原理讲一下"><a href="#String类型的底层原理讲一下" class="headerlink" title="String类型的底层原理讲一下"></a>String类型的底层原理讲一下</h2><p>SDS简单动态字符串，free、buf、len</p>
<h2 id="Redis的ZSet底层是什么结构？跳表，介绍一下，画一下基本结构，搜索插入数据过程，时间复杂度"><a href="#Redis的ZSet底层是什么结构？跳表，介绍一下，画一下基本结构，搜索插入数据过程，时间复杂度" class="headerlink" title="Redis的ZSet底层是什么结构？跳表，介绍一下，画一下基本结构，搜索插入数据过程，时间复杂度"></a>Redis的ZSet底层是什么结构？跳表，介绍一下，画一下基本结构，搜索插入数据过程，时间复杂度</h2><p>ZSet底层结构有两种，当保存的元素个数小于128并且每个元素的长度都小于64字节时，使用<strong>压缩列表（ziplist）</strong>，否则使用<strong>跳表（skiplist）</strong></p>
<p>压缩列表中，每个集合元素用两个列表集合紧挨着一起的来存储。第一个节点存放元素的成员，第二个节点存放元素的分数。且压缩列表中的元素按元素的分数大小从小到大排序。</p>
<p>若使用跳表，其实结构包含跳表和字典。因为字典在查找的时间复杂度是O(1)，而跳表查找时是O(logN)。但字典是无序的，每次进行范围查询都需要再次排序，所以还是需要使用跳表。字典的键保存元素的值，字典的值存放元素的分数。跳表节点的object属性存放元素的成员，跳表的score属性存放元素的分数。<strong>这两种数据结构会通过指针来共享同一个元素，不会产生重复成员和分值造成内存的浪费。</strong></p>
<p>跳表是一种有序数据结构，通过每个节点维持多个指向其他节点的指针来达到快速访问节点的目的。<br>1、由很多层结构组成；<br>2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；<br>3、最底层的链表包含了所有的元素；<br>4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；<br>5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</p>
<p><strong>跳表查找元素x过程</strong><br>1.从最上层的链表开始查找<br>2.假设当前节点的元素值为x，同一层下一个节点的元素值为y<br>    当x = y时，元素查到，返回x相关信息<br>    当x &gt; y时，查找位置由当前节点移到同一层下一个节点<br>    当x &lt; y时或y不存在时，查找位置由当前节点移到下一层的同元素节点<br>3.若移到了最后一层，仍需要向下走，则元素不存在</p>
<p><strong>跳表插入元素过程</strong><br>关于插入的位置，我们先利用跳跃表的查找功能，找到比x小的最大的数y。根据跳跃表中所有链均是递增序列的原则，x必然就插在y的后面。而插入列的“高度”较前者来说显得更加重要，也更加难以确定。由于它的不确定性，使得不同的决策可能会导致截然不同的算法效率。<strong>为了使插入数据之后，保持该数据结构进行各种操作均为O(logn)复杂度的性质，我们引入随机化算法(Randomized lgorithms)。</strong></p>
<p>   我们定义一个随机决策模块，它的大致内容如下：</p>
<p> 产生一个0到1的随机数r   r ← random()<br>如果r小于一个常数p，则执行方案A， if r&lt;p then do A<br>否则，执行方案B     else do B<br>   初始时列高为1。插入元素时，不停地执行随机决策模块。如果要求执行的是A操作，则将列的高度加1，并且继续反复执行随机决策模块。直到第i次，模块要求执行的是B操作，我们结束决策，并向跳跃表中插入一个高度为i的列。<br>在Redis中，生成随机层数的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设 ZSKIPLIST_P 为2 (实际为4,便于理解设置为2),这段代码我们可以理解为,落到层数为i + 1的概率为0.5^i</p>
<p>而反过来理解,每两个节点出现层数为2的期望就是1,每4个节点出现第三层的期望也为1,每8个节点出现第四层(0.5^3)的期望为1 (期望值 = 单个概率 * 数量)</p>
<p>正是基于此,如果我们的数据量越大,越是可以接近期望的值,所以,我们可以认为,我们实现了 “如果每2^i个节点都指向前面2^i个节点”的效果,也就是说,查找的平均复杂度为O(logN)</p>
<p><strong>跳表删除元素过程</strong><br>在跳跃表中查找到这个元素的位置，如果未找到，则退出<br>将该元素所在整列从表中删除<br>将多余的“空链”删除 </p>
<h2 id="Redis字典的实现"><a href="#Redis字典的实现" class="headerlink" title="Redis字典的实现"></a>Redis字典的实现</h2><p>字典是一种保存键值对的数据结构。字典中每一个键都是唯一的，通过key可以对值进行查找或修改。Redis中字典用哈希表来实现。</p>
<p>哈希表结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">     <span class="comment">//哈希表数组</span></span><br><span class="line">     dictEntry **table;</span><br><span class="line">     <span class="comment">//哈希表大小</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">     <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">     <span class="comment">//总是等于 size-1</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">     <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht</span><br></pre></td></tr></table></figure>

<p>dictEntry结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">     <span class="comment">//键</span></span><br><span class="line">     <span class="keyword">void</span> *key;</span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="keyword">union</span>&#123;</span><br><span class="line">          <span class="keyword">void</span> *val;</span><br><span class="line">          uint64_tu64;</span><br><span class="line">          int64_ts64;</span><br><span class="line">     &#125;v;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure>

<p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。还有一个指向下一个哈希表节点，用来解决哈希冲突</p>
<p>字典的结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">     <span class="comment">//类型特定函数</span></span><br><span class="line">     dictType *type;</span><br><span class="line">     <span class="comment">//私有数据</span></span><br><span class="line">     <span class="keyword">void</span> *privdata;</span><br><span class="line">     <span class="comment">//哈希表</span></span><br><span class="line">     Dictht ht[<span class="number">2</span>];</span><br><span class="line">     <span class="comment">//rehash索引</span></span><br><span class="line">     <span class="comment">//当rehash不再进行时，值为-1</span></span><br><span class="line">     in trehashidx;</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>

<p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数；<br>privdata属性保存了需要传给那些类型特定函数的可选参数；<br>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，ht[1]只有在对ht[0]哈希表进行rehash操作时使用；<br>trehashidx属性是rehash索引，没有进行rehash操作时值都为-1.</p>
<p>字典的结构示意图</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C11.png" alt=""></p>
<p>1.哈希算法：Redis计算哈希值和索引值方法如下：</p>
<p>  #1、使用字典设置的哈希函数，计算键 key 的哈希值  hash =  dict-&gt;type-&gt;hashFunction(key);<br>  #2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值  index = hash &amp;  dict-&gt;ht[x].sizemask;  </p>
<p>2.解决哈希冲突：<strong>这里使用链地址法</strong>。通过字典里面的*next指针指向下一个具有相同索引值的哈希表节点。</p>
<p>3.扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rehash(重新散列）来对哈希表进行相应的扩展或者收缩。<br>具体步骤：<br>    1、如果执行扩展操作，会基于原哈希表为ht[1]创建一个大小为第一个大于等于ht[0].used x 2的2的n次幂的哈希表（若used为7，则第一个大于7*2的2的n次幂的值为16，所以大小为16）。相反如果执行的是收缩操作，每次收缩是创建一个大小为第一个大于等于ht[0].used的2的n次幂新的哈希表。<br>    2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。<br>    3、所有键值对都迁徙完毕后，将ht[1]设置为ht[0]，并在ht[1]重新创建一个空白的哈希表。</p>
<p>4.触发扩容条件：</p>
<p>​    1.服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1时扩容。<br>​    2.服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5时扩容。</p>
<p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p>
<p>5.渐进式rehash</p>
<p>什么叫渐进式 rehash？<strong>也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。</strong>如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，<strong>但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作</strong>。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</p>
<h2 id="重哈希怎么实现，重哈希是同步还是异步，哈希键还有用什么数据结构"><a href="#重哈希怎么实现，重哈希是同步还是异步，哈希键还有用什么数据结构" class="headerlink" title="重哈希怎么实现，重哈希是同步还是异步，哈希键还有用什么数据结构"></a>重哈希怎么实现，重哈希是同步还是异步，哈希键还有用什么数据结构</h2><h2 id="Redis，它会存在线程切换的问题么"><a href="#Redis，它会存在线程切换的问题么" class="headerlink" title="Redis，它会存在线程切换的问题么"></a>Redis，它会存在线程切换的问题么</h2><p>不会，Redis是单线程的。</p>
<h2 id="谈谈Redis单线程模型和IO多路复用"><a href="#谈谈Redis单线程模型和IO多路复用" class="headerlink" title="谈谈Redis单线程模型和IO多路复用"></a>谈谈Redis单线程模型和IO多路复用</h2><p><strong>Redis单线程模型</strong></p>
<p><strong>1.文件事件处理器</strong></p>
<p>Redis基于reactor模式开发了网络事件处理器，即文件事件处理器（file event handler），这文件事件处理器是单线程的，所以Redis是单线程的。文件事件处理器采用了IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p>
<p>如果被监听的socket准备好执行accept,read,write,close等事件/操作的时候,跟事件/操作对应的文件事件就会产生,这个时候文件事件处理器就会调用之前关联好的事件处理器来处理这个事件;</p>
<p>文件事件处理器是单线程模式运行的,但是通过IO多路复用机制监听多个socket,可以实现高性能的网络通信模型.又可以跟内部其他单线程的模块进行对接,保证了Redis内部的线程模型的简单性;</p>
<p>文件事件处理器的结构包含4个部分<br>多个socket<br>IO多路复用程序<br>文件事件分派器<br>事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等等）<br>除此之外还有一个socket队列</p>
<p>多个socket可能并发的产生不同的操作,每个操作对应不同的文件事件,但是IO多路复用程序会监听多个socket,<strong>会将socket放入一个队列中排队,然后每次从队列中取出一个socket给事件分派器</strong>,事件分派器再把socket分派给对应的事件处理器去处理;</p>
<p>当一个socket的事件被处理完之后,IO多路复用程序才会将队列中的下一个socket取出交给事件分派器.文件事件分派器再根据socket当前产生的事件来选择对应的事件处理器来处理;</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C12.png" alt=""></p>
<p><strong>2.文件事件</strong></p>
<p>1&gt;.当socket变得可读时(比如客户端对Redis执行write操作或者close操作),或者有新的可以应答的socket出现时(客户端对Redis执行connect操作),socket就会产生一个”AE_READABLE”事件;</p>
<p>2&gt;.当socket变得可写的时候(客户端对Redis执行read操作),socket就会产生一个”AE_WRITABLE”事件;</p>
<p>3&gt;.IO多路复用程序可以同时监听”AE_READABLE”和”AE_WRITABLE”两种事件,要是一个socket同时产生了”AE_READABLE”和”AE_WRITABLE”两种事件,那么文件事件分派器会优先处理”AE_READABLE”事件,然后才是”AE_WRITABLE”事件;</p>
<p><strong>3.常用的文件事件处理器</strong></p>
<p>1&gt;.如果是客户端要连接Redis,那么会为socket关联<strong>连接应答处理器</strong>;</p>
<p>2&gt;.如果是客户端要写数据到Redis,那么会为socket关联<strong>命令请求处理器</strong>；</p>
<p>3&gt;.如果是客户端要从Redis中读取数据(Redis发送数据给客户端),那么会为socket关联<strong>命令回复处理器</strong>;</p>
<p><strong>4.Redis单线程模型的大致工作流程及原理</strong></p>
<p>客户端与redis进行通信大致流程：<br>1、首先在redis启动初始化的时候，redis会先将事件处理器中的连接应答处理器和AE_READABLE事件关联起来;<br>2、如果客户端向redis发起连接，会产生AE_READABLE事件(步骤A)，产生该事件后会被IO多路复用程序监听到(步骤B)，然后IO多路复用程序会把监听到的socket信息放入到队列中(步骤C)，事件分配器每次从队列中取出一个socket(步骤D)，然后事件分派器把socket给对应的事件处理器(步骤E)。由于连接应答处理器和AE_READABLE事件在redis初始化的时候已经关联起来，所以由连接应答处理器来处理跟客户端建立连接，然后通过ServerSocket创建一个与客户端一对一对应的socket，如叫socket01，同时将这个socket01的AE_READABLE事件和命令请求处理器关联起来。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C13.png" alt=""></p>
<p>3、当客户端向redis发生请求时(读、写操作)，首先就会在对应的socket如socket01上会产生AE_READABLE事件(步骤A)，产生该事件后会被IO多路复用程序监听到(步骤B)，然后IO多路复用程序会把监听到的socket信息放入到队列中(步骤C)，事件分配器每次从队列中取出一个socket(步骤D)，然后事件分派器把socket给对应的事件处理器(步骤E)。由于命令处理器和socket01的AE_READABLE事件关联起来了，然后对应的命令请求处理器来处理。这个命令请求处理器会从事件分配器传递过来的socket01上读取相关的数据，如何执行相应的读写处理。操作执行完之后，redis就会将准备好相应的响应数据(如你在redis客户端输入 set a 123回车时会看到响应ok)，并将socket01的AE_WRITABLE事件和命令回复处理器关联起来。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C14.png" alt=""></p>
<p>4、当客户端会查询redis是否完成相应的操作，就会在socket01上产生一个AE_WRITABLE事件，会由对应的命令回复处理器来处理，就是将准备好的相应数据写入socket01(由于socket连接是双向的),返回给客户端，如读操作，客户端会显示ok。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C15.png" alt=""></p>
<p>5、如果命令回复处理器执行完成后，就会删除这个socket01的AE_WRITABLE事件和命令回复处理器的关联。<br>6、这样客户端就和redis进行了一次通信。由于连接应答处理器执行一次就够了，如果客户端在次进行操作就会由命令请求处理器来处理，反复执行。</p>
<h2 id="Redis的大Key的问题，如果有个Value的大小是2M，会有什么问题么？最大支持的Value大小是多少？（实际开发中最大支持的value是多少仍需查找）"><a href="#Redis的大Key的问题，如果有个Value的大小是2M，会有什么问题么？最大支持的Value大小是多少？（实际开发中最大支持的value是多少仍需查找）" class="headerlink" title="Redis的大Key的问题，如果有个Value的大小是2M，会有什么问题么？最大支持的Value大小是多少？（实际开发中最大支持的value是多少仍需查找）"></a>Redis的大Key的问题，如果有个Value的大小是2M，会有什么问题么？最大支持的Value大小是多少？（实际开发中最大支持的value是多少仍需查找）</h2><p>Redis的大key问题是指单个key的value值非常大或者集合元素非常多。</p>
<p>出现大key会带来的一些问题：<br>1.在对大key进行读写时，会导致超时，甚至阻塞。因为redis是单线程。<br>2.对大key进行删除或者其自动过期时，会出现qps突降或突升的情况，极端情况下会造成主从复制异常，Redis请求阻塞无法响应。</p>
<p>分析大key的方法：<br>1、redis-rdb-tools工具。redis实例上执行bgsave，然后对dump出来的rdb文件进行分析，找到其中的大KEY。<br>2、redis-cli –bigkeys命令。可以找到某个实例5种数据类型(String、hash、list、set、zset)的最大key。<br>3、自定义的扫描脚本，以Python脚本居多，方法与redis-cli –bigkeys类似。<br>4、debug object key命令。可以查看某个key序列化后的长度，每次只能查找单个key的信息。官方不推荐。<br>5、Redis 4.0引入了memory usage命令和lazyfree机制，不管是对大key的发现，还是解决大key删除或者过期造成的阻塞问题都有明显的提升。</p>
<p>解决方法：<br>1、单个简单的key存储的value很大</p>
<p>（1）对象需要每次都整存整取</p>
<pre><code>可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响；</code></pre><p>（2）该对象每次只需要存取部分数据</p>
<pre><code>可以像第一种做法一样，分拆成几个key-value， 也可以将这个存储在一个hash中，每个field代表一个具体的属性，使用hget,hmget来获取部分的value，使用hset，hmset来更新部分属性</code></pre><p>2、 hash， set，zset，list 中存储过多的元素</p>
<pre><code> 可以对存储元素按一定规则进行分类，分散存储到多个redis实例中。

对于一些榜单类的场景，用户一般只会访问前几百及后几百条数据，可以只缓存前几百条以及后几百条，即对用户经常访问的数据做缓存（正序倒序的前几页），而不是全部都做，对于获取中间的数据则可以直接从数据库获取</code></pre><p>3、一个集群存储了上亿的key</p>
<p>如果key的个数过多会带来更多的内存空间占用，</p>
<p>1.key本身的占用。</p>
<p>2.集群模式中，服务端有时需要建立一些slot2key的映射关系，这其中的指针占用在key多的情况下也是浪费巨大空间。</p>
<p>所以减少key的个数可以减少内存消耗，可以参考的方案是转Hash结构存储，即原先是直接使用Redis String 的结构存储，现在将多个key存储在一个Hash结构中</p>
<p>对缓存操作的改善可以利用pipeline管道</p>
<p>  拆分之后可以考虑采用pipeline去取，由于redis是单线程的，一次只能执行一个命令，这里采用Pipeline模式，一次发送多个命令，无需等待服务端返回。这样就大大的减少了网络往返时间，提高了系统性能。<br><a href="https://blog.csdn.net/zhulj625/java/article/details/106695714" target="_blank" rel="noopener">https://blog.csdn.net/zhulj625/java/article/details/106695714</a></p>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>全量复制（发生在slave初始化阶段）<br>slave成功启动连接到master之后会发送一个syn（同步）指令<br>master收到同步指令后会开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令，主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； </p>
<p>增量复制<br>指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
<h2 id="谈谈Redis集群-Redis-Cluster？"><a href="#谈谈Redis集群-Redis-Cluster？" class="headerlink" title="谈谈Redis集群 Redis Cluster？"></a>谈谈Redis集群 Redis Cluster？</h2><p><strong>集群架构</strong><br>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果。</p>
<p><strong>集群作用</strong><br>分散单台服务器的访问压力，实现负载均衡<br>分散单台服务器的存储压力，实现可扩展性<br>降低单台服务器宕机带来的业务灾难</p>
<p><strong>存储结构设计</strong><br>存储key时，通过CRC16()方法将key代入，算出一个值。这个值再模上16384得到一个数。这个数就确定了key存储的位置。<br>将所有的存储空间计划切割成16384份，每份主机保存一部分。每份代表的是一个存储空间，不是一个key的保存空间。<br>将key按照计算出的结果放到对应的存储空间中，<strong>这个存储空间称为槽</strong><br>当有一台服务器新增，就多了存储空间。原来的存储空间会分一些到这个新的存储空间中。减少同理</p>
<p><strong>集群内部通信设计</strong><br>每个存储空间都会有记录各个计算机里面存储空间的槽是几到几，槽可能不是连续的。<br>当要查询一个key的值时，先通过算法得到一个数，这个数就是对应的要找的存储槽。当这个槽就是在当前访问的计算机的存储空间中，即一次命中返回。若没有命中，会根据槽位置，在记录中寻找该槽在哪个计算机中，直接就会让连接请求的客户端直接去那个计算机中寻找。</p>
<h2 id="说说Redis中的哨兵，即Redis-Sentinel"><a href="#说说Redis中的哨兵，即Redis-Sentinel" class="headerlink" title="说说Redis中的哨兵，即Redis Sentinel"></a>说说Redis中的哨兵，即Redis Sentinel</h2><p>能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<p>哨兵的介绍</p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<p>集群监控：负责监控 redis master 和 slave 进程是否正常工作。<br>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。<br>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。<br>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。<br>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<p>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。<br>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</p>
<p>哨兵的核心知识</p>
<p>哨兵至少需要 3 个实例，来保证自己的健壮性。<br>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。<br>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p>
<h2 id="对于Redis来说，使用悲观锁更吃力还是使用乐观锁更吃力"><a href="#对于Redis来说，使用悲观锁更吃力还是使用乐观锁更吃力" class="headerlink" title="对于Redis来说，使用悲观锁更吃力还是使用乐观锁更吃力"></a>对于Redis来说，使用悲观锁更吃力还是使用乐观锁更吃力</h2><h2 id="谈谈Redis如何实现分布式锁？-3"><a href="#谈谈Redis如何实现分布式锁？-3" class="headerlink" title="谈谈Redis如何实现分布式锁？*3"></a>谈谈Redis如何实现分布式锁？*3</h2><p>Redis实现分布式锁应该满足的条件：<br>1.互斥性：在任意时刻，只有一个客户端能持有锁<br>2.不能死锁：客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁<br>3.容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁<br>4.安全性：锁只能被被持有该锁的客户端删除，不能被其他客户端删除<br>5.高可用：当部分节点宕机，客户端仍能获取锁或者释放锁</p>
<p>实现方式：<br>1.使用setnx lock-key value的方式，执行完后通过del释放。缺点：没有设置锁的过期时间，容易造成死锁</p>
<p>2.set命令完全可以替代setnx命令，我们看官网的set命令参数</p>
<p>SET key value [EX seconds] [PX milliseconds] [NX|XX]</p>
<p><strong>参数说明：</strong></p>
<p><strong>EX second ：</strong>设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p>
<p><strong>PX millisecond ：</strong>设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p>
<p><strong>NX ：</strong>只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p>
<p><strong>XX ：</strong>只在键已经存在时，才对键进行设置操作。</p>
<p>例如：SET key value NX PX 30000 这个命令的作用是在只有这个key不存在的时候才会设置这个key的值（NX选项的作用），超时时间设为30000毫秒（PX选项的作用）</p>
<p>那么我们用set命令带上EX或者PX、以及NX参数就满足了上面提到的互斥性（加锁）、死锁（自动过期）两个要求。</p>
<p>那么如何满足安全性这个要求呢？</p>
<p>比如：客户端A拿到锁并设置了锁的过期时间为10S，但是由于某种原因客户端A执行时间超过了10S，此时锁自动过期，那么客户端B拿到了锁，然后客户端A此时正好执行完毕删除锁，但是此时删除的是客户端B加的锁，如何防止这种不安全的情况发生呢？</p>
<p><strong>方案一：</strong></p>
<p>我们可以让获得锁的线程开启一个守护线程，用来给自己的锁“续期”。</p>
<p>当过去了9S，客户端A还没执行完，这时候守护线程会执行expire指令，把锁再“续期”10S,守护线程从第9S开始执行，每9秒执行一次。</p>
<p>当客户端A执行完任务，会显式关掉守护线程。</p>
<p>如果客户端A忽然宕机，由于A线程和守护线程在同一个进程，守护线程也会停下。这把锁到了超时的时候，没人给它续期，也就自动释放了。</p>
<p><strong>方案二：</strong></p>
<p>我们也可以在加锁的时候把set的value值设置成一个唯一标识，标识这个锁是谁加的锁，在删除锁的时候判断是不是自己加的那把锁，如果不是则不删除。</p>
<p><strong>注意：</strong>这里隐含了一个新的问题，判断是不是自己加的锁和释放锁是两个独立操作，不是原子性，所以我们需要使用Lua脚本执行判断和释放锁。</p>
<p>3.Redlock算法 redission</p>
<h2 id="谈谈Redis中缓存穿透的问题，以及解决的方法？布隆过滤器有了解过么？"><a href="#谈谈Redis中缓存穿透的问题，以及解决的方法？布隆过滤器有了解过么？" class="headerlink" title="谈谈Redis中缓存穿透的问题，以及解决的方法？布隆过滤器有了解过么？"></a>谈谈Redis中缓存穿透的问题，以及解决的方法？布隆过滤器有了解过么？</h2><p>大量访问缓存和数据库中不存在的数据<br>接口层增加校验，拦截非法用户<br>从缓存中取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击<br>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免了对底层存储系统的查询压力。<br>布隆过滤器（Bloom Filter，下文简称BF）由Burton Howard Bloom在1970年提出，是一种空间效率高的概率型数据结构。<strong>它专门用来检测集合中是否存在特定的元素。</strong>听起来是很稀松平常的需求，为什么要使用BF这种数据结构呢？</p>
<p><strong>设计思想</strong><br>　　BF是由一个<strong>长度为m比特的位数组（bit array）</strong>与<strong>k个哈希函数（hash function）</strong>组成的数据结构。位数组均初始化为0，所有哈希函数都可以分别把输入数据尽量均匀地散列。<br>        当要<strong>插入</strong>一个元素时，将数据分别输入k个哈希函数，产生k个哈希值。以哈希值作为位数组中的下标，将所有k个对应的比特置为1。<br>　　当要<strong>查询</strong>（即判断是否存在）一个元素时，同样将其数据输入哈希函数，然后检查对应的k个比特。如果有任意一个比特为0，表明该元素一定不在集合中。如果所有比特均为1，表明该集合有（较大的）可能性在集合中。为什么不是一定在集合中呢？因为一个比特被置为1有可能会受到其他元素的影响，这就是所谓“假阳性”（false positive）。相对地，“假阴性”（false negative）在BF中是绝不会出现的。</p>
<h2 id="Redis中大面积的缓存失效，然后请求全部打到数据库，有什么解决方法？"><a href="#Redis中大面积的缓存失效，然后请求全部打到数据库，有什么解决方法？" class="headerlink" title="Redis中大面积的缓存失效，然后请求全部打到数据库，有什么解决方法？"></a>Redis中大面积的缓存失效，然后请求全部打到数据库，有什么解决方法？</h2><p>这是属于缓存雪崩现象。<br>给缓存的失效时间加上随机值，避免集体失效<br>使用互斥锁，但会导致吞吐量下降<br>对即将过期数据做访问量分析，确认是否延时，配个访问量统计，做热点数据的延时<br>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存</p>
<h2 id="当你通过jedis进行连接redis的时候，已经和一个进程连接了-，redis还能够和其它的进程进行通信么？"><a href="#当你通过jedis进行连接redis的时候，已经和一个进程连接了-，redis还能够和其它的进程进行通信么？" class="headerlink" title="当你通过jedis进行连接redis的时候，已经和一个进程连接了 ，redis还能够和其它的进程进行通信么？"></a>当你通过jedis进行连接redis的时候，已经和一个进程连接了 ，redis还能够和其它的进程进行通信么？</h2><p>能。</p>
<h2 id="Redis每秒能够处理处理十万请求，如果按照你上面说的，那说明它每次交互只在-1-十万-秒内完成？"><a href="#Redis每秒能够处理处理十万请求，如果按照你上面说的，那说明它每次交互只在-1-十万-秒内完成？" class="headerlink" title="Redis每秒能够处理处理十万请求，如果按照你上面说的，那说明它每次交互只在 1/十万 秒内完成？"></a>Redis每秒能够处理处理十万请求，如果按照你上面说的，那说明它每次交互只在 1/十万 秒内完成？</h2><h2 id="Redis源码是否看过"><a href="#Redis源码是否看过" class="headerlink" title="Redis源码是否看过"></a>Redis源码是否看过</h2><p>否</p>
<h2 id="为什么Nosql比sql快？主要有什么优缺点"><a href="#为什么Nosql比sql快？主要有什么优缺点" class="headerlink" title="为什么Nosql比sql快？主要有什么优缺点"></a>为什么Nosql比sql快？主要有什么优缺点</h2><p>Redis快的原因：<br>1.是在内存上工作，速度快<br>2.单线程操作，没有上下文切换<br>3.采用非阻塞的I/O多路复用机制</p>
<p>优点</p>
<p>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。<br>支持数据持久化，支持AOF和RDB两种持久化方式。<br>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。<br>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。<br>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</p>
<p>缺点</p>
<p>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。<br>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。<br>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。<br>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</p>
<h2 id="MySQL用了B-Tree，Redis中的SortSet内部用了跳跃表，他们之间有什么差别？为什么MySQL不用跳跃表，或者是Redis不用B-Tree呢？（还得再查询资料）"><a href="#MySQL用了B-Tree，Redis中的SortSet内部用了跳跃表，他们之间有什么差别？为什么MySQL不用跳跃表，或者是Redis不用B-Tree呢？（还得再查询资料）" class="headerlink" title="MySQL用了B+Tree，Redis中的SortSet内部用了跳跃表，他们之间有什么差别？为什么MySQL不用跳跃表，或者是Redis不用B+Tree呢？（还得再查询资料）"></a>MySQL用了B+Tree，Redis中的SortSet内部用了跳跃表，他们之间有什么差别？为什么MySQL不用跳跃表，或者是Redis不用B+Tree呢？（<span style="color:red">还得再查询资料</span>）</h2><p> skiplist与平衡树、哈希表的比较</p>
<ul>
<li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li>
<li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
<li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li>
<li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li>
</ul>
<p>db数据量比较大，如果db索引使用了跳跃表，那么</p>
<p>1.跳跃表的level太高，数据存储不紧凑，产生大量的空间浪费</p>
<p>2.插入的数据不会如b+树那么紧凑，数据的压缩，dump也会存在问题</p>
<p>3.查询时磁盘磁头无法对链表进行预读，会产生大量的随机IO，对磁盘的缓存不友好</p>
<p>4.无法实现聚集索引和覆盖索引</p>
<h2 id="如何保证Redis的高可用"><a href="#如何保证Redis的高可用" class="headerlink" title="如何保证Redis的高可用"></a>如何保证Redis的高可用</h2><p>使用哨兵<br>使用集群<br><a href="https://www.php.cn/redis/436062.html" target="_blank" rel="noopener">https://www.php.cn/redis/436062.html</a><br><a href="https://blog.csdn.net/zero__007/article/details/86564520" target="_blank" rel="noopener">https://blog.csdn.net/zero__007/article/details/86564520</a></p>
<h2 id="Redis的ttl指令底层实现，Redis过期策略"><a href="#Redis的ttl指令底层实现，Redis过期策略" class="headerlink" title="Redis的ttl指令底层实现，Redis过期策略"></a>Redis的ttl指令底层实现，Redis过期策略</h2><p><a href="https://www.jianshu.com/p/53083f5f2ddc" target="_blank" rel="noopener">https://www.jianshu.com/p/53083f5f2ddc</a></p>
<p>Redis针对TTL时间有专门的dict进行存储，就是redisDb当中的dict*expires字段。</p>
<p>TTL设置key过期时间的方法主要是下面4个：</p>
<ul>
<li>expire 按照相对时间且以秒为单位的过期策略</li>
<li>expireat 按照绝对时间且以秒为单位的过期策略</li>
<li>pexpire 按照相对时间且以毫秒为单位的过期策略</li>
<li>pexpireat 按照绝对时间且以毫秒为单位的过期策略</li>
</ul>
<p>整个过期时间最后都会换算到绝对时间进行存储，通过公式<strong>基准时间+过期时间</strong>来进行计算。<br> 对于相对时间而言基准时间就是当前时间，对于绝对时间而言相对时间就是0。<br> 中途考虑设置的过期时间是否已经过期，如果已经过期那么在master就会删除该数据并同步删除动作到slave。<br> 正常的设置过期时间是通过setExpire方法保存到 dict *expires对象当中。</p>
<p><strong>TTL 获取过期时间</strong></p>
<p> 通过ttl或者pttl返回剩余过期时间的逻辑其实非常简单，就是通过key去db-&gt;expires找到过期时间对象，然后与当前系统时间相比计算差值。</p>
<h2 id="Redis持久化，各个持久化的参数，开启持久化会影响性能吗"><a href="#Redis持久化，各个持久化的参数，开启持久化会影响性能吗" class="headerlink" title="Redis持久化，各个持久化的参数，开启持久化会影响性能吗"></a>Redis持久化，各个持久化的参数，开启持久化会影响性能吗</h2><p><strong>RDB(Redis DataBase)</strong><br>在指定的时间间隔内将内存中的数据集快照写入磁盘，它恢复时是将磁盘中的快照文件直接读到内存中<br><strong>配置文件参数：</strong><br><strong>save：秒钟 写操作次数</strong><br>save 60 10000 1分钟内改了1万次<br>save 300 10 5分钟内改了10次<br>save 900 1 15分钟内改了1次</p>
<p><strong>Stop-writes-on-bgsave-error：</strong>表示后台存储出现错误，停止写操作，如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制</p>
<p> <strong>rdbcompression：</strong>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</p>
<p> <strong>rdbchecksum：</strong>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p>
<p> <strong>dbfilename：</strong>指定本地数据库文件名，默认值为dump.rdb</p>
<p> <strong>dir：</strong>指定本地数据库存放目录，dir ./</p>
<p><strong>优势：</strong><br>适合大规模的数据恢复<br>对数据完整性和一致性要求不高</p>
<p><strong>劣势：</strong><br>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改<br>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p>
<p><strong>AOF(Append Only File)</strong><br>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话，就根据日志文件的内容将写指令从前到后执行一次来完成数据的恢复工作。<br><strong>配置文件参数：**</strong>Appendonly：**是否开启aof，默认是no</p>
<p><strong>Appendfilename：</strong>存储aof文件的文件名</p>
<p><strong>Appendfsync：</strong>生成aof文件的策略</p>
<p>Always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p>
<p>Everysec：<strong>出厂默认推荐，异步操作，每秒记录</strong>。如果一秒内宕机，有数据丢失</p>
<p>No</p>
<p><strong>No-appendfsync-on-rewrite：</strong>重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</p>
<p><strong>Auto-aof-rewrite-min-size</strong>：设置重写的基准值，一般是新生成的aof文件是原来的一倍</p>
<p><strong>Auto-aof-rewrite-percentage</strong>：设置重写的基准值，默认是64mb</p>
<p><strong>优势：</strong><br>每修改同步：appendfsync always  同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好<br>每秒同步：appendfsync everysec  异步操作，每秒记录  如果一秒内宕机，有数据丢失<br>不同步：appendfsync no  从不同步</p>
<p><strong>劣势：</strong></p>
<p>1.相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb<br>2.Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</p>
<p><strong>二者总结：</strong><br>1.RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储<br>2.AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大<br>3.只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.<br>4.同时开启两种持久化方式<br>    1.在这种情况下,当redis重启的时候<strong>会优先载入AOF文件</strong>来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.<br>    2.<strong>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件</strong>。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。<br>5.性能建议：<br>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。<br>如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。<strong>代价一</strong>是带来了持续的IO，<strong>二</strong>是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。<br>如果不Enable AOF ，<strong>仅靠Master-Slave Replication 实现高可用性也可以</strong>。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。</p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="为什么使用MQ？"><a href="#为什么使用MQ？" class="headerlink" title="为什么使用MQ？"></a>为什么使用MQ？</h2><p>异步处理：相比于传统的串行、并行方式，提高了系统吞吐量</p>
<p>应用解耦：系统间通过消息处理，不用关心其他系统的处理</p>
<p>流量削峰：可以通过消息队列长度控制请求量；可以缓解短时间内的高并发要求</p>
<p>日志处理：解决大量日志传输</p>
<p>消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如聊天室、实现点对点消息队列</p>
<h2 id="RabbitMQ和其它消息队列，比如ActiveMQ，RocketMQ，Kafka有什么区别"><a href="#RabbitMQ和其它消息队列，比如ActiveMQ，RocketMQ，Kafka有什么区别" class="headerlink" title="RabbitMQ和其它消息队列，比如ActiveMQ，RocketMQ，Kafka有什么区别"></a>RabbitMQ和其它消息队列，比如ActiveMQ，RocketMQ，Kafka有什么区别</h2><p>ActiveMQ：老牌消息队列，但在高并发大数据场景会出现阻塞、消息堆积、延迟等问题。集群架构简单：Master-Slave模式和NetWork模式</p>
<p>Kafka：主要特点基于PULL模式来处理信息消费，追求高吞吐量。一开始目的是用于日志收集和传输，0.8版本支持复制，但是不支持事务，对消息的重复，丢失，错误没有严格要求。适合大数据领域。它的性能是最高的，吞吐量最大。</p>
<p>RocketMQ：思路起源于Kafka，对消息可靠传输以及事务性做了优化。具有高性能、高可用、支持分布式事务、水平扩展、上亿级别的消息堆积、主从的自由切换。集群架构不用zookeeper而是使用Name Sever进行集群拓扑搭建。但是最大的问题是商业版收费，有很多功能是不对外提供的</p>
<p>RabbitMQ：基于erlang语言开发，基于AMQP协议来实现。具有性能好，可靠性好，稳定性好，开源，集群模式丰富等优点。性能介于ActiveMQ和Kafka之间。</p>
<h2 id="RabbitMQ有哪些组件-2"><a href="#RabbitMQ有哪些组件-2" class="headerlink" title="RabbitMQ有哪些组件*2"></a>RabbitMQ有哪些组件*2</h2><p>Server（又称Broker）、Channel、Virtual Host、Exchange、Binding、Queue、Routing Key</p>
<h2 id="主流MQ有哪些"><a href="#主流MQ有哪些" class="headerlink" title="主流MQ有哪些"></a>主流MQ有哪些</h2><p>ActiveMQ、Kafka、RocketMQ、RabbitMQ</p>
<h2 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h2><p>首先讲一个出现消息顺序错乱的场景</p>
<p>1.一个queue对应多个consumer去消费。consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，出现数据顺序错乱</p>
<p>2.一个queue对应一个consumer，但是consumer里面进行了多线程消费，这样也会造成消息消费顺序错乱。</p>
<p>解决</p>
<p>对于第一个场景，将一个queue拆分成多个queue，每个queue对应一个consumer。生产者发送3个消息到一个queue里面，这三个消息具有先后顺序，使用关键值哈希等操作，将具有先后顺序的消息发送到一个queue里面，这样就只有一个消费者去消费这个queue，这样消费便有了保障。不过这样会造成吞吐量下降的影响</p>
<p>对于第二个场景，让consumer内部用内存队列做排队，然后发给底层不同的worker来处理。消费者不再去直接消费消息，而是将消息保存在内存队列中，根据关键值进行哈希操作，将关键值相同的数据发送到相同的消息队列里面。消费者线程直接去消息队列获取消息消费，这样就可以保证消息的消费顺序。</p>
<h2 id="消息基于什么传输"><a href="#消息基于什么传输" class="headerlink" title="消息基于什么传输"></a>消息基于什么传输</h2><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p>
<h2 id="讲讲消费模式和刷盘策略"><a href="#讲讲消费模式和刷盘策略" class="headerlink" title="讲讲消费模式和刷盘策略"></a>讲讲消费模式和刷盘策略</h2><h2 id="RabbitMQ的特性"><a href="#RabbitMQ的特性" class="headerlink" title="RabbitMQ的特性"></a>RabbitMQ的特性</h2><h2 id="RabbitMQ的延时队列"><a href="#RabbitMQ的延时队列" class="headerlink" title="RabbitMQ的延时队列"></a>RabbitMQ的延时队列</h2><p><a href="https://www.cnblogs.com/mfrank/p/11260355.html" target="_blank" rel="noopener">https://www.cnblogs.com/mfrank/p/11260355.html</a></p>
<p>通过TTL(Time To Live)和死信队列完成延时队列<br><strong>基本思路：</strong><br>延时队列是让消息延时被消费，那么使用TLL，能让消息在指定时间内成为死信，成为死信的消息都会被投递到死信队列中，这样只需要消费者一直消费死信队列里的消息就可以实现延时队列的功能。</p>
<p><strong>具体方法：</strong><br>生产者生产一条延时消息，根据需要延时时间的不同，利用不同的RoutingKey将消息路由到不同的延时队列，每个队列都设置不同的TTL属性，并绑定在同一个私信交换机中，消息过期后，根据RoutingKey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列即可<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F.webp" alt=""></p>
<p><strong>存在问题：</strong><br>每增加一个新的时间延时需求就需要新增一个队列，这样如果需要许多不同的时间延时需求就需要增加许多队列。<br>如果将不同的TTL设置到同一个队列中，因为RabbitMQ的消费端只会根据队列中消息的顺序，首先消费在队列首部的消息，检查这个消息是否会过期，如果过期就丢到死信队列中。如果排在第一个消息的过期时间设置的很长，排在后面的消息先过期了，这种情况下也是要先消费第一个消息。</p>
<p><strong>解决：</strong><br>使用RabbitMQ插件可以解决该问题。下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring的IOC和DI"><a href="#Spring的IOC和DI" class="headerlink" title="Spring的IOC和DI"></a>Spring的IOC和DI</h2><p><strong>IOC是控制反转</strong>，原本对一个对象的操作是由程序代码来控制，而IOC则是将对对象的控制以及其依赖通过容器来实现统一管理。通过容器统一对对象进行组件的装配和管理。</p>
<p><strong>DI是依赖注入</strong>，是IOC主要实现方式。依赖注入是指对象被动的接收依赖类而不用自己主动去找，对象不是从容器中查找它依赖的类，而是在容器中实例化对象时主动将它依赖的类注入给它。比如一个Car类里面有个属性是Engine类型，那么依赖注入就会在创建Car的时候自动创建Engine对象自动注入给成员变量。Spring是通过反射来实现的注入的。</p>
<p>依赖注入的实现方法有：通过xml文件中properties的setter方法注入、通过构造器注入、通过接口注入</p>
<h2 id="IOC初始化过程"><a href="#IOC初始化过程" class="headerlink" title="IOC初始化过程"></a>IOC初始化过程</h2><p>IOC初始化过程包括Resource定位、载入和注册过程。这一过程在refresh中ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();进行，最终得到bean工厂。<br>首先就是将资源定位，资源也就是BeanDefinition，应该就是XML信息，最后返回一个resource对象。然后将定位到的信息通过XML的解析器得到document对象，这些对象并没有按照Spring Bean规则解析。完成通用XML文件解析后，按照Spring Bean规则进行解析。最后将解析好的信息统一注册到ioc容器中，通过hashMap来维护，key为beanName，value为BeanDefination。</p>
<p><a href="https://www.jianshu.com/p/70886997c46b" target="_blank" rel="noopener">https://www.jianshu.com/p/70886997c46b</a></p>
<h2 id="DI相关注解"><a href="#DI相关注解" class="headerlink" title="DI相关注解"></a>DI相关注解</h2><p><code>@Autowired</code>：自动按类型注入，如果有多个匹配则按照指定 Bean 的 id 查找，查找不到会报错。</p>
<p><code>@Qualifier</code>：在自动按照类型注入的基础上再按照 Bean 的 id 注入，给变量注入时必须搭配 <code>@Autowired</code>，给方法注入时可单独使用。</p>
<p><code>@Resource</code> ：直接按照 Bean 的 id 注入，只能注入 Bean 类型。</p>
<p><code>@Value</code> ：用于注入基本数据类型和 String 类型。</p>
<h2 id="DI的过程"><a href="#DI的过程" class="headerlink" title="DI的过程"></a>DI的过程</h2><p>refresh()方法中的finishBeanFactoryInitialization(beanFactory);初始化所有的非懒加载的单例bean</p>
<p>进入上述方法中，该方法是AbstractApplicationContext类（实现了BeanFactory接口）的方法，里面有个beanFactory.preInstantiateSingletons();调用方法进行单例的初始化</p>
<p>BeanFactory接口中的getBean()作为入口。也就是我们第一次向SpringIoC索取bean的时候。</p>
<p>getBean()的实现是在AbstractBeanFactory的doGetBean()，这个方法主要是获取bean的信息并且创建bean的实例。主要通过createBean()来实现。</p>
<p>createBean()主要是通过子类AbstractAutowireCapableBeanFactory来实现的，这个方法主要是对bean信息的判断，比如bean是否可实例化，是否能被类加载器加载等。方法里调用了doCreateBean();</p>
<p>doCreateBean()里做了两件事,1.通过createBeanInstance()来实例化bean。2.populateBean()来注入bean的依赖关系。</p>
<p>bean的实例化是通过CGLIB来进行的,主要是通过SimpleInstantiationStrategy这个类来生成bean对象的,主要有两种方法,一种是通过beanUtil反射，另一种是使用CGLIB来实例化对象</p>
<p>在 populateBean方法中，注入过程主要分为两种情况：① 属性值类型不需要强制转换时，不需要解析属性值，直接进行依赖注入。② 属性值类型需要强制转换时，首先解析属性值，然后对解析后的属性值进行依赖注入。依赖注入的过程就是将 Bean 对象实例设置到它所依赖的 Bean 对象属性上，真正的依赖注入是通过 setPropertyValues 方法实现的，该方法使用了委派模式。</p>
<p>BeanWrapperImpl 类负责对完成初始化的 Bean 对象进行依赖注入，对于非集合类型属性，使用 JDK 反射，通过属性的 setter 方法为属性设置注入后的值。对于集合类型的属性，将属性值解析为目标类型的集合后直接赋值给属性。</p>
<p><a href="https://www.jianshu.com/p/96635555f756" target="_blank" rel="noopener">https://www.jianshu.com/p/96635555f756</a></p>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>生命周期：bean的创建和销毁<br>单实例bean：容器启动的时候就创建好，容器关闭销毁<br>容器开启，创建好bean（执行构造方法）——&gt; 初始化方法——&gt;容器关闭，销毁方法<br>多实例bean：获取该bean时才创建<br>容器开启——&gt;获取bean（创建bean，执行构造方法）——&gt;初始化方法——&gt;容器关闭（不会调用bean的销毁方法）<br>初始化方法和销毁方法可以自定义。<br>XML 方式通过配置 bean 标签中的 init-Method 和 destroy-Method 指定自定义初始化和销毁方法。<br>注解方式通过 <code>@PreConstruct</code> 和 <code>@PostConstruct</code> 注解指定自定义初始化和销毁方法。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C31.png" alt=""></p>
<h2 id="bean的作用范围-作用域"><a href="#bean的作用范围-作用域" class="headerlink" title="bean的作用范围/作用域"></a>bean的作用范围/作用域</h2><p>通过 scope 属性指定 bean 的作用范围，包括：</p>
<p>① singleton：单例模式，是默认作用域，不管收到多少 Bean 请求每个容器中只有一个唯一的 Bean 实例。</p>
<p>② prototype：原型模式，和 singleton 相反，每次 Bean 请求都会创建一个新的实例。</p>
<p>③ request：每次 HTTP 请求都会创建一个新的 Bean 并把它放到 request 域中，在请求完成后 Bean 会失效并被垃圾收集器回收。</p>
<p>④ session：和 request 类似，确保每个 session 中有一个 Bean 实例，session 过期后 bean 会随之失效。</p>
<p>⑤ global session：当应用部署在 Portlet 容器时，如果想让所有 Portlet 共用全局存储变量，那么该变量需要存储在 global session 中。</p>
<h2 id="如何通过XML方式创建Bean"><a href="#如何通过XML方式创建Bean" class="headerlink" title="如何通过XML方式创建Bean"></a>如何通过XML方式创建Bean</h2><p>默认无参构造方法，只需要在bean标签中指明id和class的属性即可。也可以手动给属性赋值，或者使用constructor-arg标签赋值。</p>
<p>静态工厂方法，通过bean标签中的class属性指明静态工厂，factory-method指明静态工厂方法。</p>
<p>实例工厂方法，通过bean标签中的factory-bean属性指明实例工厂，factory-method指明实例工厂方法。</p>
<p>使用FactoryBean接口，只要是这个接口的实现类，Spring都认为是一个工厂。将这个类配置在配置文件，但实际运行获取的bean是该工厂返回的实例。但是在容器启动时是不会创建实例的。</p>
<h2 id="如何通过注解创建Bean"><a href="#如何通过注解创建Bean" class="headerlink" title="如何通过注解创建Bean"></a>如何通过注解创建Bean</h2><p><code>@Component</code> 把当前类对象存入 Spring 容器中，相当于在 xml 中配置一个 bean 标签。value 属性指定 bean 的 id，默认使用当前类的首字母小写的类名。</p>
<p><code>@Controller</code>，<code>@Service</code>，<code>@Repository</code> 三个注解都是 <code>@Component</code>  的衍生注解，作用及属性都是一模一样的。只是提供了更加明确语义，<code>@Controller</code> 用于表现层，<code>@Service</code>用于业务层，<code>@Repository</code>用于持久层。如果注解中有且只有一个 value 属性要赋值时可以省略 value。</p>
<p>如果想将第三方的类变成组件又没有源代码，也就没办法使用 <code>@Component</code> 进行自动配置，这种时候就要使用 <code>@Bean</code> 注解。被 <code>@Bean</code> 注解的方法返回值是一个对象，将会实例化，配置和初始化一个新对象并返回，这个对象由 Spring 的 IoC 容器管理。name 属性用于给当前 <code>@Bean</code>  注解方法创建的对象指定一个名称，即 bean 的 id。当使用注解配置方法时，如果方法有参数，Spring 会去容器查找是否有可用 bean对象，查找方式和 <code>@Autowired</code> 一样。</p>
<h2 id="如何通过注解配置文件"><a href="#如何通过注解配置文件" class="headerlink" title="如何通过注解配置文件"></a>如何通过注解配置文件</h2><p><code>@Configuration</code> 用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解，value 属性用于指定配置类的字节码。</p>
<p><code>@ComponentScan</code> 用于指定 Spring 在初始化容器时要扫描的包。basePackages 属性用于指定要扫描的包。</p>
<p><code>@PropertySource</code> 用于加载 <code>.properties</code> 文件中的配置。value 属性用于指定文件位置，如果是在类路径下需要加上 classpath。</p>
<p><code>@Import</code> 用于导入其他配置类，在引入其他配置类时可以不用再写 <code>@Configuration</code> 注解。有 <code>@Import</code> 的是父配置类，引入的是子配置类。value 属性用于指定其他配置类的字节码。</p>
<h2 id="BeanFactory、FactoryBean和ApplicationContext的区别"><a href="#BeanFactory、FactoryBean和ApplicationContext的区别" class="headerlink" title="BeanFactory、FactoryBean和ApplicationContext的区别"></a>BeanFactory、FactoryBean和ApplicationContext的区别</h2><p>BeanFactory 是一个 Bean 工厂，使用简单工厂模式，<strong>是 Spring IoC 容器顶级接口</strong>，可以理解为含有 Bean 集合的工厂类，作用是管理 Bean，包括实例化、定位、配置对象及建立这些对象间的依赖。BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才实例化与装配依赖关系，<strong>属于延迟加载，适合多例模式</strong>。</p>
<p>FactoryBean 是一个工厂 Bean，使用了工厂方法模式，作用是生产其他 Bean 实例，可以通过实现该接口，提供一个工厂方法来自定义实例化 Bean 的逻辑。FactoryBean 接口由 BeanFactory 中配置的对象实现，这些对象本身就是用于创建对象的工厂，如果一个 Bean 实现了这个接口，那么它就是创建对象的工厂 Bean，而不是 Bean 实例本身。</p>
<p>ApplicationConext <strong>是 BeanFactory 的子接口</strong>，扩展了 BeanFactory 的功能，提供了支持国际化的文本消息，统一的资源文件读取方式，事件传播以及应用层的特别配置等。容器会在初始化时对配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化时就已经完成，<strong>属于立即加载，适合单例模式，一般推荐使用</strong>。</p>
<h2 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h2><p>AOP是面向切面编程，就是将某段代码动态的切入到指定方法的指定位置进行运行的编程方式。并将这些指定代码命名为切面即”Aspect”。切面就是那些与业务无关，却为业务模块所共同调用的逻辑或者责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，有利于未来的可操作性和可维护性。</p>
<p>Spring根据被代理类是否实现接口来判断动态代理的方式，如果实现接口，则会使用JDK的动态代理，核心是InvocationHandler接口并复写invoke方法，还有返回Proxy类。如果没有实现接口会使用CGLib动态代理，CGLib是在运行时生成某类的子类，如果某个类被标记为final，则无法使用CGLib</p>
<h2 id="AOP的相关注解有哪些"><a href="#AOP的相关注解有哪些" class="headerlink" title="AOP的相关注解有哪些"></a>AOP的相关注解有哪些</h2><p>@Aspect：声明被注解的类是一个切面类</p>
<p>@Before：前置通知，在目标方法运行之前运行</p>
<p>@After：后置通知，在目标方法运行之后运行</p>
<p>@AfterReturning：返回通知，在目标方法正常返回后运行</p>
<p>@AfterThrowing：异常通知，在目标方法抛出异常后运行</p>
<p>@Around：环绕通知</p>
<h2 id="AOP的相关术语有什么"><a href="#AOP的相关术语有什么" class="headerlink" title="AOP的相关术语有什么"></a>AOP的相关术语有什么</h2><p><code>Aspect</code>：切面，一个关注点的模块化，这个关注点可能会横切多个对象。</p>
<p><code>Joinpoint</code>：连接点，程序执行过程中的某一行为，即业务层中的所有方法。。</p>
<p><code>Advice</code>：通知，指切面对于某个连接点所产生的动作，包括前置通知、后置通知、返回后通知、异常通知和环绕通知。</p>
<p><code>Pointcut</code>：切入点，指被拦截的连接点，切入点一定是连接点，但连接点不一定是切入点。</p>
<p><code>Proxy</code>：代理，Spring AOP 中有 JDK 动态代理和 CGLib 代理，目标对象实现了接口时采用 JDK 动态代理，反之采用 CGLib 代理。</p>
<p><code>Target</code>：代理的目标对象，指一个或多个切面所通知的对象。</p>
<p><code>Weaving</code> ：织入，指把增强应用到目标对象来创建代理对象的过程。</p>
<h2 id="AOP过程"><a href="#AOP过程" class="headerlink" title="AOP过程"></a>AOP过程</h2><p>生成Aop代理对象是通过一个<strong>BeanPostProcessor</strong>类完成的，即<strong>AnnotationAwareAspectJAutoProxyCreator</strong>，所以需要获取该对象。<br>在Spirng的IOC容器启动过程中的refresh方法里，BeanPostProcessor类的注册是在registerBeanPostProcessors中完成的。在这个方法中，先后完成AnnotationAwareAspectJAutoProxyCreator的创建和注册。<br>然后在创建Bean对象时，创建目标代理对象。在Bean对象创建中，一直跟踪到doCreateBean()方法，里面有一个initializeBean()方法，这是用来创建完Bean，并依赖注入结束后进行各种方法的回调。在这个方法里面有一个applyBeanPostProcessorsAfterInitialization()方法，该方法里面会使用上面注册的后置处理器来为该Bean创建AOP代理对象。进入到这个方法里面，首先就是先获取所有的BeanPostProcessor，循环到AnnotationAwareAspectJAutoProxyCreator这个时，就会调用该类的方法为目前的Bean创建AOP代理对象。根据是否实现接口判断是使用CGLib还是JDK创建AOP代理对象。</p>
<p><a href="https://www.douban.com/note/717482377/" target="_blank" rel="noopener">https://www.douban.com/note/717482377/</a></p>
<h2 id="Spring哪里用到了反射"><a href="#Spring哪里用到了反射" class="headerlink" title="Spring哪里用到了反射"></a>Spring哪里用到了反射</h2><p>创建Bean对象时使用BeanUtil反射来完成</p>
<p>Spring和Spring Boot的区别是什么</p>
<h2 id="Spring循环依赖如何解决"><a href="#Spring循环依赖如何解决" class="headerlink" title="Spring循环依赖如何解决"></a>Spring循环依赖如何解决</h2><p>Spring循环依赖分为构造器循环依赖和属性循环依赖</p>
<p>构造器循环依赖就是构造方法中有属性循环依赖。比如创建A时，执行A的构造方法需要B，故这时要创建B，但执行B的构造方法时需要A，这是就形成了构造器循环依赖，这种情况无法解决。</p>
<p>属性循环依赖是指A类中有个属性是B类，B类中有个属性是A类，在给A的成员变量初始化时，需要创建B，在创建B成员变量初始化时，又需要创建A，故这时形成了属性循环依赖。</p>
<p>Spring解决的方法时，在创建Bean的过程中，设有3级缓存，其中<strong>singletonObjects</strong>里面<strong>存放的是初始化之后的单例对象</strong>；<strong>earlySingletonObjects</strong>中存放的是一个<strong>已完成实例化未完成初始化的早期单例对象</strong>；而<strong>singletonFactories</strong>中存放的是ObjectFactory对象，此对象的getObject方法返回值即<strong>刚完成实例化还未开始初始化的单例对象</strong>。所以先后顺序是，单例对象先存在于singletonFactories中，后存在于earlySingletonObjects中，最后初始化完成后放入singletonObjects中。所以当创建A时，首先通过createBeanInstance实例化A对象，又将该实例化的对象通过addSingletonFactory方法放入第三级singletonFactories中，完成A对象早期的暴露；此时A对象的属性均为初始化。然后在通过populateBean方法对A对象进行属性的注入时，需要创建B对象，故触发getBean方法创建B并初始化。同样B在通过populateBean方法进行属性注入时，需要A，A调用getBean方法时，发现此时可以在缓存中拿到A，故能成功给属性A赋值，B创建完毕，放入到缓存中，前面的A随即也创建完成。</p>
<p><a href="https://www.cnblogs.com/zzq6032010/p/11406405.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzq6032010/p/11406405.html</a></p>
<h2 id="Spring生命周期"><a href="#Spring生命周期" class="headerlink" title="Spring生命周期"></a>Spring生命周期</h2><h2 id="Spring用了哪些设计模式"><a href="#Spring用了哪些设计模式" class="headerlink" title="Spring用了哪些设计模式"></a>Spring用了哪些设计模式</h2><p>工厂模式<br>模板模式<br>代理模式<br>策略模式<br>单例模式</p>
<h2 id="Resource和-Autowired的区别"><a href="#Resource和-Autowired的区别" class="headerlink" title="@Resource和@Autowired的区别"></a>@Resource和@Autowired的区别</h2><p>@Autowired是按byType自动注入，而@Resource是按byName自动注入。@Resource有两个重要的属性，分别是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。如果使用name属性，则使用byName的自动注入策略，而使用type属性时，则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过发射机制使用byName自动注入策略。</p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="SpringMVC的处理流程"><a href="#SpringMVC的处理流程" class="headerlink" title="SpringMVC的处理流程"></a>SpringMVC的处理流程</h2><p>Web容器启动时会通知Spring初始化容器，加载Bean的定义信息并初始化所有单例Bean，然后遍历容器中的Bean，获取每一个Controller中的所有方法访问的URL，将URL和对应的Controller保存到一个集合中。</p>
<p>当有请求过来时，DispatcherServlet前端控制器就会将这些请求拦截，然后通过调用doDispatch()方法进行处理。</p>
<p>​            1.调用getHandler()：根据当前请求地址找到能处理这个请求的目标处理类（处理器）。请求HandlerMapping找出容器中被 <code>@Controler</code> 注解修饰的 Bean 以及被 <code>@RequestMapping</code> 修饰的方法和类，生成 Handler 和 HandlerInterceptor 并以一个 HandlerExcutionChain 处理器执行链的形式返回。  </p>
<p>​            2.getHandlerAadapter()：根据当前处理器类获取到能执行这个处理器方法的适配器。根据当前处理器类，找到当前类的            HandlerAdapter（适配器）。通过该适配器将请求参数绑定到方法的形参上</p>
<p>​            3.使用刚才获取到的适配器（AnnotationMethodHandlerAdapter）执行目标方法</p>
<p>​            4.目标方法执行后会返回一个ModelAndView对象</p>
<p>​            5.将ModelAndView通过ViewResolver解析得到View对象，然后将View调用render()方法进行渲染，将数据填充到视图中。转发到具体的页面，并可以在请求域中取出ModelAndView中的模型数据。</p>
<h2 id="SpringMVC有哪些组件"><a href="#SpringMVC有哪些组件" class="headerlink" title="SpringMVC有哪些组件"></a>SpringMVC有哪些组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** MultipartResolver used by this servlet */</span></span><br><span class="line"><span class="comment">//文件上传解析器</span></span><br><span class="line"><span class="keyword">private</span> MultipartResolver multipartResolver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** LocaleResolver used by this servlet */</span></span><br><span class="line"><span class="comment">//区域信息解析器，与国际化有关</span></span><br><span class="line"><span class="keyword">private</span> LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ThemeResolver used by this servlet */</span></span><br><span class="line"><span class="comment">//主题解析器，支持强大的主题效果更换，用的很少</span></span><br><span class="line"><span class="keyword">private</span> ThemeResolver themeResolver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of HandlerMappings used by this servlet */</span></span><br><span class="line"><span class="comment">//Handler映射信息</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of HandlerAdapters used by this servlet */</span></span><br><span class="line"><span class="comment">//Handler的适配器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of HandlerExceptionResolvers used by this servlet */</span></span><br><span class="line"><span class="comment">//异常解析器。SpringMVC强大的异常解析功能</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** RequestToViewNameTranslator used by this servlet */</span></span><br><span class="line"><span class="comment">//将请求地址转换为视图名</span></span><br><span class="line"><span class="keyword">private</span> RequestToViewNameTranslator viewNameTranslator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** FlashMapManager used by this servlet */</span></span><br><span class="line"><span class="comment">//SpringMVC中允许重定向携带数据的功能</span></span><br><span class="line"><span class="keyword">private</span> FlashMapManager flashMapManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of ViewResolvers used by this servlet */</span></span><br><span class="line"><span class="comment">//视图解析器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br></pre></td></tr></table></figure>





<h2 id="SpringMVC的相关注解"><a href="#SpringMVC的相关注解" class="headerlink" title="SpringMVC的相关注解"></a>SpringMVC的相关注解</h2><p><code>@Controller</code>：在类定义处添加，将类交给IoC容器管理。</p>
<p><code>@RequtestMapping</code>：将URL请求和业务方法映射起来，在类和方法定义上都可以添加该注解。<code>value</code> 属性指定URL请求的实际地址，是默认值。<code>method</code> 属性限制请求的方法类型，包括GET、POST、PUT、DELETE等。如果没有使用指定的请求方法请求URL，会报405 Method Not Allowed 错误。<code>params</code> 属性限制必须提供的参数，如果没有会报错。</p>
<p><code>@RequestParam</code>：如果 Controller 方法的形参和 URL 参数名一致可以不添加注解，如果不一致可以使用该注解绑定。<code>value</code> 属性表示HTTP请求中的参数名。<code>required</code> 属性设置参数是否必要，默认false。<code>defaultValue</code> 属性指定没有给参数赋值时的默认值。</p>
<p><code>@PathVariable</code>：Spring MVC 支持 RESTful 风格 URL，通过 <code>@PathVariable</code> 完成请求参数与形参的绑定。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="MyBatis的优缺点"><a href="#MyBatis的优缺点" class="headerlink" title="MyBatis的优缺点"></a>MyBatis的优缺点</h2><p>优点：</p>
<p>相比JDBC减少了大量代码量，减少冗余代码</p>
<p>使用灵活，SQL语句写在XML中，从程序代码中彻底分离，降低了耦合度，便于管理</p>
<p>提供XML标签，支持编写动态SQL语句</p>
<p>提供映射标签，支持对象与数据库的ORM字段映射关系</p>
<p>缺点：</p>
<p>SQL语句编写工作量较大，尤其是字段和关联表多时</p>
<p>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</p>
<h2 id="MyBatis的XML文件有哪些标签属性"><a href="#MyBatis的XML文件有哪些标签属性" class="headerlink" title="MyBatis的XML文件有哪些标签属性"></a>MyBatis的XML文件有哪些标签属性</h2><p><code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 标签分别对应查询、添加、更新、删除操作。</p>
<p><code>parameterType</code>  属性表示参数的数据类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型，当有多个参数时可以使用 <code>#{argn}</code> 的形式表示第 n 个参数。除了基本数据类型都要以全限定类名的形式指定参数类型。</p>
<p><code>resultType</code>  表示返回的结果类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型。还可以使用把返回结果封装为复杂类型的 <code>resultMap</code> 。</p>
<h2 id="MyBatis的一级缓存是什么"><a href="#MyBatis的一级缓存是什么" class="headerlink" title="MyBatis的一级缓存是什么"></a>MyBatis的一级缓存是什么</h2><p>一级缓存是 SqlSession 级别，默认开启且不能关闭。</p>
<p>操作数据库时需要创建 SqlSession 对象，对象中有一个 HashMap 存储缓存数据，不同 SqlSession 之间缓存数据区域互不影响。</p>
<p>一级缓存的作用域是 SqlSession 范围的，在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存在缓存中，第二次查询直接从缓存中获取。</p>
<p>如果 SqlSession 执行了 DML 操作（insert、update、delete），Mybatis 必须将缓存清空保证数据有效性。 </p>
<h2 id="MyBatis的二级缓存是什么"><a href="#MyBatis的二级缓存是什么" class="headerlink" title="MyBatis的二级缓存是什么"></a>MyBatis的二级缓存是什么</h2><p>二级缓存是Mapper 级别，默认关闭。</p>
<p>使用二级缓存时多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区，同样使用 HashMap 进行数据存储，相比于一级缓存，二级缓存范围更大，多个 SqlSession 可以共用二级缓存，作用域是 Mapper 的同一个 namespace，不同 SqlSession 两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功后会将数据保存在二级缓存中，第二次可直接从二级缓存中取出数据。</p>
<p>要使用二级缓存，需要在全局配置文件中配置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code> ，再在对应的映射文件中配置一个 <code>&lt;cache/&gt;</code> 标签。</p>
<h2 id="MyBatis-和-的区别"><a href="#MyBatis-和-的区别" class="headerlink" title="MyBatis#{}和${}的区别"></a>MyBatis#{}和${}的区别</h2><p>使用 <code>${}</code>  相当于使用字符串拼接，存在 SQL 注入的风险。不是参数预编译，而是直接和sql语句进行拼串，或字符串替换。变量替换后，${} 对应的变量不会加上单引号 ‘’，这样如何传的是字符串没有单引号就会失败。</p>
<p>但还是有使用场景。sql语句只有参数位置时支持编译的，在不支持参数预编译的位置要进行取值就使用${ }</p>
<p>使用 <code>#{}</code> 相当于使用占位符，可以防止 SQL 注入，不支持使用占位符的地方就只能使用 <code>${}</code> ，典型情况就是动态参数。<code>#{}</code>是参数预编译的方式，参数的位置都是用？替代，变量替换后，#{} 对应的变量自动加上单引号 ‘’。参数后来的值都是预编译设置进去。安全，不会由sql注入问题。</p>
<h2 id="MyBatis中Mapper标注的接口中的方法可以重载吗"><a href="#MyBatis中Mapper标注的接口中的方法可以重载吗" class="headerlink" title="MyBatis中Mapper标注的接口中的方法可以重载吗"></a>MyBatis中Mapper标注的接口中的方法可以重载吗</h2><p>不能。<br><a href="https://blog.csdn.net/unix21/article/details/52239514" target="_blank" rel="noopener">https://blog.csdn.net/unix21/article/details/52239514</a></p>
<h2 id="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h2><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h2 id="MySQL数据库里面有个自增主键，希望在MyBatis中新增的时候能够反返回数据库中的自增主键，怎么配置？如果是非自增主键呢？"><a href="#MySQL数据库里面有个自增主键，希望在MyBatis中新增的时候能够反返回数据库中的自增主键，怎么配置？如果是非自增主键呢？" class="headerlink" title="MySQL数据库里面有个自增主键，希望在MyBatis中新增的时候能够反返回数据库中的自增主键，怎么配置？如果是非自增主键呢？"></a>MySQL数据库里面有个自增主键，希望在MyBatis中新增的时候能够反返回数据库中的自增主键，怎么配置？如果是非自增主键呢？</h2><p><strong>自增主键</strong><br>使用useGenerateKeys标签。将useGenerateKeys设置为true，keyProperty设置哪个属性为自增id，然后进行插入操作。获取id的方式就调用原生jdbc获取自增主键的方法</p>
<p><strong>非自增主键</strong><br>使用selectKey。由于不知道目前的id是多少，就可以先通过selectKey先于插入语句执行获得当前最大id值并+1，然后赋值给即将要插入的id。</p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="spring-boot有哪些提升？"><a href="#spring-boot有哪些提升？" class="headerlink" title="spring boot有哪些提升？"></a>spring boot有哪些提升？</h2><p>1.依赖引入时，不用添加多个。比如想要快速启动一个web容器，之前需要添加多个依赖，而Spring Boot则添加一个下面的依赖即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而这个依赖里面包含多个其他依赖</p>
<p>2.不用大量编写XML配置文件，==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；</p>
<p>3.新建一个类注册进容器中也不会XML文件。使用@Configuration 和@Bean两个注解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">getTestService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Configuration表示该类是个配置类，@Bean表示该方法返回一个 Bean。这样就把TestService作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用注解注入进来即可使用，非常方便。</p>
<p>4.Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目。</p>
<h2 id="spring-boot-starter的过程"><a href="#spring-boot-starter的过程" class="headerlink" title="spring boot starter的过程"></a>spring boot starter的过程</h2><p>spring-boot-starter是场景启动器，帮助我们导入相关模块正常运行所依赖的组件。</p>
<p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<p><strong>Spring帮助完成bean的配置过程（以mybatis为例）</strong><a href="https://www.cnblogs.com/hjwublog/p/10332042.html#autoid-2-0-0" target="_blank" rel="noopener">https://www.cnblogs.com/hjwublog/p/10332042.html#autoid-2-0-0</a></p>
<p><strong>基于java代码的bean配置</strong><br>mybatis-spring-boot-starter引入了mybatis-spring-boot-autoconfigure，这个包中有个MybatisAutoConfiguration类，该类有被@Configuration、和被@Bean标注的方法，SqlSessionFactory、SqlSessionTemplate就是这样被注册进IOC容器中</p>
<p><strong>自动配置条件依赖</strong></p>
<p>从MybatisAutoConfiguration这个类中使用的注解可以看出，要完成自动配置是有依赖条件的。要完成Mybatis的自动配置，需要在类路径中存在SqlSessionFactory.class、SqlSessionFactoryBean.class这两个类，需要存在DataSource这个bean且这个bean完成自动注册。然后这个bean在spring-boot-autoconfigure-2.0.4.RELEASE.jar这个包中，自动配置这个包帮们引入了jdbc、kafka、logging、mail、mongo等包。</p>
<p><strong>bean参数获取</strong></p>
<p>上面是bean配置的过程，但springboot是如何读取配置文件的属性来创建数据源<br>在DataSourceAutoConfiguration类里面有个<strong>EnableConfigurationProperties</strong>注解，这个注解括号里面的类封装了数据源的属性。进入这个类发现还被注解<strong>ConfigurationProperties</strong>指定了配置文件的前缀。<br><strong>@ConfigurationProperties</strong>注解的作用是把yml或者properties配置文件转化为bean。<br><strong>@EnableConfigurationProperties</strong>注解的作用是使@ConfigurationProperties注解生效。如果只配置@ConfigurationProperties注解，在spring容器中是获取不到yml或者properties配置文件转化的bean的。<br>通过这种方式，把yml或者properties配置参数转化为bean</p>
<p><strong>bean发现</strong></p>
<p>springboot默认扫描启动类所在的包下的主类与子类的所有组件，但并没有包括依赖包的中的类，那么依赖包中的bean是如何被发现和加载的？</p>
<p>在启动类中进入<strong>@SpringBootApplication</strong>注解，里面有三个重要的注解：<br><strong>@Configuration</strong>的作用上面我们已经知道了，被注解的类将成为一个bean配置类。<br><strong>@ComponentScan</strong>的作用就是自动扫描并加载符合条件的组件，比如@Component和@Repository等，最终将这些bean定义加载到spring容器中。<br><strong>@EnableAutoConfiguration</strong> 这个注解的功能很重要，借助@Import的支持，收集和注册依赖包中相关的bean定义。<br>第三个注解就是来加载依赖包中的bean。<br>@EnableAutoConfiguration注解引入了<strong>@AutoConfigurationPackage</strong>和<strong>@Import({AutoConfigurationImportSelector.class})</strong>这两个注解。<strong>@AutoConfigurationPackage的作用就是自动配置包，@Import导入需要自动配置的组件</strong>。第一个注解是加载启动类所在的包下的主类与子类的所有组件注册到spring容器。第二个注解进入到括号里的类中，里面有个SpringFactoriesLoader.loadFactoryNames方法，它调用loadSpringFactories方法从所有的jar包中读取META-INF/spring.factories文件信息。spring.factories文件中，其中有一个key为<strong>org.springframework.boot.autoconfigure.EnableAutoConfiguration</strong>的值定义了需要自动配置的bean，通过读取这个配置获取一组@Configuration类。每个xxxAutoConfiguration都是一个基于java的bean配置类。实际上，这些xxxAutoConfiguration不是所有都会被加载，会根据xxxAutoConfiguration上的@ConditionalOnClass等条件判断是否加载。最后通过反射机制将spring.factories中@Configuration类实例化为对应的java实例。</p>
<p><strong>bean加载</strong></p>
<p>如果要让一个普通类交给Spring容器管理，通常有以下方法：<br>1、使用 @Configuration与@Bean 注解<br>2、使用@Controller @Service @Repository @Component 注解标注该类，然后启用@ComponentScan自动扫描<br>3、使用<strong>@Import</strong> 方法<br>SpringBoot中使用了@Import 方法<br>@EnableAutoConfiguration注解中使用了@Import({AutoConfigurationImportSelector.class})注解，AutoConfigurationImportSelector实现了DeferredImportSelector接口，DeferredImportSelector接口继承了ImportSelector接口，ImportSelector接口只有一个<strong>selectImports</strong>方法。<br>selectImports方法返回一组bean，@EnableAutoConfiguration注解借助@Import注解将这组bean注入到spring容器中，springboot正式通过这种机制来完成bean的注入的。</p>
<h2 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h2><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p>
<p>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。</p>
<p>筛选有效的自动配置类。</p>
<p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p>
<h2 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h2><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p>
<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="ElasticSearch为什么查询比MySQL快？"><a href="#ElasticSearch为什么查询比MySQL快？" class="headerlink" title="ElasticSearch为什么查询比MySQL快？"></a>ElasticSearch为什么查询比MySQL快？</h2><p><a href="https://blog.csdn.net/weixin_44588495/article/details/105340593?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-105340593.nonecase&amp;utm_term=es%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E5%BF%AB" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44588495/article/details/105340593?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-105340593.nonecase&amp;utm_term=es%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E5%BF%AB</a></p>
<p><a href="https://blog.csdn.net/qq_18661793/article/details/108211788?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-108211788.nonecase&amp;utm_term=es%E4%B8%AD%E7%B4%A2%E5%BC%95%E5%92%8Cmysql%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">https://blog.csdn.net/qq_18661793/article/details/108211788?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-108211788.nonecase&amp;utm_term=es%E4%B8%AD%E7%B4%A2%E5%BC%95%E5%92%8Cmysql%E7%9A%84%E5%8C%BA%E5%88%AB</a></p>
<h2 id="ES中的translog"><a href="#ES中的translog" class="headerlink" title="ES中的translog"></a>ES中的translog</h2><p><a href="https://blog.51cto.com/sbp810050504/2393306这是大概的介绍" target="_blank" rel="noopener">https://blog.51cto.com/sbp810050504/2393306这是大概的介绍</a></p>
<h1 id="网络编程-Netty"><a href="#网络编程-Netty" class="headerlink" title="网络编程 Netty"></a>网络编程 Netty</h1><h2 id="介绍一下IO模型（BIO-NIO）"><a href="#介绍一下IO模型（BIO-NIO）" class="headerlink" title="介绍一下IO模型（BIO,NIO）"></a>介绍一下IO模型（BIO,NIO）</h2><p><a href="https://www.jianshu.com/p/39e2281d9864" target="_blank" rel="noopener">https://www.jianshu.com/p/39e2281d9864</a></p>
<p>在UNIX中一切皆为文件。文件本质上是一串二进制流，在数据交换过程中，需要对流进行数据的收发操作也就是I/O输入输出操作（<code>Input/Output</code>）。计算机里有这么多的流、我怎么知道要操作哪个流呢？做到这个的就是<strong>文件描述符<code>fd</code></strong>，文件描述符是一个整数，对这个整数的操作就是对流的操作。文件描述符<code>fd</code>（<code>File Descriptor</code>）是一个用于表述指向文件的引用的抽象化概念，文件描述符在形式上是一个非负整数。实际上它是一个索引值，指向内核<code>Kernel</code>为每个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或创建一个新文件时，内核会向进程返回一个文件描述符。</p>
<p><strong>Linux系统中的每次IO都需要经过两个阶段</strong></p>
<ol>
<li>内核准备数据<br> 将数据从磁盘文件中加载到内核内存空间（内核缓冲区），等待数据准备完毕，耗时较长。</li>
<li>将数据从内核拷贝到用户空间<br> 将数据从内核缓冲区复制到用户空间进程的内存中，耗时较短。</li>
</ol>
<p>IO包括内存IO、网络IO、磁盘IO三种，常说的IO是指后两者。以文件IO为例，一个IO读过程是文件数据从“磁盘-内核缓存区-用户内存”的过程。</p>
<p><strong>网络IO</strong>：网络应用需要处理的两大类问题是网络IO和数据计算。相对于数据计算，网络IO的延迟会给应用带来性能上的瓶颈大于后者。<br>网路IO的本质是<code>socket</code>的读取操作，<code>socket</code>在Linux操作系统中被抽象为流<code>stream</code>。IO可以理解为对流的操作。IO编程中<code>Stream</code>流是一个重要的概念，可以把流想象成水管中的水，只能单向流向。<code>Input Stream</code>是数据从外部（如磁盘、网络等）流进内存，<code>Output Steam</code>是数据从内存流到外设。<br>网络IO除了转入内核调用外，与传统的磁盘IO不同的是，网络IO的读写对于<code>socket</code>流而言大致可分为两个阶段：</p>
<ol>
<li><p>等待：等待网络上的数据分组到达，然后复制到内核的某个缓冲区。</p>
</li>
<li><p>复制：将数据从内核缓冲区复制到应用进程缓冲区</p>
</li>
</ol>
<p><strong>BIO 阻塞IO</strong>：在读写时，用户进程若没有接收到数据，就会一直阻塞，直到数据完全地接收到。<br>网络模型中阻塞IO模型中应用程序为了执行<code>read</code>读操作，会调用相应的<code>system call</code>系统调用，将系统控制权交给内核，然后就进入等待，等待的过程是被阻塞的，内核开始执行<code>system call</code>系统调用，执行完毕后会向应用程序返回响应，应用程序得到响应后就不再阻塞并继续后续工作。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C22.png" alt=""></p>
<p><strong>NIO非阻塞模型</strong>：NIO不会等待数据的就绪，如果数据不可读或不可写，相关的系统调用会立即返回。这样做的好处是结合反复轮询来尝试数据是否就绪，那么在一个进程中就可以同时处理多个IO操作。<br>当用户线程发起一个<code>read</code>读操作后并不需要等待，而是马上就得到一个结果。如果结果是一个<code>error</code>错误，就表示数据还没有准备好，于是可以再次发送<code>read</code>读操作。一旦内存中的数据准备好了并且又再次收到用户线程的请求，那么会马上就将数据拷贝到用户线程然后返回。事实上，在非阻塞IO模型中，用户线程需要不断询问内核数据是否就绪，换句话说非阻塞IO不会交出CPU而会一直占用CPU。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C23.png" alt=""></p>
<p>值得注意的是，在非阻塞状态下，IO执行的等待阶段并不是完全阻塞的，但第二个阶段依然处于一个阻塞状态。</p>
<p>当用户进程发出<code>read</code>读操作时会调用相应的<code>system call</code>，这个<code>system call</code>会立即从内核中返回。但在返回的这个时间点中内核中的数据可能还没有准备好，也就是说内核只是很快就返回了<code>system call</code>，只有这样才不会阻塞用户进程。对于应用程序，虽然这个IO操作很快就返回了，但并不知道这个IO操作是否真正成功了，为了知道IO操作是否成功，应用程序需要主动循环的去询问内核。</p>
<p>每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报。当没有数据报准备好时也不会阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮询。但轮询对CPU来说是较大的浪费，一般只有在特定场景下才使用。</p>
<p><strong>多路复用IO模型</strong>：Java NIO实际上就是多路复用IO。IO复用也叫做多路IO就绪通知，是一种进程预先告知内核的能力，内核发现进程指定的一个或多个IO条件就绪了，就会去通知进程，使得一个进程能在一连串的事件上等待。IO多路复用的基本原理是不再由应用程序自己监视连接，取而代之由内核替应用程序监视文件描述符。多路IO就绪通知模型允许进程通过一种方法同时监视所有的文件描述符，并能快速获得所有就绪的文件描述符，然后针对这些文件描述符进行数据访问。实现方式就是通过多路复用器select、poll、epoll实现</p>
<p>需要注意的是，IO就绪模型只是解决了快速获取就绪的文件描述符的问题，在得知数据就绪后，就数据访问本身而言，还是需要选择阻塞或非阻塞的访问方式。</p>
<p><img src="C:%5CUsers%5CZHAN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200812164959345.png" alt="image-20200812164959345">实现原理</p>
<ol>
<li>当进程调用<code>select</code>时会被阻塞</li>
<li>此时内核会监视所有<code>select</code>负责的<code>socket</code>，当<code>socket</code>的数据准备就绪后立即返回</li>
<li>进程再次调用<code>read</code>读操作，数据从内核中拷贝到进程。</li>
</ol>
<p>在多路复用IO模型中会有一个线程不断去轮询多个<code>socket</code>的状态，只有当<code>socket</code>真正有读写事件时，才真正调用实际的IO读写操作。</p>
<p>在多路复用IO模型中，只需要使用一个线程就可以管理多个<code>socket</code>，系统不需要建立新的线程或进程，也不必维护这些进程和线程，只有在真正有<code>socket</code>读写事件进行时才会使用IO资源，所以它大大减少了资源占用。</p>
<p><strong>信号驱动IO模型</strong>：在信号驱动IO模型中，当用户线程发起一个IO请求操作， 会给对应的<code>socket</code>注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C25.png" alt=""></p>
<p>信号驱动IO模型中应用程序告诉内核，当数据包准备好的时候，给我发送一个信号，对<code>SIGIO</code>信号进行捕捉，并且调用我的信号处理函数来获取数据报。</p>
<p>问题缺陷</p>
<p>信号驱动IO模式存在一个很大的问题是Linux中信号队列是有限的，如果超过限制则无法读取数据。</p>
<p><strong>异步IO模型</strong>：异步IO又叫做事件驱动IO，异步IO操作是需要操作系统底层支持。</p>
<p>异步IO模型是最理想的IO模型，在异步IO模型中当用户线程发起<code>read</code>读操作后立即就可以开始去做其它的事情。从内核角度看，当内核收到一个<code>asynchronous read</code>之后会立即返回，说明<code>read</code>请求已经成功发起了，因此不会对用户线程产生任何阻塞<code>block</code>。</p>
<p>然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它<code>read</code>读操作完成了。也就是说用户线程完全不需要知道实际整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时，表示IO操作已经完成可以直接去使用数据了。<br>在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成的，然后发送一个信号告知用户线程操作已经完成。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C26.png" alt=""></p>
<p><strong>小结</strong></p>
<p>前四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第二阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程会让用户线程阻塞</p>
<h2 id="select到epoll有哪些改进"><a href="#select到epoll有哪些改进" class="headerlink" title="select到epoll有哪些改进"></a>select到epoll有哪些改进</h2><p><a href="https://blog.csdn.net/wteruiycbqqvwt/article/details/90299610" target="_blank" rel="noopener">https://blog.csdn.net/wteruiycbqqvwt/article/details/90299610</a></p>
<p>select它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。因为每次要询问哪些文件描述符准备就绪时，都需要将fd_set从用户空间复制到内核空间，然后遍历所有fd，这种开销是非常大的。</p>
<p>epoll是基于事件驱动的，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
<p>epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>　　对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>　　对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果）。</p>
<h2 id="epoll-IO多路复用模型实现机制详解"><a href="#epoll-IO多路复用模型实现机制详解" class="headerlink" title="epoll IO多路复用模型实现机制详解"></a>epoll IO多路复用模型实现机制详解</h2><p>由于epoll的实现机制与select/poll机制完全不同，select的缺点在epoll上不复存在。</p>
<p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树or红黑树？)。把原先的select/poll调用分成了3个部分：</p>
<p>1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</p>
<p>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p>
<p>3）调用epoll_wait收集发生的事件的连接</p>
<p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接</p>
<h2 id="select和poll之间的区别是什么"><a href="#select和poll之间的区别是什么" class="headerlink" title="select和poll之间的区别是什么"></a>select和poll之间的区别是什么</h2><p>区别是select能够监视的文件描述符数量有大小限制，而poll没有。因为select使用数组存放，poll使用的是链表结构</p>
<h2 id="epoll套接字的实现"><a href="#epoll套接字的实现" class="headerlink" title="epoll套接字的实现"></a>epoll套接字的实现</h2><h2 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a>水平触发和边缘触发</h2><p><a href="https://www.jianshu.com/p/7eaa0224d797" target="_blank" rel="noopener">https://www.jianshu.com/p/7eaa0224d797</a></p>
<p>水平触发(Level_triggered)：只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，<br> 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知<br> LT模式支持阻塞和非阻塞两种方式。epoll默认的模式是LT</p>
<p>边缘触发(Edge_trigger)：当文件描述符关联的读内核缓冲区由空转化为非空，写缓冲区由满转化为不满的时候，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会再次通知。</p>
<p>对于水平触发，如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。但是水平触发由于会一直通知你去读写，所以这种模式下，出错误的可能性要小一点。</p>
<h2 id="除了阻塞I-O的其他I-O，用epoll来网络编程的客户端和服务端的步骤"><a href="#除了阻塞I-O的其他I-O，用epoll来网络编程的客户端和服务端的步骤" class="headerlink" title="除了阻塞I/O的其他I/O，用epoll来网络编程的客户端和服务端的步骤"></a>除了阻塞I/O的其他I/O，用epoll来网络编程的客户端和服务端的步骤</h2><p><a href="https://www.cnblogs.com/xujian2014/p/5657540.html" target="_blank" rel="noopener">https://www.cnblogs.com/xujian2014/p/5657540.html</a></p>
<p><a href="https://www.jianshu.com/p/46bba3fe5d9a" target="_blank" rel="noopener">https://www.jianshu.com/p/46bba3fe5d9a</a></p>
<p>配置服务端<br>1、创建ServerSocketChannel，配置它为非阻塞模式<br>2、绑定监听，配置TCP参数，如backlog大小<br>3、创建一个独立的I/O线程，用于轮询多路复用器Selector<br>4、创建Selector，将之前创建的ServerSocketChannel注册到Selector上，监听SelectionKey.ACCEPT<br>5、启动I/O线程，在循环体内执行Selector.select()方法，轮询就绪的Channel<br>6、当轮询到了处于就绪状态的Channel时，需对其进行判断，如果是OP_ACCEPT状态，说明是新的客户端接入，则调用ServerSocketChannel.accept()方法接受新的客户端<br>7、设置新接入的客户端链路SocketChannel为非阻塞模式，配置其他的一些TCP参数<br>8、将SocketChannel注册到Selector，监听OP_WRITE<br>9、如果轮询的Channel为OP_WRITE，则说明要向SockChannel中写入数据，则构造ByteBuffer对象，写入数据包</p>
<p>客户端<br>1.创建SocketChannel，并设置为非阻塞式<br>2.创建Selector，将socketChannel注册进该Selector<br>3.将目的地址和端口号绑定在socketChannel上<br>4.启动I/O线程，在循环体内执行Selector.select()方法，轮询就绪的Channel<br>5.如果是客户端的channel，则执行write方法将信息写出去<br>6.如果是可读channel，则读取<br>7.最后将轮询到key清除。</p>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p><a href="https://www.jianshu.com/p/46bba3fe5d9a" target="_blank" rel="noopener">https://www.jianshu.com/p/46bba3fe5d9a</a></p>
<p>主要组件channel、buffer、selector</p>
<h2 id="负载均衡了解哪些算法"><a href="#负载均衡了解哪些算法" class="headerlink" title="负载均衡了解哪些算法"></a>负载均衡了解哪些算法</h2><p><strong>轮询法</strong>：将服务器的每个IP地址存入map中（因为给出的ip地址是一个ip地址+权重的形式），然后将key值取出来存到list中，设置一个轮询指针，从0开始，每次要连接，就根据当前指针获取key，即ip地址，然后指针+1.当指针走到头时，就从0重新开始<br><strong>随机法</strong>：前面的步骤和轮询法一样，要连接选择ip地址时，用Random类随机出一个数，从list中获取ip地址。<br><strong>源地址哈希法</strong>：前面步骤一致，后面选择ip地址时，先将客户端的ip地址算出哈希值，然后将哈希值模上链表的长度，根据得到的值从list中获取ip地址。<br><strong>加权轮询法</strong>：就是存入list的时候，权重大的多存入，权重小的少存入<br><strong>加权随机法</strong>：同上<br><strong>最小连接数(Least Connections)法</strong>：最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它正是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前请求，尽可能地提高后端服务器的利用效率，将负载合理地分流到每一台机器。<br><strong>最快响应速度法</strong>：根据请求的响应时间，来动态调整每个节点的权重，将<strong>响应速度快的服务节点分配更多的请求</strong>，响应速度慢的服务节点分配更少的请求，俗称能者多劳，扶贫救弱。<br><strong>观察模式法</strong>：观察者模式是综合了<strong>最小连接数和最快响应度</strong>，同时考量这两个指标数，进行一个权重的分配。</p>
<p><a href="https://blog.csdn.net/qq_29373285/article/details/88777503" target="_blank" rel="noopener">https://blog.csdn.net/qq_29373285/article/details/88777503</a></p>
<p><a href="https://www.cnblogs.com/xrq730/p/5154340.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/5154340.html</a></p>
<h2 id="一致性hash的好处，如果节点比较少会出现什么问题"><a href="#一致性hash的好处，如果节点比较少会出现什么问题" class="headerlink" title="一致性hash的好处，如果节点比较少会出现什么问题"></a>一致性hash的好处，如果节点比较少会出现什么问题</h2><p>一致性哈希常用在负载均衡上，可以解决热点问题。而且可以使得服务器失效或者新增时的影响范围达到最小</p>
<p>如果节点较少，可能在环上的节点分布就不均匀，容器到时负载不均衡，对一个节点的负载过大。节点过少，当出现一个节点宕机的情况，可能会导致另一个节点突然增加许多负载，导致压力过大。</p>
<h2 id="Reactor-模型有了解吗"><a href="#Reactor-模型有了解吗" class="headerlink" title="Reactor 模型有了解吗"></a>Reactor 模型有了解吗</h2><p><a href="https://www.jianshu.com/p/eef7ebe28673" target="_blank" rel="noopener">https://www.jianshu.com/p/eef7ebe28673</a></p>
<p><a href="http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html" target="_blank" rel="noopener">http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html</a></p>
<p><a href="https://www.cnblogs.com/winner-0715/p/8733787.html" target="_blank" rel="noopener">https://www.cnblogs.com/winner-0715/p/8733787.html</a></p>
<p>Reactor 就是基于NIO中实现多路复用的一种模式。</p>
<p>reactor设计模式是一种事件处理模式，用于处理由一个或多个输入同时传递给服务处理程序的服务请求。然后，服务处理程序将传入的请求分解，并将它们同步地分派给相关的请求处理程序。<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C27.png" alt=""></p>
<p>reactor主要由以下几个角色构成：handle、Synchronous Event Demultiplexer、Initiation Dispatcher、Event Handler、Concrete Event HandlerHandle</p>
<p><strong>handle</strong><br>在linux中一般称为文件描述符，而在window称为句柄，两者的含义一样。handle是事件的发源地。比如一个网络socket、磁盘文件等。而发生在handle上的事件可以有connection、ready for read、ready for write等。</p>
<p><strong>Synchronous Event Demultiplexer</strong><br>同步事件分离器，本质上是系统调用。比如linux中的select、poll、epoll等。比如，select方法会一直阻塞直到handle上有事件发生时才会返回。</p>
<p><strong>Event Handler</strong><br>事件处理器，其会定义一些回调方法或者称为钩子函数，当handle上有事件发生时，回调方法便会执行，一种事件处理机制。</p>
<p><strong>Concrete Event Handler</strong><br>具体的事件处理器，实现了Event Handler。在回调方法中会实现具体的业务逻辑。</p>
<p><strong>Initiation Dispatcher</strong><br>初始分发器，也是reactor角色，提供了注册、删除与转发event handler的方法。当Synchronous Event Demultiplexer检测到handle上有事件发生时，便会通知initiation dispatcher调用特定的event handler的回调方法。</p>
<p> <strong>处理流程</strong></p>
<p>① 服务器端的Reactor是一个线程对象，该线程会启动事件循环，并使用Selector来实现IO的多路复用。注册一个Acceptor事件处理器到Reactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样Reactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。<br>② 客户端向服务器端发起一个连接请求，Reactor监听到了该ACCEPT事件的发生并将该ACCEPT事件派发给相应的Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将该连接所关注的READ事件以及对应的READ事件处理器注册到Reactor中，这样一来Reactor就会监听该连接的READ事件了。或者当你需要向客户端发送数据时，就向Reactor注册该连接的WRITE事件和其处理器。<br>③ 当Reactor监听到有读或者写事件发生时，将相关的事件派发给对应的处理器进行处理。比如，读处理器会通过SocketChannel的read()方法读取数据，此时read()操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。<br>④ 每当处理完所有就绪的感兴趣的I/O事件后，Reactor线程会再次执行select()阻塞等待新的事件就绪并将其分派给对应处理器进行处理。</p>
<p><strong>另一篇文章的流程</strong><br><strong>Reactor模式模块之间的交互</strong><br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C28.png" alt=""></p>
<p>1.初始化InitiationDispatcher，并初始化一个Handle到EventHandler的Map。</p>
<p>2.注册EventHandler到InitiationDispatcher中，每个EventHandler包含对相应Handle的引用，从而建立Handle到EventHandler的映射（Map）。</p>
<p>3.调用InitiationDispatcher的handle_events()方法以启动Event Loop。在Event Loop中，调用select()方法（Synchronous Event Demultiplexer）阻塞等待Event发生。</p>
<p>4.当某个或某些Handle的Event发生后，select()方法返回，InitiationDispatcher根据返回的Handle找到注册的EventHandler，并回调该EventHandler的handle_events()方法。</p>
<p>5.在EventHandler的handle_events()方法中还可以向InitiationDispatcher中注册新的Eventhandler，比如对AcceptorEventHandler来，当有新的client连接时，它会产生新的EventHandler以处理新的连接，并注册到InitiationDispatcher中。</p>
<p> <strong>Reactor模式实现</strong></p>
<p>在[Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events]中，一直以Logging Server来分析Reactor模式，这个Logging Server的实现完全遵循这里对Reactor描述，因而放在这里以做参考。Logging Server中的Reactor模式实现分两个部分：Client连接到Logging Server和Client向Logging Server写Log。因而对它的描述分成这两个步骤。<br><strong>Client连接到Logging Server</strong></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C29.png" alt=""></p>
<p>1.Logging Server注册LoggingAcceptor到InitiationDispatcher。<br>2.Logging Server调用InitiationDispatcher的handle_events()方法启动。<br>3.InitiationDispatcher内部调用select()方法（Synchronous Event Demultiplexer），阻塞等待Client连接。<br>4. Client连接到Logging Server。<br>5. InitiationDisptcher中的select()方法返回，并通知LoggingAcceptor有新的连接到来。<br>6. LoggingAcceptor调用accept方法accept这个新连接。<br>7. LoggingAcceptor创建新的LoggingHandler。<br>8. 新的LoggingHandler注册到InitiationDispatcher中(同时也注册到Synchonous Event Demultiplexer中)，等待Client发起写log请求。</p>
<p><strong>Client向Logging Server写Log</strong></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C30.png" alt=""></p>
<p>1.Client发送log到Logging server。<br>2.InitiationDispatcher监测到相应的Handle中有事件发生，返回阻塞等待，根据返回的Handle找到LoggingHandler，并回调LoggingHandler中的handle_event()方法。<br>3.LoggingHandler中的handle_event()方法中读取Handle中的log信息。<br>4.将接收到的log写入到日志文件、数据库等设备中。<br>3-4步骤循环直到当前日志处理完成。<br>5.返回到InitiationDispatcher等待下一次日志写请求。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="常见应用层协议使用UDP或TCP来传输"><a href="#常见应用层协议使用UDP或TCP来传输" class="headerlink" title="常见应用层协议使用UDP或TCP来传输"></a>常见应用层协议使用UDP或TCP来传输</h3><p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C57.png" alt=""></p>
<h3 id="下面聊聊Http-Code，你知道-3XX-状态码对应的是什么？"><a href="#下面聊聊Http-Code，你知道-3XX-状态码对应的是什么？" class="headerlink" title="下面聊聊Http Code，你知道 3XX 状态码对应的是什么？"></a>下面聊聊Http Code，你知道 3XX 状态码对应的是什么？</h3><p>3XX状态码对应该请求需要重定向。需要客户端采取进一步的操作才能完成请求</p>
<p>其余状态码对应</p>
<p>1xx状态码对应该请求已被接收，需要继续处理。HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应</p>
<p>2xx状态码对应该请求已成功被服务器接收</p>
<p>4xx状态码对应客户端请求出错</p>
<p>5xx状态码对应服务端出错</p>
<h3 id="常用状态码有哪些，分别什么意思？如404-302-502-503。503和502的区别"><a href="#常用状态码有哪些，分别什么意思？如404-302-502-503。503和502的区别" class="headerlink" title="常用状态码有哪些，分别什么意思？如404,302,502,503。503和502的区别"></a>常用状态码有哪些，分别什么意思？如404,302,502,503。503和502的区别</h3><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h3 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h3><p>http报文分为请求报文和响应报文</p>
<p>这两种报文都是有三个部分组成：开始行、首部行、实体主体</p>
<p>开始行：用于区分请求报文还是响应报文。在请求报文中的开始行叫做<strong>请求行(Request-Line)</strong>，而在响应报文中的开始行叫做<strong>状态行(Status-Line)</strong>。开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表回车和换行</p>
<p>首部行：用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有”回车“和”换行“。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</p>
<p>实体主体：在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</p>
<p>请求报文中的请求行：</p>
<p>请求行只有三个内容，即<strong>方法，请求资源的URL，以及HTTP的版本</strong>。<strong>“方法”</strong>是面向对象技术中使用的专门名词。所谓“方法”就是对所请求的对象进行的<strong>操作</strong>，因此<strong>这些方法实际上也就是一些命令</strong>。因此，请求报文的类型是由它所采用的方法决定的。</p>
<p>响应报文的第一行就是状态行，包括三项内容，即<strong>HTTP版本、状态码、以及解释状态码的简单短语</strong>。</p>
<h3 id="Http了解吗？讲一讲"><a href="#Http了解吗？讲一讲" class="headerlink" title="Http了解吗？讲一讲"></a>Http了解吗？讲一讲</h3><p>Http全称是超文本传输协议，是因特网上应用最为广泛的一种网络传输协议。是一个基于TCP/IP通信协议来传递数据（HTML文件，图片文件，查询结果等）。从层次的角度看，HTTP是面向事务的应用层协议。</p>
<p>HTTP协议工作在客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。WEB服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>HTTP三点注意事项：</p>
<ul>
<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li>
<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ul>
<h3 id="详细介绍一下HTTP请求响应的过程"><a href="#详细介绍一下HTTP请求响应的过程" class="headerlink" title="详细介绍一下HTTP请求响应的过程"></a>详细介绍一下HTTP请求响应的过程</h3><p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C63.png" alt=""></p>
<h3 id="Http1-0和Http1-1区别"><a href="#Http1-0和Http1-1区别" class="headerlink" title="Http1.0和Http1.1区别"></a>Http1.0和Http1.1区别</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ol>
<li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ol>
<h3 id="http2-0、https了解吗？讲一下连接过程（非对称加密，对称加密）-2"><a href="#http2-0、https了解吗？讲一下连接过程（非对称加密，对称加密）-2" class="headerlink" title="http2.0、https了解吗？讲一下连接过程（非对称加密，对称加密）*2"></a>http2.0、https了解吗？讲一下连接过程（非对称加密，对称加密）*2</h3><p><strong>HTTP/2.0 时代</strong></p>
<p>2015年5月, HTTP/2.0 在万众瞩目下以RFC 7540正式发表。（热烈鼓掌<del>啪啪啪啪</del>)</p>
<p> <strong>二进制分帧</strong></p>
<p>在应用层与传输层之间增加一个二进制分帧层，以此达到“在不改动HTTP的语义，HTTP 方法、状态码、URI及首部字段的情况下，突破HTTP1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。”</p>
<p>在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。</p>
<p> <strong>压缩头部</strong></p>
<p>HTTP/2.0规定了在客户端和服务器端会使用并且维护「首部表」来跟踪和存储之前发送的键值对，对于相同的头部，不必再通过请求发送，只需发送一次</p>
<p>事实上,如果请求中不包含首部（例如对同一资源的轮询请求），那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。</p>
<p>如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP2.0的连接存续期内始终存在,由客户端和服务器共同渐进地更新。</p>
<p><strong>多路复用</strong></p>
<p>HTTP/2.0 时代拥有了「多路复用」功能，意思是: 在一条连接上，我可以同时发起无数个请求，并且响应可以同时返回。（这个难点终于被解决了)</p>
<p>客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。注意，同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送stream，也可以一边接收者服务器的响应，而服务器那端同理。</p>
<p>就是说，HTTP2.0通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。就好比，我请求一个页面<a href="http://www.qq.com%E3%80%82%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%89%80%E6%9C%89%E7%9A%84%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E9%83%BD%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E4%B8%80%E6%9D%A1TCP%E4%B8%8A%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E7%9A%84%EF%BC%81" target="_blank" rel="noopener">http://www.qq.com%E3%80%82%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%89%80%E6%9C%89%E7%9A%84%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E9%83%BD%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E4%B8%80%E6%9D%A1TCP%E4%B8%8A%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E7%9A%84%EF%BC%81</a></p>
<p>注意，对一个域名，只需要开启一条 TCP 连接，请求都在这条 TCP 连接上干活。</p>
<p>因此在 HTTP/2.0 时代，之前的合并 JS、CSS 文件技巧，反而不适用了。</p>
<p><strong>请求优先级</strong></p>
<p>既然所有资源都是并行发送，那么就需要「优先级」的概念了，这样就可以对重要的文件进行先传输，加速页面的渲染。</p>
<p> <strong>服务器推送</strong></p>
<p>在 HTTP2.0中，服务器推送是指在客户端请求之前发送数据的机制。如果一个请求是由你的主页发起的，服务器很可能响应主页内容、logo以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送有一个很大的优势：可以缓存！</p>
<p> <strong>强制 SSL</strong></p>
<p>虽然 HTTP/2.0 协议并没声明一定要用 SSL，但是 Google Chrome 等浏览器强制要求使用 HTTP/2.0 必须要用上 SSL， 也就是说必须要： https://</p>
<p>http:// 将继续使用 http/1.0</p>
<p> <strong>对优化的影响：</strong></p>
<ol>
<li>因为“所有的HTTP2.0的请求都在一个TCP链接上”，“资源合并减少请求”，比如CSS Sprites,多个JS文件、CSS文件合并等手段没有效果，或者说没有必要。</li>
<li>因为“多路复用”，采用“cdn1.cn,cdn2.cn,cdn3.cn，打开多个TCP会话，突破浏览器对同一域名的链接数的限制”的手段是没有必要的。因为资源都是并行交错发送，且没有限制，不需要额外的多域名并行下载。</li>
<li>因为“服务器推送”，内嵌资源的优化手段也变得没有意义了。而且使用服务器推送的资源的方式更加高效，因为客户端还可以缓存起来，甚至可以由不同的页面共享（依旧遵循同源策略）。</li>
</ol>
<p><strong>HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道</strong>，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入==SSL 层==，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面</p>
<h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><p>1.传输信息安全性不同</p>
<p>http协议是超文本传输协议，信息是明文传输的。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息</p>
<p>https协议是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。</p>
<p>2.连接方式不同</p>
<p>http协议：http的连接很简单，是无状态的</p>
<p>https协议：是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议</p>
<p>3.端口不同</p>
<p>http协议使用的端口是80</p>
<p>https协议使用的端口是443</p>
<p>4.证书申请方式不同</p>
<p>http协议免费申请</p>
<p>https协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<h3 id="https加密过程-2"><a href="#https加密过程-2" class="headerlink" title="https加密过程*2"></a>https加密过程*2</h3><p>HTTPS 在内容传输的加密上使用的是==对称加密==，==非对称加密==只作用在证书验证阶段。</p>
<p><strong>证书验证阶段</strong></p>
<p>1.浏览器发起https请求</p>
<p>2.服务端返回https证书（包含了公钥）</p>
<p>3.客户端验证证书是否合法，如果不合法则提示警告</p>
<p><strong>数据传输阶段</strong></p>
<p>1.验证证书合法性（这一部分由SSL/TLS完成）。当证书验证合法后，在本地生成随机数</p>
<p>2.通过公钥加密随机数，并把加密后的随机数传输到服务端</p>
<p>3.服务端通过私钥对随机数进行解密</p>
<p>4.服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</p>
<p>5.客户端根据本地存储的随机数进行解密</p>
<h3 id="TLS-SSL的过程"><a href="#TLS-SSL的过程" class="headerlink" title="TLS/SSL的过程"></a>TLS/SSL的过程</h3><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p>
<p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</p>
<img src=".\图片\10.png" style="zoom:50%;" />

<h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><p>握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 <strong>Random1</strong>、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。</p>
<h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><p>第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <strong>Random2</strong>。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。</p>
<h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><p>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a>Server Key Exchange</h4><p>如果是DH算法，这里发送服务器使用的DH参数。RSA算法不需要这一步</p>
<h4 id="Certificate-Request"><a href="#Certificate-Request" class="headerlink" title="Certificate Request"></a>Certificate Request</h4><p>Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。</p>
<h4 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h4><p>Server Hello Done 通知客户端 Server Hello 过程结束</p>
<h4 id="Certificate-Verify"><a href="#Certificate-Verify" class="headerlink" title="Certificate Verify"></a>Certificate Verify</h4><p>客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 <strong>Random3</strong>，再用服务端公钥非对称加密 <strong>Random3</strong> 生成 <strong>PreMaster Key</strong>。</p>
<h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><p>上面客户端根据服务器传来的公钥生成了 <strong>PreMaster Key</strong>，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 <strong>PreMaster Key</strong> 得到客户端生成的 <strong>Random3</strong>。至此，客户端和服务端都拥有 <strong>Random1</strong> + <strong>Random2</strong> + <strong>Random3</strong>，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。</p>
<h4 id="Change-Cipher-Spec-Client"><a href="#Change-Cipher-Spec-Client" class="headerlink" title="Change Cipher Spec(Client)"></a>Change Cipher Spec(Client)</h4><p>这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。</p>
<h4 id="Encrypted-Handshake-Message-Client"><a href="#Encrypted-Handshake-Message-Client" class="headerlink" title="Encrypted Handshake Message(Client)"></a>Encrypted Handshake Message(Client)</h4><p>这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。</p>
<h4 id="Change-Cipher-Spec-Server"><a href="#Change-Cipher-Spec-Server" class="headerlink" title="Change Cipher Spec(Server)"></a>Change Cipher Spec(Server)</h4><p>这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</p>
<h4 id="Encrypted-Handshake-Message-Server"><a href="#Encrypted-Handshake-Message-Server" class="headerlink" title="Encrypted Handshake Message(Server)"></a>Encrypted Handshake Message(Server)</h4><p>这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p>
<h4 id="Application-Data"><a href="#Application-Data" class="headerlink" title="Application Data"></a>Application Data</h4><p>到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输</p>
<p><a href="https://www.jianshu.com/p/7158568e4867" target="_blank" rel="noopener">https://www.jianshu.com/p/7158568e4867</a></p>
<p><a href="https://www.cnblogs.com/barrywxx/p/8570715.html" target="_blank" rel="noopener">https://www.cnblogs.com/barrywxx/p/8570715.html</a></p>
<h3 id="浏览器输入URL到页面展示经历的过程"><a href="#浏览器输入URL到页面展示经历的过程" class="headerlink" title="浏览器输入URL到页面展示经历的过程"></a>浏览器输入URL到页面展示经历的过程</h3><h3 id="电子邮件系统中，用户代理把邮件发往发送发邮件服务器、发送方邮件服务器把邮件发往接收方邮件服务器以及用户使用用户代理从接收方邮件服务器上读取邮件时，使用的协议"><a href="#电子邮件系统中，用户代理把邮件发往发送发邮件服务器、发送方邮件服务器把邮件发往接收方邮件服务器以及用户使用用户代理从接收方邮件服务器上读取邮件时，使用的协议" class="headerlink" title="电子邮件系统中，用户代理把邮件发往发送发邮件服务器、发送方邮件服务器把邮件发往接收方邮件服务器以及用户使用用户代理从接收方邮件服务器上读取邮件时，使用的协议"></a>电子邮件系统中，用户代理把邮件发往发送发邮件服务器、发送方邮件服务器把邮件发往接收方邮件服务器以及用户使用用户代理从接收方邮件服务器上读取邮件时，使用的协议</h3><h3 id="HTTPS的实现"><a href="#HTTPS的实现" class="headerlink" title="HTTPS的实现"></a>HTTPS的实现</h3><h3 id="Http中GET与POST的区别"><a href="#Http中GET与POST的区别" class="headerlink" title="Http中GET与POST的区别"></a>Http中GET与POST的区别</h3><p>一般情况写GET是用来获取资源的，POST是用来修改资源的<br>GET因为是获取资源，所以是幂等的，POST因为时修改资源，所以是非幂等的<br>GET的请求信息是放在请求头中的，POST的请求信息是放在请求体中的<br>GET因为将信息放在请求头中，所以是不安全的，POST放在请求体中，是安全的。</p>
<h3 id="浏览器图片怎么加载的？"><a href="#浏览器图片怎么加载的？" class="headerlink" title="浏览器图片怎么加载的？"></a>浏览器图片怎么加载的？</h3><h3 id="DNS详细说下？为啥要这么设计？为什么域名服务器要分级设计？"><a href="#DNS详细说下？为啥要这么设计？为什么域名服务器要分级设计？" class="headerlink" title="DNS详细说下？为啥要这么设计？为什么域名服务器要分级设计？"></a>DNS详细说下？为啥要这么设计？为什么域名服务器要分级设计？</h3><p><strong>DNS（Domain Name System）是域名系统</strong>，是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。用户与因特网上某个主机通信时，必须要知道对方的IP地址。然而用户很难记住长达32位二进制主机地址。即使是点分十进制IP地址也并不太容易记忆。但在应用层为了便于用户记忆各种网络应用，更多的是使用主机名字。</p>
<p>DNS采用层次树状结构的命名方法，并使用分布式的域名系统DNS，采用客户-服务器方式。DNS使得大多数名字都在本地进行解析，仅少量解析需要在因特网上通信，因此DNS系统的效率很高。由于DNS是分布式系统，即使单个计算机出了故障，也不会妨碍整个DNS系统的正常运行。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C58.png" alt=""></p>
<p><strong>使用层次树状结构的命名方法</strong>，因为因特网上的用户数急剧增加，非等级的名字空间来管理一个很大的而且是经常变化的名字集合是非常困难的。</p>
<p><strong>与DNS有关的域名服务器</strong><br>根域名服务器<br>顶级域名服务器<br>权限域名服务器<br>本地域名服务器</p>
<p><strong>域名解析过程</strong><br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C59.png" alt=""></p>
<h3 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><p>FTP提供交互式的访问，允许客户指明文件的类型与格式，并文件具有存取权限。FTP屏蔽了各计算机系统的细节，因而适用于在异构网络中任意计算机之间传送文件。不论是基于TCP的FTP还是基于UDP的简单文件传送协议TFTP，它们都是文件共享协议中的一大类，<strong>即复制整个文件，其特点是</strong>若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后将修改后的文件副本传回到原节点。</p>
<p><strong>FTP的基本工作原理</strong><br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C60.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C61.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C62.png" alt=""></p>
<p><strong>简单文件传输协议</strong></p>
<h3 id="Cookie存放在http协议中的哪个位置"><a href="#Cookie存放在http协议中的哪个位置" class="headerlink" title="Cookie存放在http协议中的哪个位置"></a>Cookie存放在http协议中的哪个位置</h3><h3 id="Cookie和Session是什么以及区别"><a href="#Cookie和Session是什么以及区别" class="headerlink" title="Cookie和Session是什么以及区别"></a>Cookie和Session是什么以及区别</h3><p>Cookie和Seesion是什么<br><a href="https://zhuanlan.zhihu.com/p/27669892" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27669892</a><br><a href="https://blog.csdn.net/yanghaitao_1990/article/details/51723066" target="_blank" rel="noopener">https://blog.csdn.net/yanghaitao_1990/article/details/51723066</a></p>
<p>区别<br>1、数据存放bai位置不同：<br>cookie数据存放在客户的浏du览zhi器上，session数据放在服务器上。</p>
<p>2、安全程度不同：<br>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。</p>
<p>3、性能使用程度不同：<br>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</p>
<p>4、数据存储大小不同：<br>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。</p>
<h3 id="发送邮件需要用到的协议"><a href="#发送邮件需要用到的协议" class="headerlink" title="发送邮件需要用到的协议"></a>发送邮件需要用到的协议</h3><p><strong>一个电子邮件系统应具有三个主要组成构件：用户代理、邮件服务器以及邮件发送协议和邮件读取协议。</strong></p>
<p><strong>用户代理</strong><br>是用户与电子邮件系统的接口，在大多数情况下它就是运行在用户PC中的一个程序。因此用户代理又称为电子邮件客户端软件。用户代理至少应当具有以下四个功能：<br>撰写、显示、处理、通信<br><strong>邮件服务器</strong>的功能是发送和接收邮件，同时还要向发件人报告邮件传送的结果（已交付、被拒绝、丢失等）。邮件服务器按照客户服务器方式工作。邮件服务器需要两种不同的协议，一种协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如SMTP协议；而另一种协议用于用户代理从邮件服务器读取邮件，如邮局协议POP3。邮件服务器必须能够同时充当客户和服务器。</p>
<p><strong>SMTP协议</strong></p>
<p>SMTP的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循SMTP协议的发送邮件服务器。SMTP认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。</p>
<p>SMTP不使用中间的邮件服务器。不管发送方和接收方的邮件服务器相隔有多远，不管在邮件的传送过程中要经过多少个路由器，TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立。当接收方邮件服务器出故障而不能工作时，发送方邮件服务器只能等待一段时间后再尝试和该邮件服务器建立TCP连接，而不能先找一个中间的邮件服务器建立TCP连接。</p>
<p>SMTP已是事实上的E-Mail传输的标准。</p>
<p><strong>POP协议</strong></p>
<p>POP邮局协议负责从邮件服务器中检索电子邮件，使用客户-服务器的工作方式。它要求邮件服务器完成下面几种任务之一：从邮件服务器中检索读取了邮件就要从服务器中删除这个邮件；从邮件服务器中检索邮件但不删除它；不检索邮件，只是询问是否有新邮件到达。POP协议支持多用户互联网邮件扩展，后者允许用户在电子邮件上附带二进制文件，如文字处理文件和电子表格文件等，实际上这样就可以传输任何格式的文件了，包括图片和声音文件等。在用户阅读邮件时，POP命令所有的邮件信息立即下载到用户的计算机上，不在服务器上保留。</p>
<p>POP3(Post Office Protocol 3)即邮局协议的第3个版本,是因特网电子邮件的第一个离线协议标准。</p>
<p><strong>IMAP协议</strong></p>
<p>互联网信息访问协议（IMAP）是一种优于POP的新协议。和POP一样，IMAP也能下载邮件、从服务器中删除邮件或询问是否有新邮件，但IMAP克服了POP的一些缺点。例如，它可以决定客户机请求邮件服务器提交所收到邮件的方式，请求邮件服务器只下载所选中的邮件而不是全部邮件。客户机可先阅读邮件信息的标题和发送者的名字再决定是否下载这个邮件。通过用户的客户机电子邮件程序，IMAP可让用户在服务器上创建并管理邮件文件夹或邮箱、删除邮件、查询某封信的一部分或全部内容，完成所有这些工作时都不需要把邮件从服务器下载到用户的个人计算机上。缺点是如果用户没有将邮件复制到自己的PC上，则邮件一直是存放在IMAP服务器上，因此用户需要经常与IMAP服务器建立连接。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>两个机器进行通信，由于一方机器无法识别对方机器上的进程（因为每种操作系统的进程标识符不同，所以无法使用该方法），所以需要使用端口。所以虽然通信的终点是应用进程，但只要把传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由TCP来完成。</p>
<h3 id="TCP、UDP区别-2"><a href="#TCP、UDP区别-2" class="headerlink" title="TCP、UDP区别*2"></a>TCP、UDP区别*2</h3><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>3、TCP面向字节流，流指的是流入到进程或从进程流出的字节序列，实际上是TCP把数据看成一连串无结构的字节流;TCP不保证接收方应用程序所收到的数据块和发送方所发出的数据块具有对象大小的关系，但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。<br>UDP是面向报文的；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p>
<p>4、每一条TCP连接只能是点到点的，不支持广播或多播服务;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</p>
<p>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
<h3 id="TCP可靠连接用什么保证-2"><a href="#TCP可靠连接用什么保证-2" class="headerlink" title="TCP可靠连接用什么保证*2"></a>TCP可靠连接用什么保证*2</h3><p>1） 应用数据被分割成 TCP 认为最适合发送的数据块。</p>
<p>2） 确认机制，发送报文后，等待确认。</p>
<p>3） 重发机制，没有收到确认，将重发数据段。</p>
<p>4） 保持它首部和数据的校验和。确认数据的准确性。</p>
<p>5） 排序，丢弃重复的，流量控制。</p>
<p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157" target="_blank" rel="noopener">https://blog.csdn.net/liuchenxia8/article/details/80428157</a></p>
<h3 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h3><p><a href="https://www.jianshu.com/p/6c73a4585eba" target="_blank" rel="noopener">https://www.jianshu.com/p/6c73a4585eba</a></p>
<p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，通常应用在音频，视频和普通数据传送。<br>传输层无法保证数据的可靠传输，只能通过其上层来实现，如应用层。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。<br>最简单的方式是在应用层模仿传输层TCP可靠性传输。下面不考虑拥塞处理，可靠udp的简单设计<br>1.添加seq/ack机制，确保数据发送到对端<br>2.添加发送和接收缓冲区，主要是用户超时重传<br>3.添加超时重传机制<br>详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为<em>RUDP、RTP、UDT</em>。</p>
<h3 id="最大tcp连接数跟什么有关"><a href="#最大tcp连接数跟什么有关" class="headerlink" title="最大tcp连接数跟什么有关"></a>最大tcp连接数跟什么有关</h3><p><a href="https://www.cnblogs.com/duanxz/p/4464178.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz/p/4464178.html</a></p>
<p><strong>客户端</strong><br>对于客户端，通过一个四元组来标识一个tcp连接，即{local ip，local port，remote ip， remote port}<br>客户端每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本都端口，该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535，这些连接可以连到不同的server ip。</p>
<p><strong>服务端</strong><br>server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。<br>实际的tcp连接数<br>上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。在默认2.6内核配置下，经过试验，每个socket占用内存在15~20k之间。</p>
<h3 id="TCP中的MSS和MTU"><a href="#TCP中的MSS和MTU" class="headerlink" title="TCP中的MSS和MTU"></a>TCP中的MSS和MTU</h3><p>MTU(Maximum Transmission Unit)，最大传输单元，以太网的MTU为1500字节<br>MSS(Maximum Segment Size)，最大分段长度，为TCP数据包每次的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header(20 Byte)和TCP header(20 Byte)得到。</p>
<h3 id="三次握手、四次挥手各个状态名称-2"><a href="#三次握手、四次挥手各个状态名称-2" class="headerlink" title="三次握手、四次挥手各个状态名称*2"></a>三次握手、四次挥手各个状态名称*2</h3><p>三次握手</p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C1.png" alt=""></p>
<p>最初两端的TCP进程都处于<strong>CLOSED（关闭）</strong>状态。</p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C2.png" alt=""></p>
<p>四次挥手</p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C3.png" alt=""></p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C4.png" alt=""></p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C5.png" alt=""></p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C6.png" alt=""></p>
<p>由上述可知，B先于A到达CLOSED状态。</p>
<h3 id="服务器端大量出现close-wait是什么原因？"><a href="#服务器端大量出现close-wait是什么原因？" class="headerlink" title="服务器端大量出现close_wait是什么原因？"></a>服务器端大量出现close_wait是什么原因？</h3><h3 id="TCP三次握手，为什么是3次，不是2次，挥手为什么4次-2"><a href="#TCP三次握手，为什么是3次，不是2次，挥手为什么4次-2" class="headerlink" title="TCP三次握手，为什么是3次，不是2次，挥手为什么4次*2"></a>TCP三次握手，为什么是3次，不是2次，挥手为什么4次*2</h3><p><strong>3 次握手</strong>：防止已过期的连接请求报文突然又传送到服务器，因而产生错误。假设一种异常情况，即A发出的第一个连接请求报文段并未有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放后以后的某个时间才到达B。本来这是一个早已失效的连接，但是B收到此失效连接请求报文后段后，就误以为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。但由于A并没有发出建立连接的请求，因为不会理睬B的确认，也不会向B发送数据。而B却以为新的连接已经建立，就一直等待A发送数据。B的许多资源就这样浪费。</p>
<p><strong>4 次挥手</strong>：确保数据能够完成传输，但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的</p>
<h3 id="TCP三次握手发了什么？syn的全名"><a href="#TCP三次握手发了什么？syn的全名" class="headerlink" title="TCP三次握手发了什么？syn的全名"></a>TCP三次握手发了什么？syn的全名</h3><p>发了什么见上面各个状态名称</p>
<p>SYN全名是Synchronize Sequence Numbers 同步序列编号</p>
<p>ACK全名是Acknowledge character 确认字符</p>
<h3 id="TCP三次握手对应哪些系统调用"><a href="#TCP三次握手对应哪些系统调用" class="headerlink" title="TCP三次握手对应哪些系统调用"></a>TCP三次握手对应哪些系统调用</h3><h3 id="有个半连接、全连接状态，对应到具体哪步状态"><a href="#有个半连接、全连接状态，对应到具体哪步状态" class="headerlink" title="有个半连接、全连接状态，对应到具体哪步状态"></a>有个半连接、全连接状态，对应到具体哪步状态</h3><p>半连接状态：TCP三次握手中处于SYN-RCVD的状态，这里有个半连接队列，存储处于SYN-RCVD状态的连接（比如套接字存在里面）<br>半连接队列的大小取决于：max(64, tcp_max_syn_backlog)</p>
<p>全连接状态：TCP三次握手中处于ESTABLISHED的状态，这里有个全连接队列（accept队列），存储处于ESTABLISHED状态的连接（比如这时候套接字就从半连接队列来到了全连接队列）<br>全连接队列的大小取决于：min(tcp_max_syn_backlog, net.core.somaxconn)</p>
<p> <strong>队列与三次握手关系</strong></p>
<p>  当连接状态变为SYN_RCVD时，连接信息存储到syns queue；当连接状态变为ESTABLISHED时，连接信息从syns queue移动到accept queue；当accept()函数从accept queue获取连接后，连接信息从队列中移除，具体过程如下：</p>
<ul>
<li><p>客户端发送SYN请求，请求建立连接，客户端连接状态变为SYN_SENT；</p>
</li>
<li><p>服务端接受到SYN请求，连接状态变为SYN_RCVD，同时将连接信息存放到syns队列中，如果存放成功，则回复SYN+ACK给客户端；</p>
</li>
<li><p>当客户端接收到SYN+ACK后，连接状态变为ESTABLISHED，发送ACK到服务端，此时客户端可以发送数据；</p>
</li>
<li><p>服务端接收到ACK后，连接的状态变为ESTABLISHED，内核将连接信息从syns队列移动到accept队列；</p>
</li>
<li><p>服务端应用进程通过accept()函数从accept队列中获取已建立好的连接进行读写，此时连接被移除accept队列；</p>
<p><strong>队列溢出处理策略</strong></p>
<p><strong>半连接队列溢出处理策略</strong></p>
</li>
<li><p>若设置 net.ipv4.tcp_syncookies = 0 ，服务端会直接丢弃当前 SYN 包（<strong>Client端由于多次重发SYN包得不到响应而抛出connection time out错误</strong>）；</p>
</li>
<li><p>若设置 net.ipv4.tcp_syncookies = 1 ，那么SYN半连接队列就没有逻辑上的最大值了，/proc/sys/net/ipv4/tcp_max_syn_backlog设置的值会被忽略；</p>
<p><strong>全连接队列溢出处理策略</strong></p>
</li>
</ul>
<p>  如果全连接队列满了，在收到三次握手最后的 ACK 时服务端会按照网络参数net.ipv4.tcp_abort_on_overflow的值进行处理：</p>
<ul>
<li>如果tcp_abort_on_overflow=1，服务端会直接发送RST包，连接被终止并从 syn queue中删除（<strong>Client端由于多次重发SYN包得不到响应而抛出connection reset by peer错误</strong>）；</li>
<li>如果tcp_abort_on_overflow=0，服务端会丢弃掉Client的ACK包，连接信息仍保留在 SYN queue 中，同时启动定时器按照重传机制重新发送SYN + ACK包到Client（执行net.ipv4.tcp_synack_retries次重传，每次重传间隔时间double），当重传次数超过设定值时，服务端发送RST包，直接终端连接，并从 syn queue 中删除该连接信息；（<strong>在重试次数未达到上限前，重试成功客户端RT变高，Client超时则抛出read timeout异常；达到重试上限，则Client抛出connection reset by peer异常</strong>）</li>
</ul>
<p><a href="https://blog.csdn.net/yangguosb/article/details/90644683" target="_blank" rel="noopener">https://blog.csdn.net/yangguosb/article/details/90644683</a></p>
<h3 id="TCP拥塞控制和流量控制-3"><a href="#TCP拥塞控制和流量控制-3" class="headerlink" title="TCP拥塞控制和流量控制*3"></a>TCP拥塞控制和流量控制*3</h3><p><strong>拥塞控制和流量控制的区别：</strong><br><strong>拥塞控制</strong>就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷，拥塞控制是一个全局的过程涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。<br><strong>流量控制</strong>往往指点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便接收端来得及接收。</p>
<p><strong>拥塞控制</strong></p>
<p><strong>慢启动</strong></p>
<p>原理</p>
<p>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。</p>
<p>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。<strong>相当于每轮接收完毕拥塞窗口大小翻倍</strong></p>
<p>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 </p>
<p>（1）慢开始不是指 cwnd 的增长速度慢（指数增长），而是指 TCP 开始发送设置 cwnd=1。</p>
<p>（2）思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。</p>
<p>（3）为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ssthresh 状态变量）</p>
<p>当 cnwd＜ssthresh，使用慢开始算法</p>
<p>当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</p>
<p>当 cnwd＞ssthresh，使用拥塞避免算法</p>
<p><strong>拥塞避免</strong> </p>
<p>（1）拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律长，使网络比较不容易出现拥塞。</p>
<p>（2）思路：让拥塞窗口 cwnd 缓慢地增大，即<strong>每经过一个往返时间 RTT</strong> 就把发送方的拥塞控制窗口<strong>加一</strong>。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始算法。</p>
<p><strong>快速重传</strong></p>
<p>快重传算法首先要求接收方每收到一个<strong>失序</strong>的报文段后就<strong>立即发出重复确认</strong>。这样做可以让发送方及早知道有报文段没有到达接收方。</p>
<p>发送方只要<strong>一连收到三个重复确认就应当立即重传对方尚未收到的报文段</strong>。</p>
<p>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。</p>
<p><strong>快速恢复</strong></p>
<p>(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。</p>
<p>(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 <strong>ssthresh 减半后的数值，然后开始执行拥塞避免算法</strong>（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p><strong>流量控制</strong></p>
<p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收，可以利用滑动窗口进行流量控制</p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C8.png" alt=""></p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C7.png" alt=""></p>
<p><img src=".%5C%E5%9B%BE%E7%89%87%5C9.png" alt=""></p>
<h3 id="拥塞如何解决？"><a href="#拥塞如何解决？" class="headerlink" title="拥塞如何解决？"></a>拥塞如何解决？</h3><p>见拥塞控制</p>
<h3 id="TIME-WAIT的作用-2"><a href="#TIME-WAIT的作用-2" class="headerlink" title="TIME_WAIT的作用*2"></a>TIME_WAIT的作用*2</h3><p>两个原因</p>
<p>1.保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST_ACK的状态的B收不到对已发送的FIN+ACK报文段确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器。最后A和B都能正常的进入到CLOSED状态。如果A在TIME_WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样B就无法按照正常步骤进入CLOSED状态。</p>
<p>2.A在发送完最后一个ACK报文段之后，再经过2MSL就可以使本连接持续时间内所产生的所有报文段都从网络消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<h3 id="TIME-WAIT为什么是2MSL，如何解决TIME-WAIT状态过多"><a href="#TIME-WAIT为什么是2MSL，如何解决TIME-WAIT状态过多" class="headerlink" title="TIME_WAIT为什么是2MSL，如何解决TIME_WAIT状态过多"></a>TIME_WAIT为什么是2MSL，如何解决TIME_WAIT状态过多</h3><p>MSL是报文最大生存时间。</p>
<p>在最后的A发送给B确认报文阶段，假如A返回给B的时候，1MSL过去了，报文过期了；B没有收到，再发一遍，如果设置 <code>time_wait 状态</code> 是 <code>1msl</code>，那么 A处于<code>closed</code>状态，拒收B的<code>FIN 包</code>，B 无法关闭。</p>
<p>所以要设置大于 1MSL。</p>
<p>而 TCP B 重传过来的包，你也要假设他可能需要<code>1 msl</code>吧，那么 time_wait 就要<code>2 msl</code>的时间来保证此极端情况下，B 能重传成功。</p>
<p>相当于一来一回，两个2msl。</p>
<p>在高并发短时间连接时会造成TIME_WAIT状态过多</p>
<p>TIME_WAIT状态过多危害</p>
<p>网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；<br>同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。<br>过多的话会占用内存，一个TIME_WAIT占用4k大小</p>
<p><strong>如何尽量处理TIMEWAIT过多?</strong></p>
<p>编辑内核文件/etc/sysctl.conf，加入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line">net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</span><br><span class="line">这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。</span><br></pre></td></tr></table></figure>

<p>然后执行 /sbin/sysctl -p 让参数生效.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP&#x2F;IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。</span><br></pre></td></tr></table></figure>

<p>简单来说，就是打开系统的TIMEWAIT重用和快速回收。</p>
<p>如果以上配置调优后性能还不理想，可继续修改一下配置：</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">net.ipv4.tcp_keepalive_time &#x3D; 1200 </span><br><span class="line">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span><br><span class="line">net.ipv4.ip_local_port_range &#x3D; 1024 65000 </span><br><span class="line">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 8192 </span><br><span class="line">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span><br><span class="line">net.ipv4.tcp_max_tw_buckets &#x3D; 5000 </span><br><span class="line">#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。</span><br><span class="line">默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h3 id="写过socket编程吗？"><a href="#写过socket编程吗？" class="headerlink" title="写过socket编程吗？"></a>写过socket编程吗？</h3><h3 id="校园网都是局域网，怎么访问外网？NAT。-它又问NAT具体是怎么回事。"><a href="#校园网都是局域网，怎么访问外网？NAT。-它又问NAT具体是怎么回事。" class="headerlink" title="校园网都是局域网，怎么访问外网？NAT。 它又问NAT具体是怎么回事。"></a>校园网都是局域网，怎么访问外网？NAT。 它又问NAT具体是怎么回事。</h3><p>通过NAT。</p>
<p>NAT是网络地址转换（Network Address Translation），替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。我们一般使用私网ip作为局域网内部的主机标识，使用公网ip作为互联网上通信的标识</p>
<p>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。</p>
<p>在整个NAT的转换中，最关键的流程有以下几点</p>
<p>网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关<br>网络访问只能先由私网侧发起，公网无法主动访问私网主机；<br>NAT网关在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换；<br>NAT网关的存在对通信双方是保持透明的；<br>NAT网关为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。<br><a href="https://blog.csdn.net/gui951753/java/article/details/79593307" target="_blank" rel="noopener">https://blog.csdn.net/gui951753/java/article/details/79593307</a></p>
<p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。</p>
<p><strong>静态转换</strong>是指将内部网络的私有IP地址转换为公有IP地址，IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。借助于静态转换，可以实现外部网络对内部网络中某些特定设备（如服务器）的访问。</p>
<p><strong>动态转换</strong>是指将内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</p>
<p><strong>端口多路复用（Port address Translation,PAT)</strong>是指改变外出数据包的源端口并进行端口转换，即端口地址转换（PAT，Port Address Translation).采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p>
<p><strong>ALG（Application Level Gateway）</strong>，即应用程序级网关技术：传统的NAT技术只对IP层和传输层头部进行转换处理，但是一些应用层协议，在协议数据报文中包含了地址信息。为了使得这些应用也能透明地完成NAT转换，NAT使用一种称作ALG的技术，它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换。例如：对于FTP协议的PORT/PASV命令、DNS协议的 “A” 和 “PTR” queries命令和部分ICMP消息类型等都需要相应的ALG来支持。</p>
<p>如果协议数据报文中不包含地址信息，则很容易利用传统的NAT技术来完成透明的地址转换功能，通常我们使用的如下应用就可以直接利用传统的NAT技术：HTTP、TELNET、FINGER、NTP、NFS、ARCHIE、RLOGIN、RSH、RCP等。</p>
<h3 id="用UDP传数据一次传4k好还是4次传1k好"><a href="#用UDP传数据一次传4k好还是4次传1k好" class="headerlink" title="用UDP传数据一次传4k好还是4次传1k好"></a>用UDP传数据一次传4k好还是4次传1k好</h3><p>一次传4k，因为MTU是1500字节，因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节。如果一次传递的话会分成4K的大小会分成3个包，比4次传1K少一次，所以更好。<br><a href="https://blog.csdn.net/meidiya123/article/details/78262729" target="_blank" rel="noopener">https://blog.csdn.net/meidiya123/article/details/78262729</a></p>
<h3 id="如何判断数据发送完了？"><a href="#如何判断数据发送完了？" class="headerlink" title="如何判断数据发送完了？"></a>如何判断数据发送完了？</h3><h3 id="设计一种方法解决粘包问题"><a href="#设计一种方法解决粘包问题" class="headerlink" title="设计一种方法解决粘包问题?"></a>设计一种方法解决粘包问题?</h3><p><a href="https://www.cnblogs.com/kex1n/p/6502002.html" target="_blank" rel="noopener">https://www.cnblogs.com/kex1n/p/6502002.html</a></p>
<h3 id="如果客户端突然出现故障，tcp连接会怎么样"><a href="#如果客户端突然出现故障，tcp连接会怎么样" class="headerlink" title="如果客户端突然出现故障，tcp连接会怎么样"></a>如果客户端突然出现故障，tcp连接会怎么样</h3><p>如果设置了keepalive机制，则打开后会定时向连接对方发送ACK包(linux下默认是7200s 即2小时发生一次发送一次握手信息)，如果在发送ACK包后对方不回应才能检测道对方的断开信息，所以B错误; </p>
<p>使用心跳机制，Heartbeat机制是客户端每个一段时间向服务器发送数据包，来通知服务端该客户端保持连接</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ip数据报"><a href="#ip数据报" class="headerlink" title="ip数据报"></a>ip数据报</h3><p>由首部和数据两部分组成<br>首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的，固定部分的后面是一些可选字段，长度可变<br>(1) <strong>版本</strong> 占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 (即 IPv4)</p>
<p>(2) <strong>首部长度</strong> 占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)因此 IP 的首部长度的最大值是 60 字节。</p>
<p>(3) <strong>区分服务</strong> 占 8 位，用来获得更好的服务。在旧标准中叫做<strong>服务类型</strong>，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。<strong>在一般的情况下都不使用这个字段</strong>。</p>
<p>(4) <strong>总长度</strong> 占 16 位，指首部和数据之和的长度，<strong>单位为字节</strong>，因此数据报的最大长度为 65535 字节。总长度必须不超过<strong>最大传送单元 MTU(Maximum Transfer Unit)</strong>。IP协议规定，在因特网中所有的主机和路由器，必须能够接受长度不超过576字节的数据报。当主机需要发送长度超过576字节的数据报时，应当先了解一下，目的主机是否能够接受。否则就要进行分片。</p>
<p>(5) <strong>标识(identification)</strong>  占 16 位，它是一个计数器，用来产生数据报的标识</p>
<p>(6) <strong>标志(flag)</strong> 占 3 位，目前只有前两位有意义。</p>
<p>标志字段的最低位是 MF (More Fragment)。MF =1 表示后面“还有分片”。MF =0 表示最后一个分片。</p>
<p>标志字段中间的一位是 DF (Don’t Fragment)。只有当 DF =0 时才允许分片。</p>
<p>(7) <strong>片偏移</strong> 占13 位，指出：较长的分组在分片后，某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。具体例子见书P142</p>
<p>(8) <strong>生存时间</strong> 占8位，记为 TTL (Time To Live)，数据报在网络中可通过的路由器数的最大值。</p>
<p>(9) <strong>协议</strong> 占8位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给哪个处理过程</p>
<p>(10) <strong>首部检验和</strong> 占16位，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法</p>
<p>(11) <strong>源地址</strong> 占32位</p>
<p>(12) <strong>目的地址</strong> 占32位</p>
<p><strong>IP</strong> <strong>数据报首部的可变部分</strong><br>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。<br>选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。<br>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。<br>实际上这些选项很少被使用。</p>
<h3 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h3><p>当发送的IP数据包的大小超过了MTU时，IP就需要对数据进行分片，否则数据将无法发送成功。<br>IP分片发生在IP层，不仅源端主机会进行分片，中间的路由器也有可能分片，因为不同的网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU要小，路由器就可能对IP数据报再次进行分片。分片数据的重组只会发生在目的端的IP层。</p>
<p>在IP首部有4个字节是用于分片的。前16位是IP数据报的标识，同一个数据报的各个分片的标识是一样的，目的端会根据这个标识来判断IP分片是否属于同一个IP数据报。中间3位是标志位，其中有1位用来表示是否有更多的分片，如果是最后一个分片，该标志位为0，否则为1。后面13位表示分片在原始数据的偏移，这里的原始数据是IP层收到的传输的TCP或UDP数据，不包含IP首部。</p>
<p>需要注意的，在分片的数据中，传输层的首部只会出现在第一个分片中。因为传输层的数据格式对IP层是透明的，传输层的首部只有在传输层才会有它的作用，IP层不知道也不需要保证在每个分片中都有传输层首部。所以，在网络上传输的数据包是有可能没有传输层首部的。</p>
<p><strong>避免ip分片</strong></p>
<p>在网络编程中，我们要避免出现IP分片，那么为什么要避免呢？==原因是IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍==，这个代价有点大。由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。</p>
<p><strong>如何避免</strong></p>
<p>对于UDP包，我们需要在应用层去限制每个包的大小，一般不要超过1472字节，即以太网MTU（1500）—UDP首部（8）—IP首部（20）。</p>
<p>对于TCP数据，应用层就不需要考虑这个问题了，因为传输层已经帮我们做了。在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment Size，最大报文段长度），MSS一般是MTU—IP首部（20）—TCP首部（20），每次发送的TCP数据都不会超过双方MSS的最小值，所以就保证了IP数据报不会超过MTU，避免了IP分片。</p>
<p><strong>分片顺序</strong></p>
<p>有标识字段可以确定分片属于哪一个报文，13位的片偏移可以确定分片的顺序。</p>
<p><strong>接收端如何确定分片均到达</strong></p>
<p>1）如果收到的包IP头中Fragmentation Flags为0且有UDP字段，则未分片<br>2）如果收到的包IP头中Fragmentation Flags为1且有UDP字段，则为第一片<br>3）如果收到的包IP头中Fragmentation Flags为1且无UDP字段，则为中间片<br>4）如果收到的包IP头中Fragmentation Flags为0且无UDP字段，则为最后一片</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址的表示方法：IP地址 ::={&lt;网络号&gt;, &lt;主机号&gt;}, ::=表示定义为。<br><strong>IP地址分类</strong><br> <img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C32.png" alt=""></p>
<p>A、B、C类地址的网络段字号分别为1,2和3字节长，而在网络号字段的最前面有1~3位的类别位，其数值分别规定为0,10,110。<br>A、B、C类地址的主机号字段分别为3个、2个和1个字节长。<br>D类地址（前4位为1110）为多播（一对多通信）<br>E类地址（前4位是1111）保留为以后使用</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C33.png" alt=""><br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C34.png" alt=""></p>
<h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p><strong>划分子网的基本思路：</strong><br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C35.png" alt=""></p>
<p>总之，当没有划分子网时，IP地址是两级结构。划分子网后IP地址变成了三级结构。划分子网只是把IP地址的主机号这部分进行再划分，而不改变IP地址原来的网络号</p>
<p><strong>子网掩码</strong><br>使用子网掩码可以将一个数据报到达该网络号所在网络后具体发送给哪个子网。<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C36.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C37.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C38.png" alt=""></p>
<h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p>为了提高IP数据报交付成功的机会，在网际层使用了网际控制报文协议<br>ICMP是为了解决两大问题：<br>1.反馈分组传送和到达中出现的各种错误<br>2.查询主机或路由器信息<br>ICMP 报文不直接传递给下层（数据链路层）而是作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。  </p>
<p><strong>ICMP协议报文格式</strong><br>类型                    代码                    检验和<br>（这四个字节取决于ICMP报文的类型）<br>ICMP的数据部分（长度取决于类型）<br>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。<br><strong>ICMP报文的种类</strong><br>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文和 ICMP 询问报文</strong>。</p>
<p><strong>ICMP差错报文共有5种</strong><br><strong>终点不可达</strong>：当路由器或主机不能交付数据报时就向源点发送终点不可达报文<br><strong>源点抑制</strong>：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢<br><strong>时间超过</strong>：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文<br><strong>参数问题</strong>：当路由器或目的主机收到数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文<br><strong>改变路由（重定向）</strong>：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）</p>
<p><strong>ICMP</strong> <strong>差错报告报文的数据字段的内容</strong><br>把收到的需要进行差错报告的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文数据字段。再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。</p>
<p><strong>不应发送 ICMP 差错报告报文的几种情况</strong><br>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。<br>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。<br>对具有多播地址的数据报都不发送 ICMP 差错报告报文。<br>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</p>
<p><strong>ICMP</strong> <strong>询问报文有两种</strong><br><strong>回送请求和回答报文</strong> ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。<br><strong>时间戳请求和回答报文</strong> ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用来进行时钟同步和测量时间。</p>
<p><strong>下面的几种 ICMP 报文不再使用</strong></p>
<p>信息请求与回答报文、掩码地址请求和回答报文、路由器询问和通告报文</p>
<h3 id="ICMP的应用举例"><a href="#ICMP的应用举例" class="headerlink" title="ICMP的应用举例"></a>ICMP的应用举例</h3><p>ICMP的一个重要应用就是分组网间探测<strong>PING(Packet InterNet Groper)</strong>，用来测试两个主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。源主机向目的主机发送ICMP回送请求报文，目的主机就会发回ICMP回送回答报文。由于往返的ICMP报文上都有时间戳，因此容易得出往返时间。最后可以显示出的统计结果包含了发送到哪个机器（ip地址），发送的、收到的和丢失的分组数。往返时间的最小值、最大值和平均值。</p>
<p>另一个应用traceroute，用来跟踪一个分组从源点到终点的路径。<br>工作原理：<br>Tracerroute从源主机向目的主机发送一连串的IP数据报，数据报中<strong>封装的是无法交付的UDP用户数据报</strong>。第一个数据报P1的生存时间TTL设置为1,，当P1到达路径上的第一个路由器R1时，R1先收下，TTL减一，由于TTL为0了，R1就把P1丢弃，并向源主机发送一个ICMP时间超过差错报告报文。源主机接着发送第二个数据报P2，并把TTL设置为2。P2先到达路由器R1，R1收下后，将TTL减一再转发给路由器R2。R2收到P2是TTL为1，减一后TTL为0，R2丢弃P2，并向源主机发送一个时间超过差错报告报文。这样一直下去，直到最后一个数据报刚刚到达目的主机，此时数据报的TTL为1.主机不转发数据报，也不把TTL减一。但是IP数据报中封装的是无法交付的UDP用户数据报，因此目的主机要向源主机发送ICMP终点不可达差错报文。这样源主机得到了想知道的路由信息即到达目的主机所经过的路由器的IP地址，以及到达其中每一个路由器的往返时间。</p>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><p>因特网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C41.png" alt=""></p>
<p><strong>RIP路由信息协议</strong><br>该协议要求网络中每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。距离就是两个网络之间的路由器个数。所以一个路由器到直接连接的网络距离为1，中间每多个路由，距离就要加一。RIP允许一条路径最多只能包含15个路由器，因为距离等于16相当于不可达。<strong>所以RIP只适用于小型互联网</strong>。<br>特点：<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C39.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C40.png" alt=""></p>
<p><strong>OSPF开放最短路径优先</strong><br>OSPF最主要的特征就是使用分布式的链路状态协议，OSPF的三个要点和RIP的都不一样。<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C42.png" alt=""><br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C43.png" alt=""></p>
<p><strong>OSPF不用UDP而是直接用IP数据报传送</strong></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C44.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C45.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C46.png" alt=""></p>
<p><strong>BGP边界网关协议</strong></p>
<p>BGP是力求寻找一条能够到达目的网络且比较好的路由，而并非寻找一条最佳路由。BGP采用了路径向量路由选择器。<br><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C47.png" alt=""></p>
<p>边界网关协议BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列自治系统。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所要用的策略从收到的路由信息中找出到达各自治系统的较好路由。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C48.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C49.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C50.png" alt=""></p>
<h3 id="虚拟专用网vpn"><a href="#虚拟专用网vpn" class="headerlink" title="虚拟专用网vpn"></a>虚拟专用网vpn</h3><p>RFC1918指明了一些<strong>专用地址</strong>。这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。换言之，专用地址只能用作本地地址而不能用作全球地址。<strong>在因特网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</strong>。<br>采用这样的专用IP地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫做专用网。全世界可能有很多的专用互连网络具有相同的专用IP地址，但这并不会引起麻烦，因为这些专用地址仅在本机构内部使用，<strong>专用IP地址也叫做可重用地址</strong>。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C51.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C52.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C53.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C54.png" alt=""></p>
<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>NAT用于专用网内部的一些主机本来已经分配到了本地IP地址，但现在又想和因特网上的主机通信。NAT需要在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C55.png" alt=""></p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5C56.png" alt=""></p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="MTU的概念"><a href="#MTU的概念" class="headerlink" title="MTU的概念"></a>MTU的概念</h3><p>MTU（Maximum Transmission Unit）最大传输单元。是通信协议某一层上面所能通过的最大的数据包的大小（以字节为单位）<br>数据链路层的最小MTU为64字节，最大MTU为1500字节</p>
<h3 id="ARP、RARP协议"><a href="#ARP、RARP协议" class="headerlink" title="ARP、RARP协议"></a>ARP、RARP协议</h3><p><strong>ARP协议</strong>是地址解析协议，用来从网络层使用的IP地址解析出在数据链路层使用的硬件地址，解决的是同一局域网上的。==由于传送ARP分组使用的是IP协议，因此应当把ARP协议划归网络层。但ARP协议的用途是为了从网络层使用的IP地址解析出在数据链路层使用的硬件地址，有的教科书就按照协议的所用，把ARP协议划归在数据链路层==。<br><strong>4种使用ARP协议的典型情况：</strong><br>1.发送方是主机，要把IP数据报发送到本网络上的另一个主机，这时用ARP找到目的主机的硬件地址。<br>2.发送方是主机，要把IP数据报发送到另一个网络上的一个主机，这是用ARP找到本网络上的一个路由器的硬件地址<br>3.发送方是路由器，要把IP数据报发送到本网络上的一个主机，这时用ARP找到目的主机的硬件地址<br>4.发送方是路由器，要把IP数据报发送到另一个网络上的一个主机，这时用ARP找到本网络上另一个路由器的硬件地址。</p>
<p><strong>ARP查询原理</strong><br>每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。<br>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址。<br>如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。<br>此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。<br>如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中。<br>如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。<br>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。<br>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<p><strong>RARP协议</strong>是反向地址转换协议，允许<strong>局域网的物理机器</strong>从网关服务器的ARP表或者缓存上请求其IP地址。</p>
<p><strong>工作原理</strong>：</p>
<p>1.发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；<br>2.本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；<br>3.如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；<br>4.如果不存在，RARP服务器对此不做任何的响应；<br>5.源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p>
<h2 id="应用层、传输层、网络层、数据链路层的常用协议"><a href="#应用层、传输层、网络层、数据链路层的常用协议" class="headerlink" title="应用层、传输层、网络层、数据链路层的常用协议"></a>应用层、传输层、网络层、数据链路层的常用协议</h2><p>应用层：http https ftp smtp pop3 imap4 telnet dns<br>传输层：udp tcp<br>网络层：ip icmp<br>数据链路层：arp rarp</p>
<p><img src="H:%5C1.5%E5%B9%B4%E8%AE%A1%E5%88%92%5C%E7%AC%94%E8%AE%B0%5C%E9%9D%A2%E7%BB%8F%5C%E5%9B%BE%E7%89%87%5CTCPIP%E5%8D%8F%E8%AE%AE.gif" alt=""></p>
<h2 id="物理层，数据链路层，网络层的硬件设备"><a href="#物理层，数据链路层，网络层的硬件设备" class="headerlink" title="物理层，数据链路层，网络层的硬件设备"></a>物理层，数据链路层，网络层的硬件设备</h2><p>物理层：网卡、网线、集线器、中继器、调制解调器<br>数据链路层：网桥、交换机<br>网络层：路由器<br>应用层：网关</p>
<p>网桥：工作在数据链路层，根据MAC帧的目的地址对收到的帧进行转发和过滤，当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后在确定将该帧转发到哪个接口或是把它丢弃（即过滤）。</p>
<p>网关：连接两个不同的网络的设备都可以叫网关设备；网关的作用就是实现两个网络之间进行通讯与控制。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="对设计模式的理解"><a href="#对设计模式的理解" class="headerlink" title="对设计模式的理解"></a>对设计模式的理解</h2><p>在编程时，利用设计模式可以实现代码的重用性，即相同功能的代码不用多次编写；可读性强，编程规范；扩展性强，当要新增功能时方便，可维护；可靠性强，增加新的功能，对原来的功能没有影响；使得程序呈现出高内聚、低耦合的特性。</p>
<p>jdk中使用的设计模式有哪些</p>
<p>设计模式了解哪些，有什么应用</p>
<p>讲讲代理模式，静态代理和动态代理的区别？JDK代理的条件*2</p>
<p>单例模式，线程安全吗？如何改成线程安全</p>
<h2 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h2><p>单一职责、开闭原则、依赖倒置、接口隔离、合成复用、迪米特法则、里式替换</p>
<p>写一个自己认为比较完善的单例模式？我写了一个静态内部类，然后面试官看了之后说想要一个懒汉式的单例模式，我写了一个双检验的单例模式，面试官问为什么要这样写？不考虑效率的情况下怎么做比较简单呢？</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>你知道Linux怎么查看当前的负载情况么？linux负载高怎么看</p>
<p>cat、tail、vi、vim命令的区别，分别说一说？</p>
<p>如果Linux下需要打开或者查看大文件，你会怎么做？</p>
<h2 id="linux查看日志文件"><a href="#linux查看日志文件" class="headerlink" title="linux查看日志文件"></a>linux查看日志文件</h2><p>tail 参数<br>查看看日志参数：<br><code>-f</code>循环读取<br><code>-q</code>不显示处理信息<br><code>-v</code>显示详细的处理信息<br><code>-c&lt;数目&gt;</code> 显示的字节数<br><code>-n&lt;行数&gt;</code> 显示行数<br><code>--pid=PID</code> 与-f合用,表示在进程ID,PID死掉之后结束.<br><code>-q, --quiet, --silent</code>从不输出给出文件名的首部<br><code>-s, --sleep-interval=S</code> 与 <code>-f</code> 合用,表示在每次反复的间隔休眠S秒</p>
<p>日志中查找关键字（cat+grep）</p>
<p>日志太大如何处理</p>
<p>linux调试，top，ps，atop，netstat，awk</p>
<p>查看网络端口</p>
<p>用户权限控制</p>
<p>内核拷贝函数</p>
<p>ls -l出现的各个参数</p>
<p>linux io模式？</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="线程和进程的区别？-2"><a href="#线程和进程的区别？-2" class="headerlink" title="线程和进程的区别？*2"></a>线程和进程的区别？*2</h3><p>1.拥有资源，进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属于进程的资源<br>2.调度，线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换<br>3.系统开销，由于创建进程或撤销进程时，系统都要为之分配或者回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或者撤销线程时的开销。类似地，在进行进程切换时，涉及当前进程CPU环境的保存以及新调度进程CPU环境的设置，而线程切换时只需要保存和设置少量寄存器内容，开销很小<br>4.通信方面，线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。</p>
<h3 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h3><p>进程创建：系统初始化，用户请求创建一个新进程，正在运行的进程执行了创建进程的系统调用都用创建一个新进程<br>进程运行：内核选择一个就绪的进程，让它占用处理机并运行<br>进程等待（阻塞）：请求并等待系统服务，无法马上完成；启用某种操作，无法马上完成；需要的数据没有到达。前述三种情况均会造成进程等待。进程只能自己阻塞自己，进程等待不占用CPU了。<br>进程唤醒：被阻塞进程需要的资源可被满足；被阻塞的进程等待的事件到达；将该进程的PCB插入到就绪队列中。前述三种情况均会造成进程唤醒。进程只能被别的进程或操作系统唤醒。<br>进程结束：正常退出；错误退出；致命错误；被其它进程所杀。</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程的状态有5种，分别是创建、就绪、运行、终止（结束）、阻塞（等待）。<br>创建：一个进程正在被创建，还没被转到就绪态之前的状态<br>终止（结束）：一个进程正在从系统中消失时的状态，这是因为进程结束或者由于其它原因所导致的。<br>运行：当一个进程正在一个处理机上运行时<br>就绪：一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行<br>阻塞（等待）：一个进程正在等待某一事件而暂停运行时的状态，如等待资源，等待I/O完成。进程等待就不占用CPU了。</p>
<h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><p>动态性：可动态的创建，结束进程<br>并发性：进程可以被独立调度并占用处理机运行<br>独立性：不同进程的工作不互相影响<br>制约性：因访问共享数据/资源或进程间同步产生制约</p>
<h3 id="进程隔离哪些资源"><a href="#进程隔离哪些资源" class="headerlink" title="进程隔离哪些资源"></a>进程隔离哪些资源</h3><p>进程隔离是隔离两个进程的地址空间，这样在地址空间里面的资源两个进程就无法互相访问。资源有CPU 时间、内存、文件、I/O 设备等</p>
<h3 id="进程的调度，进程的切换"><a href="#进程的调度，进程的切换" class="headerlink" title="进程的调度，进程的切换"></a>进程的调度，进程的切换</h3><p><strong>何时调度</strong><br>1.创建一个新的进程后，需要决定是运行父进程还是子进程。当二者均处于就绪态，调度程序可以任意的选择子进程或者父进程开始运行<br>2.在一个进程退出时需要进行调度，必须从就绪进程中选择其他进程运行，如果没有则系统提供的空闲进程通常会运行<br>3.当进程阻塞在I/O、信号量或其他原因时，必须选择另外一个进程来运行<br>4.当I/O中断发生时，可以做出调度决策。如果中断来自I/O设备，而I/O设备已经完成了其工作，那么等待I/O的进程现在可以继续运行</p>
<p><strong>调度算法</strong><br>不同环境下需要不同的调度算法。<br>批处理系统：考虑吞吐量、周转时间、CPU利用率。先来先到，最短作业优先，最短剩余时间优先<br>交互式系统：考虑响应时间、均衡性。轮询调度，最短进程，优先级调度，多级队列，公平调度，保证调度，彩票调度<br>实时系统：满足截止时间、可预测性</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>创建进程</strong><br>Windows系统下，创建进程使用CreateProcess(filename)<br>Linux系统下，创建进程使用fork()，fork()创建一个子进程，复制父进程的所有变量和内存，复制父进程的所有CPU寄存器（有一个寄存器除外）<br>fork()的返回值：子进程的fork()返回0，父进程的fork()返回子进程的标识符即pid。如果出错返回-1</p>
<p>创建进程的一般工作：<br>1.分配一个PCB，拷贝父进程的PCB的绝大部分数据<br>2.给子进程分配资源<br>3.复制父进程的地址空间的数据<br>4.将进程状态置为就绪态，插入就绪队列</p>
<p>fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中去。在fork之后处理的文件描述符有两种常见的情况：<br>父进程等待子进程完成。在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，子进程对文件偏移量的修改和已执行的更新。<br>父子进程各自执行不同的程序段。这种情况下，在fork之后，父子进程各自关闭他们不需要使用的文件描述符，这样就不会干扰对方使用文件描述符。这种方法在网络服务进程中经常使用。</p>
<p>函数fork()会创建一个新的进程，并从内核中为此进程得到一个新的可用的进程ID，之后为这个新进程分配进程空间，并将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。所以子进程的地址空间完全和父进程分开。父子进程是两个独立的进程，接收系统调度和分配系统资源的机会均等。</p>
<p>vfork()函数也能产生子进程。其产生的子进程和父进程完全共享地址空间，包括代码段、数据段和堆栈段，子进程对这些共享资源所做的修改可以影响到父进程。vfork()产生的子进程一定比父进程先运行，也就是说父进程调用了vfork()函数后会等待子进程运行后再运行。</p>
<p><strong>加载和执行</strong><br>系统调用exec()加载程序取代当前运行的进程。exec是准备执行一个新的程序，所以当成功的执行了exec之后，后面的函数是不会执行到的。当执行exec的时候，代码数据都复制了一份，PID没有变化，但是执行的代码改变了，也就是另外程序的执行过程。exec()调用后，原先的代码段，数据段，stack&amp;heap都会被覆盖。</p>
<p><strong>等待和终止</strong><br>wait()系统调用是父进程用来等待子进程的结束。wait()系统调用担任这个要求，它使父进程去睡眠来等待子进程的结果。当一个子进程调用exit()的时候，操作系统解锁父进程，并且将通过exit()传递得到的返回值作为wait调用的一个技术，如果这里没有子进程存活，wait()立即返回。如果这里有父进程的僵尸等待，wait()立即返回其中一个值，并且解除僵尸状态。<br>exit()系统调用用来结束进程。这个系统调用将程序的结果作为一个“参数”，关闭所有打开的文件，连接等等。释放内存，释放大部分支持进程的操作系统结构，检查父进程是否存活，如果是的话，它保留结果的值，直到父进程需要它，这种情况里，进程没有真正死亡，但是它进入了僵尸状态；如果没有，它释放所有的数据结构，这个进程死亡。这个系统调用也会清理所有等待的僵尸进程。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>用户级线程</strong>：由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，并给予进程一个时间片控制。进程中的线程调度会决定哪个线程运行。线程调度的算法可以是进程调度中的任意一种，一般轮询调度和优先级调度更为常用。一个进程内的线程运行不会影响到其他进程，其他进程会得到调度程序所分配的合适份额，不会考虑该进程内部发生的事情。</p>
<p><strong>内核线程</strong>：内核选一个特定的线程运行，它不会考虑线程属于哪个进程，如果有必要的话也可以考虑。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。</p>
<p>用户级线程和内核线程之间的主要差别在于性能：用户级线程的切换需要少量的机器指令，而内核线程的切换需要完整的上下文切换，修改内存映像，使高速缓存失效，这会导致若干数量级的延迟。另一方面在使用内核级线程时，一旦线程阻塞在I/O上就不需要在用户级线程中那样将整个进程挂起。</p>
<h3 id="线程共享和独有的内容"><a href="#线程共享和独有的内容" class="headerlink" title="线程共享和独有的内容"></a>线程共享和独有的内容</h3><p>线程共享的内容包括：<br>1.进程代码段<br>2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)<br>3.进程打开的文件描述符、<br>4.信号的处理器、<br>5.进程的当前目录和<br>6.进程用户ID与进程组ID</p>
<p>线程独有的内容包括：<br>1.线程ID<br>2.寄存器组的值<br>3.线程的堆栈<br>4.错误返回码<br>5.线程的信号屏蔽码</p>
<p>操作系统的线程，以及它的状态</p>
<h3 id="进程、线程同步"><a href="#进程、线程同步" class="headerlink" title="进程、线程同步"></a>进程、线程同步</h3><p><strong>竞态条件：</strong>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件。</p>
<p><a href="https://www.cnblogs.com/youngforever/p/3250270.html" target="_blank" rel="noopener">https://www.cnblogs.com/youngforever/p/3250270.html</a><br><a href="https://www.zhihu.com/question/36529093" target="_blank" rel="noopener">https://www.zhihu.com/question/36529093</a><br><a href="https://blog.csdn.net/zxx901221/article/details/83006453" target="_blank" rel="noopener">https://blog.csdn.net/zxx901221/article/details/83006453</a></p>
<p>翻阅网上的资料，有说进程能通讯就一定是一种同步机制，也有的把这两个分开来讲。所以先讲一下线程同步的机制</p>
<p><strong>线程同步机制</strong><br><strong>1.临界区：</strong>临界区是指对共享内存进行访问的程序片段，它是一个程序片段。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。<br><strong>2.互斥量：</strong>采用互斥对象机制。只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。<br><strong>3.信号量：</strong>它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时共享资源的线程的最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。<br><strong>4.事件：</strong>通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较操作。</p>
<p><strong>总结：</strong><br>　　1． 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。<br>　　2． 互斥量（Mutex），信号量（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和线程退出。<br>　　3． 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器。</p>
<pre><code>4.    临界区不是内核对象，只能用于进程内部的线程同步，是用户方式的同步。互斥、信号量是内核对象可以用于不同进程之间的线程同步（跨进程同步）。</code></pre><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><a href="https://www.cnblogs.com/joker-wz/p/11000489.html" target="_blank" rel="noopener">https://www.cnblogs.com/joker-wz/p/11000489.html</a><br><a href="https://www.cnblogs.com/joker-wz/p/11006414.html" target="_blank" rel="noopener">https://www.cnblogs.com/joker-wz/p/11006414.html</a><br><a href="https://www.cnblogs.com/joker-wz/p/11013086.html" target="_blank" rel="noopener">https://www.cnblogs.com/joker-wz/p/11013086.html</a></p>
<p><strong>1.管道</strong><br><strong>普通/匿名管道PIPE：</strong></p>
<ul>
<li><p>管道是半双工，数据（管道的数据是字节流）只能向一个方向流动；双方需要互相通信时，需要建立起两个管道。</p>
</li>
<li><p>只能用于具有亲缘关系的进程（父子进程或者兄弟进程）之间。</p>
</li>
<li><p>管道对于两端通信的进程来说就只是一种文件，一种不属于文件系统仅存在内存中的“伪文件”。</p>
</li>
<li><p>管道的通信方式为：写端每次都将数据写入管道缓冲区的 <strong>末尾</strong> ，而读端每次都从管道缓冲区的 <strong>头部</strong> 读出数据。</p>
</li>
<li><p>读管道：</p>
<ol>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：<ul>
<li>管道写端被全部关闭，read返回0 (好像读到文件结尾)。</li>
<li>写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)。</li>
</ul>
</li>
</ol>
</li>
<li><p>写管道：</p>
<ol>
<li>管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)。</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>命名管道(FIFO)：</strong><br>FIFO常被称为命名管道，以区分管道。管道只能用于父子进程间，但FIFO不相关的进程也能使用<br>命名管道不同于匿名管道之处在于它提供了<strong>一个路径名</strong>与之关联，以命名管道的文件形式存在于文件系统中，这样，即使与命名管道的创建进程不存在亲缘关系的进程，<strong>只要可以访问该路径，就能够彼此通过命名管道相互通信</strong>，因此，通过命名管道不相关的进程也能交换数据。值的注意的是，命名管道<strong>严格遵循先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。命名管道的名字存在于文件系统中，内容存放在内存中。</p>
<p><strong>2.信号</strong></p>
<ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
</ul>
<p><strong>信号来源</strong></p>
<p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p>
<ul>
<li><p>硬件来源：用户按键输入 <code>Ctrl+C</code> 退出、硬件异常如无效的存储访问等。</p>
</li>
<li><p>软件终止：终止进程信号、其他进程调用 <code>kill</code> 函数、软件异常产生信号。</p>
<p><strong>信号生命周期和处理流程</strong></p>
</li>
</ul>
<ol>
<li>信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；</li>
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。</li>
<li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li>
</ol>
<p><strong>3.消息队列</strong></p>
<ul>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）<strong>不同的是消息队列存放在内核中</strong>，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li>
<li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</li>
</ul>
<blockquote>
<p>消息队列特点总结：</p>
<ol>
<li>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.</li>
<li>消息队列<strong>允许一个或多个进程向它写入与读取消息</strong></li>
<li>管道和消息队列的通信数据都是先进先出的原则。</li>
<li>消息队列可以实现消息的随机查询,消息<strong>不一定要以先进先出的次序读取</strong>,也可以按消息的类型读取.比FIFO更有优势。</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</li>
<li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，System V消息队列目前被大量使用。System V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ol>
</blockquote>
<p><strong>4.共享内存</strong></p>
<ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li>
</ul>
<p><strong>5.信号量</strong></p>
<p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br>为了获得共享资源，进程需要执行下列操作：</p>
<ol>
<li>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li>
<li>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li>
<li>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li>
</ol>
<p>为了正确地实现信号量，<strong>信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。</strong>Linux环境中，有三种类型：Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）。这三种信号量都可用于进程间或线程间的同步。</p>
<p><strong>6.套接字</strong></p>
<p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。<br>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。<br>套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。</p>
<h3 id="什么是守护进程"><a href="#什么是守护进程" class="headerlink" title="什么是守护进程"></a>什么是守护进程</h3><p>守护进程是运行在后台的一种特殊进程，它是独立于控制终端的，并周期性地执行某些任务。用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。</p>
<h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p><strong>孤儿进程：</strong>就是一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程，孤儿进程将被init进程（进程id为1）所收养，并由init进程对它们完成状态收集工作。因为孤儿进程会被init进程收养，所以孤儿进程不会对系统造成危害</p>
<p><strong>僵尸进程：</strong>子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为僵尸进程。僵尸进程就是一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 <code>wait()</code> 或 <code>waitpid()</code> 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 <code>wait()</code> 或 <code>waitpid()</code>，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。僵尸进程通过 <code>ps</code> 命令显示出来的状态为 <code>Z</code>。</p>
<h3 id="一个进程有哪些段"><a href="#一个进程有哪些段" class="headerlink" title="一个进程有哪些段"></a>一个进程有哪些段</h3><p>现代计算机操作系统都采用段页式管理方式，对每个进程分配一个虚拟的内存空间，将程序调入内存中进行加载。进程对应的内存空间中包含5种不同的的数据区<br>1.BSS段：通常是指用来存放程序中未初始化的全局变量的一块区域。BSS段属于静态内存分配<br>2.数据段：通常是指存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配<br>3.代码段：通常是指用来存放程序执行代码的一块内存区域。这部分区域大小在程序运行之前就已经确定，并且内存区域通常属于只读，某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。<br>4.堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）<br>5.栈（stack）：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
<p>进程线程，进程间、线程间通信方式，管道如何传输数据是否像队列一样先进先出*2</p>
<p>单个进程分配最大内存是多少</p>
<p>两个进程拥有一个共享内存，如果一个进程退出了，这个共享内存会释放吗？</p>
<p>为什么要提出多线程应用，而不是多进程应用呢？</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="什么是地址空间"><a href="#什么是地址空间" class="headerlink" title="什么是地址空间"></a>什么是地址空间</h3><p>地址空间是一个存储器抽象，为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>基本思想：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或者页面。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立即执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p>
<h3 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h3><p>指程序在执行过程中的一个较短时间，所执行的指令地址和指令的操作数地址分别局限于一定区域，表现为：<br>-&gt;时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短的时间里<br>-&gt;空间局部性：当前指令和临近的几条指令，当前访问的数据和领近的几个数据都集中在一个较小区域内<br>程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的，而且在实现了以后应该能够取得一个满意的效果的。</p>
<p>内存解决了什么问题</p>
<h3 id="如何完成虚拟地址到物理地址的映射？"><a href="#如何完成虚拟地址到物理地址的映射？" class="headerlink" title="如何完成虚拟地址到物理地址的映射？"></a>如何完成虚拟地址到物理地址的映射？</h3><p>虚拟地址空间有固定大小的单元组成，这种固定大小单元称为页(pages)。而相对的，物理内存中也有固定大小的物理单元，称为页框(page frame)。页和页框的大小一样。<br><strong>访问存在映射的页</strong><br>首先会将虚拟地址比如0送到MMU中(内存管理单元)中，MMU看到0在虚拟地址空间中落在页面哪里，根据这个映射得到对应的页框位置比如说2，因此MMU就找到物理内存中2映射的内容，MMU就将地址变换为该物理地址上的内容，对其进行访问。<br><strong>未映射的页如何映射</strong><br>若虚拟地址的页没有对应页框的位置，就会陷入缺页中断，操作系统就会选择一个很少使用的页并把它的内容写进入磁盘。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动陷入的指令。</p>
<p>虚拟地址被分为虚拟页号（高位部分）和偏移量（地位部分）。例如对于16位地址和4KB的页面大小，高4位可以指定16个虚拟页面中的一页，而低12位确定了所选页面中的偏移量（0-4095）。<br>虚拟页号可作为页表的索引来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</p>
<h3 id="加速分页过程，转换检测缓冲区-TLB"><a href="#加速分页过程，转换检测缓冲区-TLB" class="headerlink" title="加速分页过程，转换检测缓冲区(TLB)"></a>加速分页过程，转换检测缓冲区(TLB)</h3><p>虚拟地址到物理地址的映射速度必须要快，由于每次访问内存都需要进行虚拟地址到物理地址的映射，相当于要对内存进行两次访问，这与CPU直接从内存中取出想要的数据的访问性能下降一半。<br>大多数程序总是对少量页面进行多次访问，而不是对大量页面进行少量访问，因为从硬件方面为计算机设置一个小型硬件设备，能够将虚拟地址直接映射到物理地址，而不必再访问页表，即TLB，有时又称为相联存储器。<br>TLB通常位于MMU中，包含少量的表项，每个表项都记录了页面相关信息，除了虚拟页号外，其他表项都和页表一一对应。<br><strong>TLB通常位于CPU和CPU缓存之间</strong>，与CPU缓存是不同的级别，所以先去TLB找虚拟地址和物理地址的映射是比到页表中找要快的。</p>
<p><strong>工作过程</strong><br>当一个MMU中的虚拟地址需要进行转换时，硬件首先检查虚拟页号与TLB中所有的表项进行并行匹配，判断虚拟页是否在TLB中。如果找到了有效匹配项，并且要进行的访问操作没有违反保护位的话，则将页框号直接从TLB中取出而不用再直接访问页表。如果违反了保护位的权限的话，则会生成一个保护错误返回<br>当虚拟地址不在TLB中时，就会进程正常的页表查找，然后从TLB中逐出一个表项然后把从页表中找到的项放在TLB中。当一个表项被从TLB中清除出，将修改位复制到内存中页表项，除了访问位之外，其他位保持不变。当页表项从页表装入TLB中时，所有的值都来自于内存。</p>
<h3 id="针对大内存的页表（还得看）"><a href="#针对大内存的页表（还得看）" class="headerlink" title="针对大内存的页表（还得看）"></a>针对大内存的页表（还得看）</h3><p><strong>多级页面</strong><br>引入多级页表的原因是避免把全部页表一直保存在内存中。不需要的页表就不应该保留。<br>多级页表它由两个或多个层次的分页表组成，也称为分层分页。级别1页面表的条目指向级别2页面表的指针，级别2页面表的条目指向级别3页面表的指针，依次类推，最后一级页表存储的是实际的信息。</p>
<p><strong>倒排页表、反向页表</strong><br>页表来表示物理地址(页帧)号，而不是之前的逻辑地址(页号)，能够减少页表尺寸，但是给映射关系的建立带来点困难。</p>
<h3 id="在操作系统中，有寄存器，高速缓存，主存，虚拟内存，外存，有知道它们之间有什么样的关系，以及它们的作用是啥？"><a href="#在操作系统中，有寄存器，高速缓存，主存，虚拟内存，外存，有知道它们之间有什么样的关系，以及它们的作用是啥？" class="headerlink" title="在操作系统中，有寄存器，高速缓存，主存，虚拟内存，外存，有知道它们之间有什么样的关系，以及它们的作用是啥？"></a>在操作系统中，有寄存器，高速缓存，主存，虚拟内存，外存，有知道它们之间有什么样的关系，以及它们的作用是啥？</h3><p>寄存器：存储器系统的顶层是CPU中的寄存器，和CPU一样快</p>
<p>高速缓存：</p>
<p>主存：主存就是内存系统的主力军，主存通常叫做RAM(Random Access Memory)随机存储器，所有不能在高速缓存中得到满足的内存访问请求都会转往主存中。</p>
<p>虚拟内存：程序运行时需要的使用内存，但多个程序运行需要的内存总是比实际的内存要大的，这样内存就不够用。所以为了保证能让多个进程正常运行，将磁盘空间的一部分拿来当做内存使用，存放进程运行时暂时不需要的部分。当需要的时候再从虚拟内存中装入物理内存。</p>
<p>外存：外存应该就是硬盘、软盘、U盘、光盘等，此类存储器一般断电后仍能保存数据，但读取的速度很慢</p>
<h3 id="就是当我们的主存满了，或者虚存满了，那么需要存在一个换页操作，你知道有哪些换页算法么？"><a href="#就是当我们的主存满了，或者虚存满了，那么需要存在一个换页操作，你知道有哪些换页算法么？" class="headerlink" title="就是当我们的主存满了，或者虚存满了，那么需要存在一个换页操作，你知道有哪些换页算法么？"></a>就是当我们的主存满了，或者虚存满了，那么需要存在一个换页操作，你知道有哪些换页算法么？</h3><p>当发生缺页异常时，操作系统会选择一个页面进行换出从而为新进来的页面腾出空间。如果要换出的页面在内存中已经被修改，那么必须将其写到磁盘中以使磁盘副本保持最新状态。如果页面没有被修改过，并且磁盘中的副本也已经是最新的，那么就不需要进行重写。那么就直接使用调入的页面覆盖需要移除的页面就可以了。</p>
<p><strong>最优页面置换算法：</strong>当一个缺页中断发生时，对于保存在内存中的每一个逻辑页面，计算在它的下一次访问之前，还需要等待多时间，从中选择等待时间最长的那个，作为被置换的页面。<br><strong>先进先出算法：</strong>通过维护一个页面的链表来记录它们装入内存的顺序。淘汰的是最老的页面。但是该页面可能仍在使用，因此FIFO算法不是一个好的选择。<br><strong>最近未使用算法（nru）：</strong>在大部分具有虚拟内存的计算机中，系统为每一页面设置了两个状态位。当页面被访问（读或写）时设置R位；当页面被写入（即修改时）时设置M位。每次访问内存时更新这些位，因此由硬件来设置它们是必要的。当启动一个进程时，它的所有页面的两个位都由操作系统设置成0,。R位被定期地清零，以区别最近没有被访问的页面和被访问的页面。当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位的值，分成4类：<br>第0类：没有被访问，没有被修改。<br>第1类：没有被访问，已被修改。<br>第2类：已被访问，没有被修改。<br>第3类：已被访问，已被修改。<br>NRU算法随机地从编号最小的非空类中挑选一个页面淘汰。<br><strong>最近最久未使用算法（lru）：</strong>缺页中断时，置换未使用时间最长的页面。是一种优秀的算法，但只能通过特定的硬件来实现。<br><strong>老化算法：</strong>用计数器来关联该页面访问情况。首先在R位被加进来之前先将计数器右移一位；其次，将R位加到计数器最左端的位而不是最右端的位。发生缺页中断时，将置换计数器值最小的页面。<br><strong>最近最少使用（lfu）：</strong><br><strong>时钟页面置换算法：</strong>是对二次机会算法的另一种实现，具有相同的性能特征，而且只需要更少的执行时间。<br><strong>二次机会算法：</strong>对FIFO算法的改进，它在移出页面前先检查该页面是否正在被使用。如果该页面正在被使用，就保留该页面。<br><strong>工作集页面置换算法：</strong>当发生缺页中断时，淘汰一个不在工作集中的页面。工作集就是最近k次内存访问所使用过的页面的集合。要完成这个需要比较大的开销，所以使用一种近似的方法就是考虑执行时间，这样工作集的定义就变成在过去τ秒实际运行时间中内存访问所用到的页面集合。<br>工作方式：在每个时钟滴答中，处理每个表项，都需要检查R位。如果它是1，就把当前实际时间写进页表项的“上次使用时间”域，以表示缺页中断发生时该页面正在被使用。既然该页面在时钟滴答中已经被访问过，那么很明显它应该出现在工作集中，并且不该被删除。如果R是0，那么表示在当前时钟中，该页面还没有被访问过，则它就可以作为候选者被置换。计算出它的生存时间（即当前实际时间减去上次使用时间），然后与τ比较，若大于则这个页面不应该在工作集中，而用新的页面置换。若小于，则该页面仍然在工作集中，将其临时保留下来。但是要记录生存时间最长（即上次使用时间的最小值）的页面。如果扫描完整个页表却没有找到合适被淘汰的页面，也就意味着所有的页面都在工作集中。在这各种情况下，如果找到了一个或者多个R=0的页面，就淘汰生存时间最长的页面。在最坏的情况下，在当前时间中，所有页面都被访问过也就是R = 1，因此就随机选择一个页面淘汰，如果有的话最好选一个干净页面。<br><strong>工作集时钟页面置换算法：</strong>与时钟算法一样，每次缺页中断时，首先检查指针指向的页面。如果R为被置为1，该页面在当前时钟中就被使用过，那么该页面就不适合被淘汰。然后把该页面的R位置为0，指针指向下一个页面，并重复该算法。当R为0时，如果页面的生存时间大于τ，并且该页面是干净的，它就不在工作集中，并且在磁盘上有个有效的副本。申请次页框，并把新页面放在其没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，继续对下一个页面进行操作。如果指针经过一圈返回起点，若至少调度了一次写操作，指针仅仅是不停地移动，寻找一个干净页面，既然已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为干净。若没有调度过写操作，则所有的页面都在工作集中，否则至少调度了一个写操作，由于缺乏额外信息，一个简单的方法就是随便置换一个干净的页面来使用。</p>
<h2 id="用户态、内核态-2"><a href="#用户态、内核态-2" class="headerlink" title="用户态、内核态*2"></a>用户态、内核态*2</h2><p>内核态与用户态是操作系统的两种运行级别。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。</p>
<p>主要差别：处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理机是可被抢占的；而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占有的处理机是不允许被抢占的。</p>
<p>导致用户态切换到内核态的三种情况：<br><strong>1.系统调用</strong><br>这是用户态<strong>主动要求</strong>切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()函数。<br><strong>2.异常</strong><br>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常<br><strong>3.外围设备的中断</strong><br>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号， 这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信 号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬 盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<h2 id="IO多路复用是什么？多路复用运用的场景？"><a href="#IO多路复用是什么？多路复用运用的场景？" class="headerlink" title="IO多路复用是什么？多路复用运用的场景？"></a>IO多路复用是什么？多路复用运用的场景？</h2><p>IO多路复用就是使用一个进程或者线程去同时监听每一个IO的连接或者内核中的文件描述符。若有新的请求，则该进程或者线程就会通知服务器进行数据的接收读取。实现这个操作需要用到多路复用器即select,poll,epoll。poll在select的基础上，去掉了select给定的只能最多处理1024个客户端连接的限制，并不会再修改传入该方法的参数数组。epoll是在poll的基础上，使其变成了线程安全的（不会因为通信过程中其它线程关掉了已经加入到select或者poll中的IO流而产生未知的后果），同时会告知服务端具体是哪个IO流来了数据，不需要靠服务器自己去找。</p>
<p><strong>运用场景：</strong><br>客户端要处理多个socket<br>客户端同时处理连接和用户输入，比如聊天室<br>TCP服务器要同时处理监听socket和连接socket<br>服务器同时处理TCP和UDP<br>服务器要监听多个端口</p>
<p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<h2 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h2><p>协程是一种比线程更加轻量级的存在，一个线程可以拥有多个协程。协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行），这样切换协程就不会像切换线程那样消耗资源。<br><a href="https://blog.csdn.net/zheng199172/article/details/88800275" target="_blank" rel="noopener">https://blog.csdn.net/zheng199172/article/details/88800275</a></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是应用程序向系统内核请求服务的方式。可以包括硬件相关的服务（如访问硬盘等），或者创建新进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。</p>
<h2 id="软连接和硬链接区别？"><a href="#软连接和硬链接区别？" class="headerlink" title="软连接和硬链接区别？"></a>软连接和硬链接区别？</h2><p>硬链接就是在目录下创建一个条目，记录着文件名与inode编号，这个inode就是源文件的inode。删除任意一个条目，文件还是存在的，只要引用数不为0。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。</p>
<p>软链接也就是符号链接，保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为Windows的快捷方式。当源文件被删除了，链接文件就打不开了。因为记录的是路径，所以可以为目录建立符号链接。软链接也就是新建立一个文件，这个文件就是专门用来指向别的文件的，删了这个软链接文件，那就等于不需要这个链接，和原来存在的实体源文件没有任何关系。</p>
<h2 id="操作系统中引入缓冲的主要原因"><a href="#操作系统中引入缓冲的主要原因" class="headerlink" title="操作系统中引入缓冲的主要原因"></a>操作系统中引入缓冲的主要原因</h2><p>1.改善CPU与I/O设备间速度不匹配的矛盾<br>例如一个程序，它时而进行长时间的计算而没有输出，时而又阵发性把输出送到打印机。由于打印机的速度跟不上CPU，而使得CPU长时间的等待，如果设置了缓冲区，程序输出的数据先送到缓冲区暂存，然后由打印机慢慢地输出。这是，CPU不必等待，可以继续执行程序。实现了CPU与I/O设备之间的并行工作。事实上，凡在数据的到达速率与其离去速率不同的地方，都可设置缓冲，以缓和它们速度不匹配的矛盾。众所周知，通常的程序都是时而计算，时而输出的。</p>
<p>2.可以减少对CPU中断频率，放宽对中断响应时间的限制<br>如果I/O操作每传送一个字节就要产生一次中断，那么设置了n个字节的缓冲区后，则可以等到缓冲区满才产生中断，这样中断次数就减少到1/n，而且中断响应的时间也可以相应的放宽</p>
<p>3.提高CPU和I/O设备之间的并行性<br>缓冲的引入可显著提高CPU和设备的并行操作程度，提高系统的吞吐量和设备的利用率。</p>
<h2 id="进程A和B，A-0X123AA-10-B-0X123AA-20-问题：在多core-cpu环境下，A和B进程同时运行时，会不会出现写冲突、数据被覆盖的情况"><a href="#进程A和B，A-0X123AA-10-B-0X123AA-20-问题：在多core-cpu环境下，A和B进程同时运行时，会不会出现写冲突、数据被覆盖的情况" class="headerlink" title="进程A和B，A:  *(0X123AA) = 10; B:  *(0X123AA) = 20; 问题：在多core cpu环境下，A和B进程同时运行时，会不会出现写冲突、数据被覆盖的情况"></a>进程A和B，A:  *(0X123AA) = 10; B:  *(0X123AA) = 20; 问题：在多core cpu环境下，A和B进程同时运行时，会不会出现写冲突、数据被覆盖的情况</h2><p>会出现写冲突。若该内存为共享内存时就会出现写冲突。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的4个特征"><a href="#死锁的4个特征" class="headerlink" title="死锁的4个特征"></a>死锁的4个特征</h3><p>1.互斥：资源一旦被使用则其他的进程就不应该运用这个资源。处理器，i/o通道，主和副存储器，设备和数据结构，如文件，数据库和信号量都可以看作是资源的一种形式<br>2.持有并等待：进程保持至少一个资源正在等待获取其他进程持有的额外资源<br>3.无抢占：一个资源只能被进程自愿释放，其他进程无法去抢夺这个资源<br>4.循环并等待：存在等待进程集合{P0,P1,P2,..,PN}，P0正在等待P1所占的资源，P1正在等待P2占用的资源，… ，PN-1正在等待PN所占用的资源，PN正在等待P0所占用的资源。</p>
<p>死锁出现肯定有这四个条件，但这四个特征出现并不意味着死锁的出现</p>
<h3 id="死锁处理办法"><a href="#死锁处理办法" class="headerlink" title="死锁处理办法"></a>死锁处理办法</h3><p>4种死锁处理的办法，分别是死锁预防，死锁避免，死锁检测，死锁恢复。这个四个方法从左至右约束一个比一个弱。</p>
<p><strong>死锁预防</strong><br>思路：只要将前述四个条件打破其中一个，那么就不会出现死锁<br>1.互斥：本来资源是互斥的，通过使资源不互斥<br>2.占用并等待：将条件变大，拿资源就拿全部的资源才去执行，否则不拿资源去睡眠。但是在不同的执行过程中，需要的资源不同，导致一直占用资源但是没有使用，所以会导致系统资源的利用率低，可能发生饥饿<br>3.不抢占：直接将进程kill掉，也就是将资源抢占过来，但比较暴力不合理<br>4.循环等待：死锁的出现会出现一个环，打破这个环可以实现死锁的预防。如果对资源类型进行排序，进程按资源顺序进行申请，也就是资源只能往上申请，这样就不会形成循环 的圈，但前提是将资源排好序</p>
<p><strong>死锁避免</strong><br>思路：当进程在申请资源的过程中，判断这个申请合不合理，如果会存在死锁的概率，就会拒绝这个请求。这里涉及到一个银行家算法。</p>
<p><strong>银行家算法</strong><br>前提条件：<br>多个实例；<br>每个进程都必须能最大限度地利用资源<br>当一个进程请求一个资源，就不得不等待<br>当一个进程获得所有的资源就必须在一段有限的时间释放它们<br>算法设计：<br>Max进程对一个资源总需求量、Available资源的剩余空闲量、Allocation资源对一个进程已分配量、Need进程对一个资源的未来需要量。一条关系式为Need = Max - Allocation<br>简单的执行过程是：当一个进程对一系列资源进程请求时即request，若request &lt; Available那么就可以获取，但是在获取后，需要判断接下来运行时，系统是否会发生死锁，即是否出现不安全状态，若出现则这个request还是不能被请求的。具体的过程可看笔记中的银行家算法。</p>
<p><strong>死锁检测</strong><br>死锁检测允许系统进入unsafe状态，在某个状态判断当前的系统是否出现死锁，如果是就启动恢复机制；如果没有就继续执行，将死锁的检测放在了系统运行之中。<br>大致思路：允许系统进入死锁状态，然后进行死锁检测算法，若出现则启动恢复机制</p>
<p><strong>死锁恢复</strong><br>终止所有的死锁进程<br>在一个时间内终止一个进程直到死锁消除<br>终止进程的顺序：进程的优先级、进程运行了多久以及需要多少时间才能完成、进程占用的资源、进程完成需要的资源、多少进程需要被终止、进程是交互还是批处理<br>选择一个受害者<br>回滚，返回到一些安全状态，重启进程到安全状态<br>饥饿，同一进程可能一直被选作受害者，包括回滚的数量。<br>以上方法在某种程度上都存在强制性和不合理性，所以死锁恢复是最后的手段。</p>
<h1 id="数据结构与基础"><a href="#数据结构与基础" class="headerlink" title="数据结构与基础"></a>数据结构与基础</h1><h2 id="排序算法哪些是稳定的，为什么直接插入排序是稳定的"><a href="#排序算法哪些是稳定的，为什么直接插入排序是稳定的" class="headerlink" title="排序算法哪些是稳定的，为什么直接插入排序是稳定的"></a>排序算法哪些是稳定的，为什么直接插入排序是稳定的</h2><p>稳定的定义：稳定的算法在排序的过程中不会改变元素彼此的位置的相对次序<br>稳定的：插入排序、冒泡排序、归并排序、基数排序<br>不稳定：堆排序、快速排序、希尔排序、选择排序</p>
<h2 id="各个排序的时间和空间复杂度"><a href="#各个排序的时间和空间复杂度" class="headerlink" title="各个排序的时间和空间复杂度"></a>各个排序的时间和空间复杂度</h2><table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最坏)</th>
<th>时间复杂度(最好)</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>复杂性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlog2n)</td>
<td>O(n2)</td>
<td>O(n1.3)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>直接选择排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>简单</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog2n)</td>
<td>O(n2)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(n)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(n+r)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
</tbody></table>
<p>红黑树了解哪些、红黑树和其他平衡树有什么不同</p>
<p>堆的各种操作的数据结构以及时间复杂度</p>
<p>堆排序的思路，时空复杂度</p>
<p>前缀树了解吗？说一下结构</p>
<p>最短路径算法</p>
<p>有向图是否有环</p>
<p>如何判断两个链表有交点</p>
<p>如何判断链表有环</p>
<p>如何判断链表的环入口</p>
<p>KMP算法</p>
<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><p>二叉搜索树转链表，空间复杂度O(1)，讲讲时间复杂度*2</p>
<p>64匹马8个赛道找出速度前四的马的最少次数*2</p>
<p>二叉树求和 leetcode129，讲一下时间复杂度</p>
<p>回文串判断</p>
<p>给一个链表，奇数为递减，偶数位递增，不使用额外空间，进行排序实现全部递增</p>
<p>给定一个数组，不改变其中的数字，变更为字典序的下一位</p>
<p>01矩阵最大正方形</p>
<p>二叉树找target路径</p>
<p>优先队列和</p>
<p>相同元素（相邻排序）里查找唯一元素</p>
<p>有n个人过河，他们过桥花的时间可能不相同，但是一次最多只能两个人过河，有一个手电筒，每次过河还要有手电筒才行。问：最短的时间是多少？</p>
<p>一个int数组，找出两个异或最大的数字，时间要求O(n)</p>
<p>四个int数组，从每个数组里面挑一个数，加起来等于指定数，要求打印出所有非重复的组合，时间要求最大(n2)</p>
<p>求二叉树最长路径*2</p>
<p>找波谷数</p>
<p>复制带随机指针的单向链表</p>
<p>使用固定长度的数组实现队列没要求O(1)</p>
<p>求最大岛屿面积</p>
<p>给定固定数组 arr = {1，-1,0,8,20,10}； target = 7， 找出数组两个相加等于target， 要求 空间复杂度O（1）， 时间复杂度越低越好。快排+双指针</p>
<p>给定一个数 num = 62425， k = 1，去掉 k 的数之后 剩下的最大。贪心 用栈</p>
<p>给一棵二叉树和一个整数，要求输出二叉树中路径和等于这个整数的路径。</p>
<p>判断两个字符串是否同构。</p>
<p>哈夫曼编码</p>
<h2 id="10G文件的字典序排序、2G内存"><a href="#10G文件的字典序排序、2G内存" class="headerlink" title="10G文件的字典序排序、2G内存"></a>10G文件的字典序排序、2G内存</h2><p>使用桶排序，下面链接是10g文件，2g内存找出中位数<br><a href="https://blog.csdn.net/oppo62258801/article/details/78296765" target="_blank" rel="noopener">https://blog.csdn.net/oppo62258801/article/details/78296765</a></p>
<p>实现一个二叉查找树（实现插入和查询功能）、如果存入的值是任意对象如何处理、如何删除一个节点如何处理</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>Jmeter压测的时候为什么会丢包</p>
<p>用户登录如何实现（主要考察Session和Cookie的关系）</p>
<p>Cookie如何传输</p>
<p>RPC有了解吗</p>
<p>为什么选择RabbitMQ</p>
<p>cookie 的 用户ID 被假冒，怎么防伪</p>
<p>介绍项目的难点</p>
<h2 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h2><h3 id="如何解决超卖问题"><a href="#如何解决超卖问题" class="headerlink" title="如何解决超卖问题"></a>如何解决超卖问题</h3><p>1.利用数据库本身的隔离级别，SQL加库存数量判断：防止库存变为负数<br>2.使用Redis的原子操作，采用Redis的原子操作SETNX和EXPIRE方法来实现一种“分布式锁”，进而控制高并发多线程对共享资源的访问</p>
<p>rabbitMQ消费端出现异常如何处理<br>项目里用到threadlocal了，说一下原理<br>如果手机端和pc端同时登陆，就想下两次单，应该怎么办？(面试官提示说可以不一定要在服务端生成订单，可以考虑在请求的时候，或者用一些订单生成算法？)<br>如何保证库存一致性？库存多了或者少了有啥影响？<br>下订单和付钱的事务怎么控制？如果有人下订单未付钱如何回滚事务？<br>那回滚库存之后，和redis不一致如何处理？如果硬要保证redis和db库存一致，如何保证？<br>如果用户能够秒杀订单，但支付时放弃如何处理</p>
<h3 id="如果限定30分钟后不支付自动取消订单，如何处理"><a href="#如果限定30分钟后不支付自动取消订单，如何处理" class="headerlink" title="如果限定30分钟后不支付自动取消订单，如何处理"></a>如果限定30分钟后不支付自动取消订单，如何处理</h3><p>使用RabbitMQ中的死信队列和TTL构成的延时队列。在确定可以秒杀时，除了给RabbitMQ发送下订单的消息外，还将相应的信息入死信队列，并制定TTL时间为30分钟。这样过了30分钟还未支付，这个消息就会进入死信队列，然后被相应的消费者消费来取消订单。</p>
<h2 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h2><p>如何设计管理员和非管理员<br>若管理员分为超级管理员、普通管理员如何设计<br>回复文章的评论、回复评论的评论是如何设计的<br>返回给前端的评论的数据结构是什么样子的</p>
<h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="海量评论系统，实现以下功能-提交评论，查看热门评论，查看最新评论，查看我的评论。从数据库，缓存的应用、服务器，到前端如何实现。"><a href="#海量评论系统，实现以下功能-提交评论，查看热门评论，查看最新评论，查看我的评论。从数据库，缓存的应用、服务器，到前端如何实现。" class="headerlink" title="海量评论系统，实现以下功能 提交评论，查看热门评论，查看最新评论，查看我的评论。从数据库，缓存的应用、服务器，到前端如何实现。"></a>海量评论系统，实现以下功能 提交评论，查看热门评论，查看最新评论，查看我的评论。从数据库，缓存的应用、服务器，到前端如何实现。</h2><h2 id="12306抢票设计"><a href="#12306抢票设计" class="headerlink" title="12306抢票设计"></a>12306抢票设计</h2><p>1.存储位置：存到redis被引导了一波，可以直接存到物理内存上，如何保证分布式一致性？不超卖？<br>2.票如何设置原子性，怎么划分？</p>
<h2 id="停车系统"><a href="#停车系统" class="headerlink" title="停车系统"></a>停车系统</h2>
    </div>

    
    
    

    <div>
	
	  <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

	
   </div>

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/14/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/" rel="prev" title="华为实习面经">
      <i class="fa fa-chevron-left"></i> 华为实习面经
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/15/%E8%87%AA%E5%B7%B1%E9%9D%A2%E7%BB%8F/" rel="next" title="自己面经">
      自己面经 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaSE"><span class="nav-number">1.</span> <span class="nav-text">JavaSE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#讲一下java的三个特性、多态-2、封装有什么用"><span class="nav-number">1.1.</span> <span class="nav-text">讲一下java的三个特性、多态*2、封装有什么用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int和Integer区别"><span class="nav-number">1.2.</span> <span class="nav-text">int和Integer区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#i-i-、i-、i-i、-i"><span class="nav-number">1.3.</span> <span class="nav-text">i &#x3D; i++、i++、i&#x3D;++i、++i</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深拷贝、浅拷贝"><span class="nav-number">1.4.</span> <span class="nav-text">深拷贝、浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接口和抽象类有什么区别"><span class="nav-number">1.4.1.</span> <span class="nav-text">接口和抽象类有什么区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#讲一下String三个类的区别"><span class="nav-number">1.5.</span> <span class="nav-text">讲一下String三个类的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String拼接怎么做到的"><span class="nav-number">1.6.</span> <span class="nav-text">String拼接怎么做到的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和链表的区别"><span class="nav-number">1.7.</span> <span class="nav-text">数组和链表的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arraylist和LinkedList区别，ArrayList的初始大小"><span class="nav-number">1.8.</span> <span class="nav-text">Arraylist和LinkedList区别，ArrayList的初始大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java泛型机制了解吗"><span class="nav-number">1.9.</span> <span class="nav-text">Java泛型机制了解吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK源码看过哪些-2"><span class="nav-number">1.10.</span> <span class="nav-text">JDK源码看过哪些*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap遍历键值对的方法，哪种方式速度最快？"><span class="nav-number">1.11.</span> <span class="nav-text">HashMap遍历键值对的方法，哪种方式速度最快？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap的键如果是自定义类，会有什么问题？"><span class="nav-number">1.12.</span> <span class="nav-text">HashMap的键如果是自定义类，会有什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap底层实现原理，如何进行put的"><span class="nav-number">1.13.</span> <span class="nav-text">HashMap底层实现原理，如何进行put的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何计算Hash值"><span class="nav-number">1.14.</span> <span class="nav-text">如何计算Hash值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap线程安全吗？为什么不安全？"><span class="nav-number">1.15.</span> <span class="nav-text">HashMap线程安全吗？为什么不安全？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap内部是怎么实现的（数组-红黑树-链表）-2"><span class="nav-number">1.16.</span> <span class="nav-text">HashMap内部是怎么实现的（数组+红黑树&#x2F;链表）*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希冲突怎么办？为什么都用链地址法？"><span class="nav-number">1.17.</span> <span class="nav-text">哈希冲突怎么办？为什么都用链地址法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap底层扩容（扩容因子为什么是0-75？扩容之后的数组落在哪？为啥容量一定是2的倍数？为什么引入红黑树？红黑树的参数？并发的时候怎么处理）-2"><span class="nav-number">1.18.</span> <span class="nav-text">HashMap底层扩容（扩容因子为什么是0.75？扩容之后的数组落在哪？为啥容量一定是2的倍数？为什么引入红黑树？红黑树的参数？并发的时候怎么处理）*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#想获得线程安全的HashMap有哪些方式"><span class="nav-number">1.19.</span> <span class="nav-text">想获得线程安全的HashMap有哪些方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap如何保证线程安全，如何分段，锁粒度，扩容rehash的过程，size如何计算-3"><span class="nav-number">1.20.</span> <span class="nav-text">ConcurrentHashMap如何保证线程安全，如何分段，锁粒度，扩容rehash的过程，size如何计算*3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap和concurrentHashMap分别的应用场景，区别？"><span class="nav-number">1.21.</span> <span class="nav-text">HashMap和concurrentHashMap分别的应用场景，区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap底层，以及对时间复杂度是否有变慢"><span class="nav-number">1.22.</span> <span class="nav-text">LinkedHashMap底层，以及对时间复杂度是否有变慢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakHashMap的使用场景，实现原理"><span class="nav-number">1.23.</span> <span class="nav-text">WeakHashMap的使用场景，实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射了解吗"><span class="nav-number">1.24.</span> <span class="nav-text">反射了解吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阐述一下java-jar-main的整个运行过程"><span class="nav-number">1.25.</span> <span class="nav-text">阐述一下java jar main的整个运行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何读入文档最后N行？"><span class="nav-number">1.26.</span> <span class="nav-text">如何读入文档最后N行？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的异常体系"><span class="nav-number">1.27.</span> <span class="nav-text">Java的异常体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static关键字的作用（在类上、方法上、变量上）"><span class="nav-number">1.28.</span> <span class="nav-text">static关键字的作用（在类上、方法上、变量上）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-number">1.29.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写equals方法"><span class="nav-number">1.30.</span> <span class="nav-text">重写equals方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">2.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM的组成-内存结构？-3"><span class="nav-number">2.1.</span> <span class="nav-text">JVM的组成&#x2F;内存结构？*3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象创建的内存分配"><span class="nav-number">2.2.</span> <span class="nav-text">对象创建的内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">2.3.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常量池存在的意义"><span class="nav-number">2.4.</span> <span class="nav-text">常量池存在的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU过高的原因有哪些？"><span class="nav-number">2.5.</span> <span class="nav-text">CPU过高的原因有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哪些区域会出现OOM？遇见OOM该如何分析？"><span class="nav-number">2.6.</span> <span class="nav-text">哪些区域会出现OOM？遇见OOM该如何分析？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM的调优工具有哪些？"><span class="nav-number">2.7.</span> <span class="nav-text">JVM的调优工具有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏是什么？怎么解决？内存泄漏的场景有哪些？如何处理内存泄漏的场景？-2"><span class="nav-number">2.8.</span> <span class="nav-text">内存泄漏是什么？怎么解决？内存泄漏的场景有哪些？如何处理内存泄漏的场景？*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何判断对象需要被回收"><span class="nav-number">2.9.</span> <span class="nav-text">如何判断对象需要被回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法-2"><span class="nav-number">2.10.</span> <span class="nav-text">垃圾收集算法*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么分为新生代和老年代"><span class="nav-number">2.11.</span> <span class="nav-text">为什么分为新生代和老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象何时晋升到老年代"><span class="nav-number">2.12.</span> <span class="nav-text">对象何时晋升到老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么不在新生代使用标记整理算法？或者在老年代使用复制算法？"><span class="nav-number">2.13.</span> <span class="nav-text">为什么不在新生代使用标记整理算法？或者在老年代使用复制算法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新生代中为什么要分为Eden和Survivor？区域的比例？为什么要设置两个Survivor区？"><span class="nav-number">2.14.</span> <span class="nav-text">新生代中为什么要分为Eden和Survivor？区域的比例？为什么要设置两个Survivor区？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发可达性分析"><span class="nav-number">2.15.</span> <span class="nav-text">并发可达性分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#何时会触发full-gc"><span class="nav-number">2.16.</span> <span class="nav-text">何时会触发full gc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS垃圾回收器"><span class="nav-number">2.17.</span> <span class="nav-text">CMS垃圾回收器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Garbage-First收集器"><span class="nav-number">2.18.</span> <span class="nav-text">Garbage First收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Java的内存模型？"><span class="nav-number">2.19.</span> <span class="nav-text">什么是Java的内存模型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java如何做到并发三要素的？"><span class="nav-number">2.20.</span> <span class="nav-text">Java如何做到并发三要素的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有了解过Volatile么？谈谈你对Volatile的理解"><span class="nav-number">2.21.</span> <span class="nav-text">有了解过Volatile么？谈谈你对Volatile的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile如何保证可见性的？以及如何实现可见性的机制。"><span class="nav-number">2.22.</span> <span class="nav-text">Volatile如何保证可见性的？以及如何实现可见性的机制。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果大量的使用Volatile存在什么问题？"><span class="nav-number">2.23.</span> <span class="nav-text">如果大量的使用Volatile存在什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有人说JVM拖累了java效率，你是怎么理解的，JVM的设计理念有哪里让你感觉比较惊艳，感触比较深？（面试官说JVM的推出是为了跨平台，JVM何去何从，怎么演变，及变化趋势）"><span class="nav-number">2.24.</span> <span class="nav-text">有人说JVM拖累了java效率，你是怎么理解的，JVM的设计理念有哪里让你感觉比较惊艳，感触比较深？（面试官说JVM的推出是为了跨平台，JVM何去何从，怎么演变，及变化趋势）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何打破双亲委派机制"><span class="nav-number">2.25.</span> <span class="nav-text">如何打破双亲委派机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的四种引用"><span class="nav-number">2.26.</span> <span class="nav-text">Java的四种引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-number">3.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized的底层原理"><span class="nav-number">3.1.</span> <span class="nav-text">synchronized的底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized锁状态的转换"><span class="nav-number">3.2.</span> <span class="nav-text">synchronized锁状态的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一般创建线程的几种方式"><span class="nav-number">3.3.</span> <span class="nav-text">一般创建线程的几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍一下线程池"><span class="nav-number">3.4.</span> <span class="nav-text">介绍一下线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池创建的方法有哪些（线程池的主要参数），如果没有达到设定最大线程数，等待队列满了如何进行操作"><span class="nav-number">3.5.</span> <span class="nav-text">线程池创建的方法有哪些（线程池的主要参数），如果没有达到设定最大线程数，等待队列满了如何进行操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池原理"><span class="nav-number">3.6.</span> <span class="nav-text">线程池原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大空闲时间是用来做什么的？"><span class="nav-number">3.7.</span> <span class="nav-text">最大空闲时间是用来做什么的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞队列有哪些"><span class="nav-number">3.8.</span> <span class="nav-text">阻塞队列有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的submit策略操作如何实现"><span class="nav-number">3.9.</span> <span class="nav-text">线程池的submit策略操作如何实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的饱和策略（拒绝策略）"><span class="nav-number">3.10.</span> <span class="nav-text">线程池的饱和策略（拒绝策略）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#乐观锁和悲观锁的区别"><span class="nav-number">3.11.</span> <span class="nav-text">乐观锁和悲观锁的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-number">3.12.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS底层使用了模板方法模式"><span class="nav-number">3.12.0.0.1.</span> <span class="nav-text">AQS底层使用了模板方法模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#讲一下ThreadLocal"><span class="nav-number">3.13.</span> <span class="nav-text">讲一下ThreadLocal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS原理"><span class="nav-number">3.14.</span> <span class="nav-text">CAS原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写锁介绍一下？并手写一个读写锁"><span class="nav-number">3.15.</span> <span class="nav-text">读写锁介绍一下？并手写一个读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock的实现原理"><span class="nav-number">3.16.</span> <span class="nav-text">ReentrantLock的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和重入锁的区别"><span class="nav-number">3.17.</span> <span class="nav-text">synchronized和重入锁的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现线程同步的方法"><span class="nav-number">3.18.</span> <span class="nav-text">实现线程同步的方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL"><span class="nav-number">4.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL的整体结构"><span class="nav-number">4.1.</span> <span class="nav-text">MySQL的整体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inner-join、right-join、left-join的区别"><span class="nav-number">4.2.</span> <span class="nav-text">inner join、right join、left join的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL的底层索引结构，InnoDB里面的B-Tree？"><span class="nav-number">4.3.</span> <span class="nav-text">MySQL的底层索引结构，InnoDB里面的B+Tree？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB和MyISAM区别"><span class="nav-number">4.4.</span> <span class="nav-text">InnoDB和MyISAM区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB是通过什么支持事务的？"><span class="nav-number">4.5.</span> <span class="nav-text">InnoDB是通过什么支持事务的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Tree-和-B-Tree的区别-3"><span class="nav-number">4.6.</span> <span class="nav-text">B Tree 和 B+ Tree的区别*3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库表删除数据，B-树的空洞问题。"><span class="nav-number">4.7.</span> <span class="nav-text">数据库表删除数据，B+树的空洞问题。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何用select语句创建索引（可能记错，是如何用SQL语句创建）？"><span class="nav-number">4.8.</span> <span class="nav-text">如何用select语句创建索引（可能记错，是如何用SQL语句创建）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#百万级别或以上的数据如何删除"><span class="nav-number">4.9.</span> <span class="nav-text">百万级别或以上的数据如何删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#联合索引、联合查询"><span class="nav-number">4.10.</span> <span class="nav-text">联合索引、联合查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主键索引和非主键索引有什么区别"><span class="nav-number">4.11.</span> <span class="nav-text">主键索引和非主键索引有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聊聊MySQL索引的发展过程？是一来就是B-Tree的么？从-没有索引、hash、二叉排序树、AVL树、B树、B-树-聊。"><span class="nav-number">4.12.</span> <span class="nav-text">聊聊MySQL索引的发展过程？是一来就是B+Tree的么？从 没有索引、hash、二叉排序树、AVL树、B树、B+树 聊。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主键使用自增ID还是UUID？"><span class="nav-number">4.13.</span> <span class="nav-text">主键使用自增ID还是UUID？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL中如果使用like进行模糊匹配的时候，是否会使用索引？一定不会用么？"><span class="nav-number">4.14.</span> <span class="nav-text">MySQL中如果使用like进行模糊匹配的时候，是否会使用索引？一定不会用么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-的having，order-by如何走索引"><span class="nav-number">4.15.</span> <span class="nav-text">MySQL 的having，order by如何走索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash索引和B-树所有有什么区别或者说优劣呢"><span class="nav-number">4.16.</span> <span class="nav-text">Hash索引和B+树所有有什么区别或者说优劣呢?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈MySQL里面的事务，说说什么是事务？"><span class="nav-number">4.17.</span> <span class="nav-text">谈谈MySQL里面的事务，说说什么是事务？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务四大特性ACID讲一讲-2"><span class="nav-number">4.18.</span> <span class="nav-text">事务四大特性ACID讲一讲*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID如何实现"><span class="nav-number">4.19.</span> <span class="nav-text">ACID如何实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL里面有哪些事务级别，并且不同的事务级别会出现什么问题？-2"><span class="nav-number">4.20.</span> <span class="nav-text">MySQL里面有哪些事务级别，并且不同的事务级别会出现什么问题？*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务并发有哪些问题？"><span class="nav-number">4.21.</span> <span class="nav-text">事务并发有哪些问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈可重复读和幻读的区别？"><span class="nav-number">4.22.</span> <span class="nav-text">谈谈可重复读和幻读的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务通过什么回滚删除插入失败的数据"><span class="nav-number">4.23.</span> <span class="nav-text">事务通过什么回滚删除插入失败的数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库有哪些锁？"><span class="nav-number">4.24.</span> <span class="nav-text">数据库有哪些锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql的锁，什么情况下会锁住整张表？"><span class="nav-number">4.25.</span> <span class="nav-text">mysql的锁，什么情况下会锁住整张表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是页锁？"><span class="nav-number">4.26.</span> <span class="nav-text">什么是页锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库MVCC的实现"><span class="nav-number">4.27.</span> <span class="nav-text">数据库MVCC的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快照发生在什么时候？"><span class="nav-number">4.28.</span> <span class="nav-text">快照发生在什么时候？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么保证update的正确性？"><span class="nav-number">4.29.</span> <span class="nav-text">怎么保证update的正确性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是间隙锁"><span class="nav-number">4.30.</span> <span class="nav-text">什么是间隙锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可重复读是怎么解决幻读的问题的"><span class="nav-number">4.31.</span> <span class="nav-text">可重复读是怎么解决幻读的问题的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聊聊索引，我给你写个表，看看下面的查询语句，走了那些索引？"><span class="nav-number">4.32.</span> <span class="nav-text">聊聊索引，我给你写个表，看看下面的查询语句，走了那些索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果你在MySQL中遇到一些慢查询，有什么解决方法么？"><span class="nav-number">4.33.</span> <span class="nav-text">如果你在MySQL中遇到一些慢查询，有什么解决方法么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈explain即执行计划？执行的explain后，出现的哪些字段，能够帮助我们呢？"><span class="nav-number">4.34.</span> <span class="nav-text">谈谈explain即执行计划？执行的explain后，出现的哪些字段，能够帮助我们呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库连接池"><span class="nav-number">4.35.</span> <span class="nav-text">数据库连接池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JTA事务和普通事务"><span class="nav-number">4.36.</span> <span class="nav-text">JTA事务和普通事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL一条语句的执行过程，解析过程？查询缓存？怎么判断是否命中？"><span class="nav-number">4.37.</span> <span class="nav-text">MySQL一条语句的执行过程，解析过程？查询缓存？怎么判断是否命中？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL的执行计划"><span class="nav-number">4.38.</span> <span class="nav-text">MySQL的执行计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL注入"><span class="nav-number">4.39.</span> <span class="nav-text">SQL注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库的三大范式"><span class="nav-number">4.40.</span> <span class="nav-text">数据库的三大范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java与数据库的连接"><span class="nav-number">4.41.</span> <span class="nav-text">Java与数据库的连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">5.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关系型数据库和非关系型数据库的区别，有哪些非关系型数据库？"><span class="nav-number">5.1.</span> <span class="nav-text">关系型数据库和非关系型数据库的区别，有哪些非关系型数据库？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的应用场景有哪些"><span class="nav-number">5.2.</span> <span class="nav-text">Redis的应用场景有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis为什么采用单线程而不是多线程以及为什么Redis这么快"><span class="nav-number">5.3.</span> <span class="nav-text">Redis为什么采用单线程而不是多线程以及为什么Redis这么快</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String类型的底层原理讲一下"><span class="nav-number">5.4.</span> <span class="nav-text">String类型的底层原理讲一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的ZSet底层是什么结构？跳表，介绍一下，画一下基本结构，搜索插入数据过程，时间复杂度"><span class="nav-number">5.5.</span> <span class="nav-text">Redis的ZSet底层是什么结构？跳表，介绍一下，画一下基本结构，搜索插入数据过程，时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis字典的实现"><span class="nav-number">5.6.</span> <span class="nav-text">Redis字典的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重哈希怎么实现，重哈希是同步还是异步，哈希键还有用什么数据结构"><span class="nav-number">5.7.</span> <span class="nav-text">重哈希怎么实现，重哈希是同步还是异步，哈希键还有用什么数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis，它会存在线程切换的问题么"><span class="nav-number">5.8.</span> <span class="nav-text">Redis，它会存在线程切换的问题么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈Redis单线程模型和IO多路复用"><span class="nav-number">5.9.</span> <span class="nav-text">谈谈Redis单线程模型和IO多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的大Key的问题，如果有个Value的大小是2M，会有什么问题么？最大支持的Value大小是多少？（实际开发中最大支持的value是多少仍需查找）"><span class="nav-number">5.10.</span> <span class="nav-text">Redis的大Key的问题，如果有个Value的大小是2M，会有什么问题么？最大支持的Value大小是多少？（实际开发中最大支持的value是多少仍需查找）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主从复制原理"><span class="nav-number">5.11.</span> <span class="nav-text">主从复制原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈Redis集群-Redis-Cluster？"><span class="nav-number">5.12.</span> <span class="nav-text">谈谈Redis集群 Redis Cluster？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说Redis中的哨兵，即Redis-Sentinel"><span class="nav-number">5.13.</span> <span class="nav-text">说说Redis中的哨兵，即Redis Sentinel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对于Redis来说，使用悲观锁更吃力还是使用乐观锁更吃力"><span class="nav-number">5.14.</span> <span class="nav-text">对于Redis来说，使用悲观锁更吃力还是使用乐观锁更吃力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈Redis如何实现分布式锁？-3"><span class="nav-number">5.15.</span> <span class="nav-text">谈谈Redis如何实现分布式锁？*3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈Redis中缓存穿透的问题，以及解决的方法？布隆过滤器有了解过么？"><span class="nav-number">5.16.</span> <span class="nav-text">谈谈Redis中缓存穿透的问题，以及解决的方法？布隆过滤器有了解过么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis中大面积的缓存失效，然后请求全部打到数据库，有什么解决方法？"><span class="nav-number">5.17.</span> <span class="nav-text">Redis中大面积的缓存失效，然后请求全部打到数据库，有什么解决方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#当你通过jedis进行连接redis的时候，已经和一个进程连接了-，redis还能够和其它的进程进行通信么？"><span class="nav-number">5.18.</span> <span class="nav-text">当你通过jedis进行连接redis的时候，已经和一个进程连接了 ，redis还能够和其它的进程进行通信么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis每秒能够处理处理十万请求，如果按照你上面说的，那说明它每次交互只在-1-十万-秒内完成？"><span class="nav-number">5.19.</span> <span class="nav-text">Redis每秒能够处理处理十万请求，如果按照你上面说的，那说明它每次交互只在 1&#x2F;十万 秒内完成？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis源码是否看过"><span class="nav-number">5.20.</span> <span class="nav-text">Redis源码是否看过</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么Nosql比sql快？主要有什么优缺点"><span class="nav-number">5.21.</span> <span class="nav-text">为什么Nosql比sql快？主要有什么优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL用了B-Tree，Redis中的SortSet内部用了跳跃表，他们之间有什么差别？为什么MySQL不用跳跃表，或者是Redis不用B-Tree呢？（还得再查询资料）"><span class="nav-number">5.22.</span> <span class="nav-text">MySQL用了B+Tree，Redis中的SortSet内部用了跳跃表，他们之间有什么差别？为什么MySQL不用跳跃表，或者是Redis不用B+Tree呢？（还得再查询资料）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何保证Redis的高可用"><span class="nav-number">5.23.</span> <span class="nav-text">如何保证Redis的高可用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的ttl指令底层实现，Redis过期策略"><span class="nav-number">5.24.</span> <span class="nav-text">Redis的ttl指令底层实现，Redis过期策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis持久化，各个持久化的参数，开启持久化会影响性能吗"><span class="nav-number">5.25.</span> <span class="nav-text">Redis持久化，各个持久化的参数，开启持久化会影响性能吗</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">6.</span> <span class="nav-text">RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么使用MQ？"><span class="nav-number">6.1.</span> <span class="nav-text">为什么使用MQ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ和其它消息队列，比如ActiveMQ，RocketMQ，Kafka有什么区别"><span class="nav-number">6.2.</span> <span class="nav-text">RabbitMQ和其它消息队列，比如ActiveMQ，RocketMQ，Kafka有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ有哪些组件-2"><span class="nav-number">6.3.</span> <span class="nav-text">RabbitMQ有哪些组件*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主流MQ有哪些"><span class="nav-number">6.4.</span> <span class="nav-text">主流MQ有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何保证消息的顺序性"><span class="nav-number">6.5.</span> <span class="nav-text">如何保证消息的顺序性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息基于什么传输"><span class="nav-number">6.6.</span> <span class="nav-text">消息基于什么传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#讲讲消费模式和刷盘策略"><span class="nav-number">6.7.</span> <span class="nav-text">讲讲消费模式和刷盘策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ的特性"><span class="nav-number">6.8.</span> <span class="nav-text">RabbitMQ的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ的延时队列"><span class="nav-number">6.9.</span> <span class="nav-text">RabbitMQ的延时队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-number">7.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring的IOC和DI"><span class="nav-number">7.1.</span> <span class="nav-text">Spring的IOC和DI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC初始化过程"><span class="nav-number">7.2.</span> <span class="nav-text">IOC初始化过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DI相关注解"><span class="nav-number">7.3.</span> <span class="nav-text">DI相关注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DI的过程"><span class="nav-number">7.4.</span> <span class="nav-text">DI的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bean的生命周期"><span class="nav-number">7.5.</span> <span class="nav-text">bean的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bean的作用范围-作用域"><span class="nav-number">7.6.</span> <span class="nav-text">bean的作用范围&#x2F;作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何通过XML方式创建Bean"><span class="nav-number">7.7.</span> <span class="nav-text">如何通过XML方式创建Bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何通过注解创建Bean"><span class="nav-number">7.8.</span> <span class="nav-text">如何通过注解创建Bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何通过注解配置文件"><span class="nav-number">7.9.</span> <span class="nav-text">如何通过注解配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactory、FactoryBean和ApplicationContext的区别"><span class="nav-number">7.10.</span> <span class="nav-text">BeanFactory、FactoryBean和ApplicationContext的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring的AOP"><span class="nav-number">7.11.</span> <span class="nav-text">Spring的AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP的相关注解有哪些"><span class="nav-number">7.12.</span> <span class="nav-text">AOP的相关注解有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP的相关术语有什么"><span class="nav-number">7.13.</span> <span class="nav-text">AOP的相关术语有什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP过程"><span class="nav-number">7.14.</span> <span class="nav-text">AOP过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring哪里用到了反射"><span class="nav-number">7.15.</span> <span class="nav-text">Spring哪里用到了反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring循环依赖如何解决"><span class="nav-number">7.16.</span> <span class="nav-text">Spring循环依赖如何解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring生命周期"><span class="nav-number">7.17.</span> <span class="nav-text">Spring生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring用了哪些设计模式"><span class="nav-number">7.18.</span> <span class="nav-text">Spring用了哪些设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Resource和-Autowired的区别"><span class="nav-number">7.19.</span> <span class="nav-text">@Resource和@Autowired的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringMVC"><span class="nav-number">8.</span> <span class="nav-text">SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC的处理流程"><span class="nav-number">8.1.</span> <span class="nav-text">SpringMVC的处理流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC有哪些组件"><span class="nav-number">8.2.</span> <span class="nav-text">SpringMVC有哪些组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC的相关注解"><span class="nav-number">8.3.</span> <span class="nav-text">SpringMVC的相关注解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MyBatis"><span class="nav-number">9.</span> <span class="nav-text">MyBatis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis的优缺点"><span class="nav-number">9.1.</span> <span class="nav-text">MyBatis的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis的XML文件有哪些标签属性"><span class="nav-number">9.2.</span> <span class="nav-text">MyBatis的XML文件有哪些标签属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis的一级缓存是什么"><span class="nav-number">9.3.</span> <span class="nav-text">MyBatis的一级缓存是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis的二级缓存是什么"><span class="nav-number">9.4.</span> <span class="nav-text">MyBatis的二级缓存是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis-和-的区别"><span class="nav-number">9.5.</span> <span class="nav-text">MyBatis#{}和${}的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis中Mapper标注的接口中的方法可以重载吗"><span class="nav-number">9.6.</span> <span class="nav-text">MyBatis中Mapper标注的接口中的方法可以重载吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><span class="nav-number">9.7.</span> <span class="nav-text">通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL数据库里面有个自增主键，希望在MyBatis中新增的时候能够反返回数据库中的自增主键，怎么配置？如果是非自增主键呢？"><span class="nav-number">9.8.</span> <span class="nav-text">MySQL数据库里面有个自增主键，希望在MyBatis中新增的时候能够反返回数据库中的自增主键，怎么配置？如果是非自增主键呢？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot"><span class="nav-number">10.</span> <span class="nav-text">Spring Boot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-boot有哪些提升？"><span class="nav-number">10.1.</span> <span class="nav-text">spring boot有哪些提升？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-boot-starter的过程"><span class="nav-number">10.2.</span> <span class="nav-text">spring boot starter的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-自动配置原理是什么？"><span class="nav-number">10.3.</span> <span class="nav-text">Spring Boot 自动配置原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-是否可以使用-XML-配置"><span class="nav-number">10.4.</span> <span class="nav-text">Spring Boot 是否可以使用 XML 配置 ?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ElasticSearch"><span class="nav-number">11.</span> <span class="nav-text">ElasticSearch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch为什么查询比MySQL快？"><span class="nav-number">11.1.</span> <span class="nav-text">ElasticSearch为什么查询比MySQL快？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES中的translog"><span class="nav-number">11.2.</span> <span class="nav-text">ES中的translog</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程-Netty"><span class="nav-number">12.</span> <span class="nav-text">网络编程 Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍一下IO模型（BIO-NIO）"><span class="nav-number">12.1.</span> <span class="nav-text">介绍一下IO模型（BIO,NIO）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select到epoll有哪些改进"><span class="nav-number">12.2.</span> <span class="nav-text">select到epoll有哪些改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-IO多路复用模型实现机制详解"><span class="nav-number">12.3.</span> <span class="nav-text">epoll IO多路复用模型实现机制详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select和poll之间的区别是什么"><span class="nav-number">12.4.</span> <span class="nav-text">select和poll之间的区别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll套接字的实现"><span class="nav-number">12.5.</span> <span class="nav-text">epoll套接字的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#水平触发和边缘触发"><span class="nav-number">12.6.</span> <span class="nav-text">水平触发和边缘触发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#除了阻塞I-O的其他I-O，用epoll来网络编程的客户端和服务端的步骤"><span class="nav-number">12.7.</span> <span class="nav-text">除了阻塞I&#x2F;O的其他I&#x2F;O，用epoll来网络编程的客户端和服务端的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-NIO"><span class="nav-number">12.8.</span> <span class="nav-text">Java NIO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#负载均衡了解哪些算法"><span class="nav-number">12.9.</span> <span class="nav-text">负载均衡了解哪些算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一致性hash的好处，如果节点比较少会出现什么问题"><span class="nav-number">12.10.</span> <span class="nav-text">一致性hash的好处，如果节点比较少会出现什么问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor-模型有了解吗"><span class="nav-number">12.11.</span> <span class="nav-text">Reactor 模型有了解吗</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">13.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用层"><span class="nav-number">13.1.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见应用层协议使用UDP或TCP来传输"><span class="nav-number">13.1.1.</span> <span class="nav-text">常见应用层协议使用UDP或TCP来传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下面聊聊Http-Code，你知道-3XX-状态码对应的是什么？"><span class="nav-number">13.1.2.</span> <span class="nav-text">下面聊聊Http Code，你知道 3XX 状态码对应的是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用状态码有哪些，分别什么意思？如404-302-502-503。503和502的区别"><span class="nav-number">13.1.3.</span> <span class="nav-text">常用状态码有哪些，分别什么意思？如404,302,502,503。503和502的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http报文结构"><span class="nav-number">13.1.4.</span> <span class="nav-text">http报文结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http了解吗？讲一讲"><span class="nav-number">13.1.5.</span> <span class="nav-text">Http了解吗？讲一讲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#详细介绍一下HTTP请求响应的过程"><span class="nav-number">13.1.6.</span> <span class="nav-text">详细介绍一下HTTP请求响应的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http1-0和Http1-1区别"><span class="nav-number">13.1.7.</span> <span class="nav-text">Http1.0和Http1.1区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http2-0、https了解吗？讲一下连接过程（非对称加密，对称加密）-2"><span class="nav-number">13.1.8.</span> <span class="nav-text">http2.0、https了解吗？讲一下连接过程（非对称加密，对称加密）*2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http和https的区别"><span class="nav-number">13.1.9.</span> <span class="nav-text">http和https的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#https加密过程-2"><span class="nav-number">13.1.10.</span> <span class="nav-text">https加密过程*2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS-SSL的过程"><span class="nav-number">13.1.11.</span> <span class="nav-text">TLS&#x2F;SSL的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-Hello"><span class="nav-number">13.1.11.1.</span> <span class="nav-text">Client Hello</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Server-Hello"><span class="nav-number">13.1.11.2.</span> <span class="nav-text">Server Hello</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Certificate"><span class="nav-number">13.1.11.3.</span> <span class="nav-text">Certificate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Server-Key-Exchange"><span class="nav-number">13.1.11.4.</span> <span class="nav-text">Server Key Exchange</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Certificate-Request"><span class="nav-number">13.1.11.5.</span> <span class="nav-text">Certificate Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Server-Hello-Done"><span class="nav-number">13.1.11.6.</span> <span class="nav-text">Server Hello Done</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Certificate-Verify"><span class="nav-number">13.1.11.7.</span> <span class="nav-text">Certificate Verify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-Key-Exchange"><span class="nav-number">13.1.11.8.</span> <span class="nav-text">Client Key Exchange</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Change-Cipher-Spec-Client"><span class="nav-number">13.1.11.9.</span> <span class="nav-text">Change Cipher Spec(Client)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Encrypted-Handshake-Message-Client"><span class="nav-number">13.1.11.10.</span> <span class="nav-text">Encrypted Handshake Message(Client)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Change-Cipher-Spec-Server"><span class="nav-number">13.1.11.11.</span> <span class="nav-text">Change Cipher Spec(Server)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Encrypted-Handshake-Message-Server"><span class="nav-number">13.1.11.12.</span> <span class="nav-text">Encrypted Handshake Message(Server)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-Data"><span class="nav-number">13.1.11.13.</span> <span class="nav-text">Application Data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器输入URL到页面展示经历的过程"><span class="nav-number">13.1.12.</span> <span class="nav-text">浏览器输入URL到页面展示经历的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电子邮件系统中，用户代理把邮件发往发送发邮件服务器、发送方邮件服务器把邮件发往接收方邮件服务器以及用户使用用户代理从接收方邮件服务器上读取邮件时，使用的协议"><span class="nav-number">13.1.13.</span> <span class="nav-text">电子邮件系统中，用户代理把邮件发往发送发邮件服务器、发送方邮件服务器把邮件发往接收方邮件服务器以及用户使用用户代理从接收方邮件服务器上读取邮件时，使用的协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS的实现"><span class="nav-number">13.1.14.</span> <span class="nav-text">HTTPS的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http中GET与POST的区别"><span class="nav-number">13.1.15.</span> <span class="nav-text">Http中GET与POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器图片怎么加载的？"><span class="nav-number">13.1.16.</span> <span class="nav-text">浏览器图片怎么加载的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS详细说下？为啥要这么设计？为什么域名服务器要分级设计？"><span class="nav-number">13.1.17.</span> <span class="nav-text">DNS详细说下？为啥要这么设计？为什么域名服务器要分级设计？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件传送协议FTP"><span class="nav-number">13.1.18.</span> <span class="nav-text">文件传送协议FTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie存放在http协议中的哪个位置"><span class="nav-number">13.1.19.</span> <span class="nav-text">Cookie存放在http协议中的哪个位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie和Session是什么以及区别"><span class="nav-number">13.1.20.</span> <span class="nav-text">Cookie和Session是什么以及区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送邮件需要用到的协议"><span class="nav-number">13.1.21.</span> <span class="nav-text">发送邮件需要用到的协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传输层"><span class="nav-number">13.2.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#端口号"><span class="nav-number">13.2.1.</span> <span class="nav-text">端口号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP、UDP区别-2"><span class="nav-number">13.2.2.</span> <span class="nav-text">TCP、UDP区别*2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP可靠连接用什么保证-2"><span class="nav-number">13.2.3.</span> <span class="nav-text">TCP可靠连接用什么保证*2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP如何实现可靠传输"><span class="nav-number">13.2.4.</span> <span class="nav-text">UDP如何实现可靠传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大tcp连接数跟什么有关"><span class="nav-number">13.2.5.</span> <span class="nav-text">最大tcp连接数跟什么有关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP中的MSS和MTU"><span class="nav-number">13.2.6.</span> <span class="nav-text">TCP中的MSS和MTU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三次握手、四次挥手各个状态名称-2"><span class="nav-number">13.2.7.</span> <span class="nav-text">三次握手、四次挥手各个状态名称*2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器端大量出现close-wait是什么原因？"><span class="nav-number">13.2.8.</span> <span class="nav-text">服务器端大量出现close_wait是什么原因？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP三次握手，为什么是3次，不是2次，挥手为什么4次-2"><span class="nav-number">13.2.9.</span> <span class="nav-text">TCP三次握手，为什么是3次，不是2次，挥手为什么4次*2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP三次握手发了什么？syn的全名"><span class="nav-number">13.2.10.</span> <span class="nav-text">TCP三次握手发了什么？syn的全名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP三次握手对应哪些系统调用"><span class="nav-number">13.2.11.</span> <span class="nav-text">TCP三次握手对应哪些系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有个半连接、全连接状态，对应到具体哪步状态"><span class="nav-number">13.2.12.</span> <span class="nav-text">有个半连接、全连接状态，对应到具体哪步状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP拥塞控制和流量控制-3"><span class="nav-number">13.2.13.</span> <span class="nav-text">TCP拥塞控制和流量控制*3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞如何解决？"><span class="nav-number">13.2.14.</span> <span class="nav-text">拥塞如何解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIME-WAIT的作用-2"><span class="nav-number">13.2.15.</span> <span class="nav-text">TIME_WAIT的作用*2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIME-WAIT为什么是2MSL，如何解决TIME-WAIT状态过多"><span class="nav-number">13.2.16.</span> <span class="nav-text">TIME_WAIT为什么是2MSL，如何解决TIME_WAIT状态过多</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写过socket编程吗？"><span class="nav-number">13.2.17.</span> <span class="nav-text">写过socket编程吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#校园网都是局域网，怎么访问外网？NAT。-它又问NAT具体是怎么回事。"><span class="nav-number">13.2.18.</span> <span class="nav-text">校园网都是局域网，怎么访问外网？NAT。 它又问NAT具体是怎么回事。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用UDP传数据一次传4k好还是4次传1k好"><span class="nav-number">13.2.19.</span> <span class="nav-text">用UDP传数据一次传4k好还是4次传1k好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何判断数据发送完了？"><span class="nav-number">13.2.20.</span> <span class="nav-text">如何判断数据发送完了？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计一种方法解决粘包问题"><span class="nav-number">13.2.21.</span> <span class="nav-text">设计一种方法解决粘包问题?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果客户端突然出现故障，tcp连接会怎么样"><span class="nav-number">13.2.22.</span> <span class="nav-text">如果客户端突然出现故障，tcp连接会怎么样</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络层"><span class="nav-number">13.3.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ip数据报"><span class="nav-number">13.3.1.</span> <span class="nav-text">ip数据报</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP分片"><span class="nav-number">13.3.2.</span> <span class="nav-text">IP分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP地址"><span class="nav-number">13.3.3.</span> <span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#划分子网"><span class="nav-number">13.3.4.</span> <span class="nav-text">划分子网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网际控制报文协议ICMP"><span class="nav-number">13.3.5.</span> <span class="nav-text">网际控制报文协议ICMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ICMP的应用举例"><span class="nav-number">13.3.6.</span> <span class="nav-text">ICMP的应用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由协议"><span class="nav-number">13.3.7.</span> <span class="nav-text">路由协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟专用网vpn"><span class="nav-number">13.3.8.</span> <span class="nav-text">虚拟专用网vpn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络地址转换NAT"><span class="nav-number">13.3.9.</span> <span class="nav-text">网络地址转换NAT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据链路层"><span class="nav-number">13.4.</span> <span class="nav-text">数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MTU的概念"><span class="nav-number">13.4.1.</span> <span class="nav-text">MTU的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP、RARP协议"><span class="nav-number">13.4.2.</span> <span class="nav-text">ARP、RARP协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用层、传输层、网络层、数据链路层的常用协议"><span class="nav-number">13.5.</span> <span class="nav-text">应用层、传输层、网络层、数据链路层的常用协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理层，数据链路层，网络层的硬件设备"><span class="nav-number">13.6.</span> <span class="nav-text">物理层，数据链路层，网络层的硬件设备</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式"><span class="nav-number">14.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对设计模式的理解"><span class="nav-number">14.1.</span> <span class="nav-text">对设计模式的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式的原则"><span class="nav-number">14.2.</span> <span class="nav-text">设计模式的原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux"><span class="nav-number">15.</span> <span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linux查看日志文件"><span class="nav-number">15.1.</span> <span class="nav-text">linux查看日志文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统"><span class="nav-number">16.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程"><span class="nav-number">16.1.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程和进程的区别？-2"><span class="nav-number">16.1.1.</span> <span class="nav-text">线程和进程的区别？*2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的生命周期"><span class="nav-number">16.1.2.</span> <span class="nav-text">进程的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的状态"><span class="nav-number">16.1.3.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的特点"><span class="nav-number">16.1.4.</span> <span class="nav-text">进程的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程隔离哪些资源"><span class="nav-number">16.1.5.</span> <span class="nav-text">进程隔离哪些资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的调度，进程的切换"><span class="nav-number">16.1.6.</span> <span class="nav-text">进程的调度，进程的切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制"><span class="nav-number">16.1.7.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程调度"><span class="nav-number">16.1.8.</span> <span class="nav-text">线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程共享和独有的内容"><span class="nav-number">16.1.9.</span> <span class="nav-text">线程共享和独有的内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程、线程同步"><span class="nav-number">16.1.10.</span> <span class="nav-text">进程、线程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信"><span class="nav-number">16.1.11.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是守护进程"><span class="nav-number">16.1.12.</span> <span class="nav-text">什么是守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#孤儿进程和僵尸进程"><span class="nav-number">16.1.13.</span> <span class="nav-text">孤儿进程和僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个进程有哪些段"><span class="nav-number">16.1.14.</span> <span class="nav-text">一个进程有哪些段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">16.2.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是地址空间"><span class="nav-number">16.2.1.</span> <span class="nav-text">什么是地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟内存"><span class="nav-number">16.2.2.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的局部性原理"><span class="nav-number">16.2.3.</span> <span class="nav-text">程序的局部性原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何完成虚拟地址到物理地址的映射？"><span class="nav-number">16.2.4.</span> <span class="nav-text">如何完成虚拟地址到物理地址的映射？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加速分页过程，转换检测缓冲区-TLB"><span class="nav-number">16.2.5.</span> <span class="nav-text">加速分页过程，转换检测缓冲区(TLB)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#针对大内存的页表（还得看）"><span class="nav-number">16.2.6.</span> <span class="nav-text">针对大内存的页表（还得看）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在操作系统中，有寄存器，高速缓存，主存，虚拟内存，外存，有知道它们之间有什么样的关系，以及它们的作用是啥？"><span class="nav-number">16.2.7.</span> <span class="nav-text">在操作系统中，有寄存器，高速缓存，主存，虚拟内存，外存，有知道它们之间有什么样的关系，以及它们的作用是啥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#就是当我们的主存满了，或者虚存满了，那么需要存在一个换页操作，你知道有哪些换页算法么？"><span class="nav-number">16.2.8.</span> <span class="nav-text">就是当我们的主存满了，或者虚存满了，那么需要存在一个换页操作，你知道有哪些换页算法么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户态、内核态-2"><span class="nav-number">16.3.</span> <span class="nav-text">用户态、内核态*2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO多路复用是什么？多路复用运用的场景？"><span class="nav-number">16.4.</span> <span class="nav-text">IO多路复用是什么？多路复用运用的场景？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程是什么？"><span class="nav-number">16.5.</span> <span class="nav-text">协程是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用"><span class="nav-number">16.6.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软连接和硬链接区别？"><span class="nav-number">16.7.</span> <span class="nav-text">软连接和硬链接区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统中引入缓冲的主要原因"><span class="nav-number">16.8.</span> <span class="nav-text">操作系统中引入缓冲的主要原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程A和B，A-0X123AA-10-B-0X123AA-20-问题：在多core-cpu环境下，A和B进程同时运行时，会不会出现写冲突、数据被覆盖的情况"><span class="nav-number">16.9.</span> <span class="nav-text">进程A和B，A:  *(0X123AA) &#x3D; 10; B:  *(0X123AA) &#x3D; 20; 问题：在多core cpu环境下，A和B进程同时运行时，会不会出现写冲突、数据被覆盖的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">16.10.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的4个特征"><span class="nav-number">16.10.1.</span> <span class="nav-text">死锁的4个特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁处理办法"><span class="nav-number">16.10.2.</span> <span class="nav-text">死锁处理办法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构与基础"><span class="nav-number">17.</span> <span class="nav-text">数据结构与基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法哪些是稳定的，为什么直接插入排序是稳定的"><span class="nav-number">17.1.</span> <span class="nav-text">排序算法哪些是稳定的，为什么直接插入排序是稳定的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各个排序的时间和空间复杂度"><span class="nav-number">17.2.</span> <span class="nav-text">各个排序的时间和空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法题"><span class="nav-number">18.</span> <span class="nav-text">算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10G文件的字典序排序、2G内存"><span class="nav-number">18.1.</span> <span class="nav-text">10G文件的字典序排序、2G内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#项目"><span class="nav-number">19.</span> <span class="nav-text">项目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#秒杀"><span class="nav-number">19.1.</span> <span class="nav-text">秒杀</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何解决超卖问题"><span class="nav-number">19.1.1.</span> <span class="nav-text">如何解决超卖问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果限定30分钟后不支付自动取消订单，如何处理"><span class="nav-number">19.1.2.</span> <span class="nav-text">如果限定30分钟后不支付自动取消订单，如何处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#论坛"><span class="nav-number">19.2.</span> <span class="nav-text">论坛</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#场景题"><span class="nav-number">20.</span> <span class="nav-text">场景题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#海量评论系统，实现以下功能-提交评论，查看热门评论，查看最新评论，查看我的评论。从数据库，缓存的应用、服务器，到前端如何实现。"><span class="nav-number">20.1.</span> <span class="nav-text">海量评论系统，实现以下功能 提交评论，查看热门评论，查看最新评论，查看我的评论。从数据库，缓存的应用、服务器，到前端如何实现。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12306抢票设计"><span class="nav-number">20.2.</span> <span class="nav-text">12306抢票设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停车系统"><span class="nav-number">20.3.</span> <span class="nav-text">停车系统</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="詹智健"
      src="/images/A%20lemon.jpg">
  <p class="site-author-name" itemprop="name">詹智健</p>
  <div class="site-description" itemprop="description">今天也是很多个开心日子里开心的一天呀</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SsssshiFT-96" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SsssshiFT-96" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">詹智健</span>
</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共190.5k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
